<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Behaviors/FearBehaviour.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Behaviors/FearBehaviour.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;        private Vector3 fearZonePosition;&#10;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;        private void CheckPlayerInZone()&#10;        {&#10;            var distanceToPlayer = Vector3.Distance(fearZonePosition, BossController.Player.position);&#10;            var currentlyInZone = distanceToPlayer &lt;= Config.phase2.fearZoneRadius;&#10;            &#10;            if (currentlyInZone)&#10;            {&#10;                if (!playerInZone)&#10;                {&#10;                    playerInZone = true;&#10;                    playerInZoneTime = 0f;&#10;                    StartHeartbeatSound();&#10;                }&#10;                playerInZoneTime += Time.deltaTime;&#10;            }&#10;            else&#10;            {&#10;                if (!playerInZone) return;&#10;                playerInZone = false;&#10;                playerInZoneTime = 0f;&#10;                StopHeartbeatSound();&#10;            }&#10;        }&#10;&#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (Config.audioConfig.heartbeatSound == null) return;&#10;            BossController.AudioSource.clip = Config.audioConfig.heartbeatSound;&#10;            BossController.AudioSource.loop = true;&#10;            BossController.AudioSource.Play();&#10;        }&#10;&#10;        private void StopHeartbeatSound()&#10;        {&#10;            BossController.AudioSource.Stop();&#10;            BossController.AudioSource.loop = false;&#10;        }&#10;&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;        private Vector3 fearZonePosition;&#10;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;                StartHeartbeatSound();&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;                StopHeartbeatSound();&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;&#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (Config.audioConfig.heartbeatSound == null) return;&#10;            BossController.AudioSource.clip = Config.audioConfig.heartbeatSound;&#10;            BossController.AudioSource.loop = true;&#10;            BossController.AudioSource.Play();&#10;        }&#10;&#10;        private void StopHeartbeatSound()&#10;        {&#10;            BossController.AudioSource.Stop();&#10;            BossController.AudioSource.loop = false;&#10;        }&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossBehaviors.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossBehaviors.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Decoy (bóng ảo) - di chuyển chậm theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyBehavior : MonoBehaviour&#10;    {&#10;        private BossController bossController;&#10;        private bool isReal;&#10;        private float moveSpeed;&#10;        private Transform target;&#10;        &#10;        public bool IsReal =&gt; isReal;&#10;&#10;        public void Initialize(BossController controller, bool real, float speed)&#10;        {&#10;            bossController = controller;&#10;            isReal = real;&#10;            moveSpeed = speed;&#10;            target = controller.Player;&#10;            &#10;            // Visual differences between real and fake decoy could be added here&#10;            if (!isReal)&#10;            {&#10;                // Make fake decoy slightly different (transparency, color, etc.)&#10;                var renderer = GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = renderer.material;&#10;                    var color = material.color;&#10;                    color.a = 0.8f; // Slightly transparent&#10;                    material.color = color;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                MoveTowardsTarget();&#10;            }&#10;        }&#10;&#10;        private void MoveTowardsTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            transform.position += direction * moveSpeed * Time.deltaTime;&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;))&#10;            {&#10;                HandlePlayerContact();&#10;            }&#10;        }&#10;&#10;        private void HandlePlayerContact()&#10;        {&#10;            if (isReal)&#10;            {&#10;                // Player hit real decoy - boss takes damage&#10;                BossEventSystem.Trigger(BossEventType.RealDecoyHit);&#10;                bossController.TakeDamage(1);&#10;            }&#10;            else&#10;            {&#10;                // Player hit fake decoy - player takes damage&#10;                BossEventSystem.Trigger(BossEventType.FakeDecoyHit);&#10;                BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                &#10;                // Transition to Soul State&#10;                bossController.ChangeState(new SoulState());&#10;            }&#10;            &#10;            // Remove this decoy&#10;            bossController.RemoveDecoy(gameObject);&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Soul (dục hồn) - đuổi nhanh theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class SoulBehavior : MonoBehaviour&#10;    {&#10;        private Transform target;&#10;        private SoulConfig config;&#10;        private float currentSpeed;&#10;        &#10;        public void Initialize(Transform playerTarget, SoulConfig soulConfig)&#10;        {&#10;            target = playerTarget;&#10;            config = soulConfig;&#10;            currentSpeed = config.soulMoveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                FollowTarget();&#10;            }&#10;        }&#10;&#10;        private void FollowTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            &#10;            // Keep minimum distance from player&#10;            float distance = Vector3.Distance(transform.position, target.position);&#10;            if (distance &gt; config.soulFollowDistance)&#10;            {&#10;                transform.position += direction * currentSpeed * Time.deltaTime;&#10;            }&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;            &#10;            // Add floating/hovering effect&#10;            AddFloatingEffect();&#10;        }&#10;&#10;        private void AddFloatingEffect()&#10;        {&#10;            float hover = Mathf.Sin(Time.time * 2f) * 0.5f;&#10;            Vector3 pos = transform.position;&#10;            pos.y += hover * Time.deltaTime;&#10;            transform.position = pos;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Soul destroyed - could trigger particle effects here&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;            &#10;            CreateVisualEffect();&#10;        }&#10;&#10;        private void CreateVisualEffect()&#10;        {&#10;            // Create dark circle on ground&#10;            var cylinder = GameObject.CreatePrimitive(PrimitiveType.Cylinder);&#10;            cylinder.transform.parent = transform;&#10;            cylinder.transform.localPosition = Vector3.zero;&#10;            cylinder.transform.localScale = new Vector3(radius * 2, 0.1f, radius * 2);&#10;            &#10;            // Make it dark and transparent&#10;            var renderer = cylinder.GetComponent&lt;Renderer&gt;();&#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = new Color(0, 0, 0, 0.7f);&#10;                material.SetFloat(&quot;_Mode&quot;, 3); // Transparent mode&#10;                renderer.material = material;&#10;            }&#10;            &#10;            // Remove collider&#10;            var collider = cylinder.GetComponent&lt;Collider&gt;();&#10;            if (collider != null)&#10;                Destroy(collider);&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Memory Fragment - mảnh ghép kí ức&#10;    /// &lt;/summary&gt;&#10;    public class MemoryFragmentBehavior : MonoBehaviour&#10;    {&#10;        private bool collected = false;&#10;        &#10;        private void Start()&#10;        {&#10;            // Add visual effects for memory fragment&#10;            AddGlowEffect();&#10;        }&#10;&#10;        private void AddGlowEffect()&#10;        {&#10;            // Add rotating and glowing effect&#10;            var renderer = GetComponent&lt;Renderer&gt;();&#10;            if (renderer == null)&#10;            {&#10;                // Create a simple cube as memory fragment&#10;                var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);&#10;                cube.transform.parent = transform;&#10;                cube.transform.localPosition = Vector3.zero;&#10;                renderer = cube.GetComponent&lt;Renderer&gt;();&#10;            }&#10;            &#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = Color.cyan;&#10;                material.EnableKeyword(&quot;_EMISSION&quot;);&#10;                material.SetColor(&quot;_EmissionColor&quot;, Color.cyan * 0.5f);&#10;                renderer.material = material;&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!collected)&#10;            {&#10;                // Rotate the fragment&#10;                transform.Rotate(0, 90 * Time.deltaTime, 0);&#10;                &#10;                // Add floating effect&#10;                float hover = Mathf.Sin(Time.time * 2f) * 0.2f;&#10;                Vector3 pos = transform.position;&#10;                pos.y += hover * Time.deltaTime;&#10;                transform.position = pos;&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !collected)&#10;            {&#10;                CollectFragment();&#10;            }&#10;        }&#10;&#10;        private void CollectFragment()&#10;        {&#10;            collected = true;&#10;            &#10;            // Trigger collection event&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;MemoryFragmentCollected&quot;, gameObject = gameObject });&#10;            &#10;            // Play collection effect and sound&#10;            // Add particle effects here&#10;            &#10;            // Destroy after collection&#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Decoy (bóng ảo) - di chuyển chậm theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyBehavior : MonoBehaviour&#10;    {&#10;        private BossController bossController;&#10;        private bool isReal;&#10;        private float moveSpeed;&#10;        private Transform target;&#10;        &#10;        public bool IsReal =&gt; isReal;&#10;&#10;        public void Initialize(BossController controller, bool real, float speed)&#10;        {&#10;            bossController = controller;&#10;            isReal = real;&#10;            moveSpeed = speed;&#10;            target = controller.Player;&#10;            &#10;            // Visual differences between real and fake decoy could be added here&#10;            if (!isReal)&#10;            {&#10;                // Make fake decoy slightly different (transparency, color, etc.)&#10;                var renderer = GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = renderer.material;&#10;                    var color = material.color;&#10;                    color.a = 0.8f; // Slightly transparent&#10;                    material.color = color;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                MoveTowardsTarget();&#10;            }&#10;        }&#10;&#10;        private void MoveTowardsTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            transform.position += direction * moveSpeed * Time.deltaTime;&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;))&#10;            {&#10;                HandlePlayerContact();&#10;            }&#10;        }&#10;&#10;        private void HandlePlayerContact()&#10;        {&#10;            if (isReal)&#10;            {&#10;                // Player hit real decoy - boss takes damage&#10;                BossEventSystem.Trigger(BossEventType.RealDecoyHit);&#10;                bossController.TakeDamage(1);&#10;            }&#10;            else&#10;            {&#10;                // Player hit fake decoy - player takes damage&#10;                BossEventSystem.Trigger(BossEventType.FakeDecoyHit);&#10;                BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                &#10;                // Transition to Soul State&#10;                bossController.ChangeState(new SoulState());&#10;            }&#10;            &#10;            // Remove this decoy&#10;            bossController.RemoveDecoy(gameObject);&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Soul (dục hồn) - đuổi nhanh theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class SoulBehavior : MonoBehaviour&#10;    {&#10;        private Transform target;&#10;        private SoulConfig config;&#10;        private float currentSpeed;&#10;        &#10;        public void Initialize(Transform playerTarget, SoulConfig soulConfig)&#10;        {&#10;            target = playerTarget;&#10;            config = soulConfig;&#10;            currentSpeed = config.soulMoveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                FollowTarget();&#10;            }&#10;        }&#10;&#10;        private void FollowTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            &#10;            // Keep minimum distance from player&#10;            float distance = Vector3.Distance(transform.position, target.position);&#10;            if (distance &gt; config.soulFollowDistance)&#10;            {&#10;                transform.position += direction * currentSpeed * Time.deltaTime;&#10;            }&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;            &#10;            // Add floating/hovering effect&#10;            AddFloatingEffect();&#10;        }&#10;&#10;        private void AddFloatingEffect()&#10;        {&#10;            float hover = Mathf.Sin(Time.time * 2f) * 0.5f;&#10;            Vector3 pos = transform.position;&#10;            pos.y += hover * Time.deltaTime;&#10;            transform.position = pos;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Soul destroyed - could trigger particle effects here&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;            &#10;            CreateVisualEffect();&#10;        }&#10;&#10;        private void CreateVisualEffect()&#10;        {&#10;            // Create dark circle on ground&#10;            var cylinder = GameObject.CreatePrimitive(PrimitiveType.Cylinder);&#10;            cylinder.transform.parent = transform;&#10;            cylinder.transform.localPosition = Vector3.zero;&#10;            cylinder.transform.localScale = new Vector3(radius * 2, 0.1f, radius * 2);&#10;            &#10;            // Make it dark and transparent&#10;            var renderer = cylinder.GetComponent&lt;Renderer&gt;();&#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = new Color(0, 0, 0, 0.7f);&#10;                material.SetFloat(&quot;_Mode&quot;, 3); // Transparent mode&#10;                renderer.material = material;&#10;            }&#10;            &#10;            // Remove collider&#10;            var collider = cylinder.GetComponent&lt;Collider&gt;();&#10;            if (collider != null)&#10;                Destroy(collider);&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Memory Fragment - mảnh ghép kí ức&#10;    /// &lt;/summary&gt;&#10;    public class MemoryFragmentBehavior : MonoBehaviour&#10;    {&#10;        private bool collected = false;&#10;        &#10;        private void Start()&#10;        {&#10;            // Add visual effects for memory fragment&#10;            AddGlowEffect();&#10;        }&#10;&#10;        private void AddGlowEffect()&#10;        {&#10;            // Add rotating and glowing effect&#10;            var renderer = GetComponent&lt;Renderer&gt;();&#10;            if (renderer == null)&#10;            {&#10;                // Create a simple cube as memory fragment&#10;                var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);&#10;                cube.transform.parent = transform;&#10;                cube.transform.localPosition = Vector3.zero;&#10;                renderer = cube.GetComponent&lt;Renderer&gt;();&#10;            }&#10;            &#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = Color.cyan;&#10;                material.EnableKeyword(&quot;_EMISSION&quot;);&#10;                material.SetColor(&quot;_EmissionColor&quot;, Color.cyan * 0.5f);&#10;                renderer.material = material;&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!collected)&#10;            {&#10;                // Rotate the fragment&#10;                transform.Rotate(0, 90 * Time.deltaTime, 0);&#10;                &#10;                // Add floating effect&#10;                float hover = Mathf.Sin(Time.time * 2f) * 0.2f;&#10;                Vector3 pos = transform.position;&#10;                pos.y += hover * Time.deltaTime;&#10;                transform.position = pos;&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !collected)&#10;            {&#10;                CollectFragment();&#10;            }&#10;        }&#10;&#10;        private void CollectFragment()&#10;        {&#10;            collected = true;&#10;            &#10;            // Trigger collection event&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;MemoryFragmentCollected&quot;, gameObject = gameObject });&#10;            &#10;            // Play collection effect and sound&#10;            // Add particle effects here&#10;            &#10;            // Destroy after collection&#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossConfig.cs" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Cấu hình toàn bộ boss - File config duy nhất để điều chỉnh toàn bộ boss&#10;    /// &lt;/summary&gt;&#10;    [CreateAssetMenu(fileName = &quot;BossConfig&quot;, menuName = &quot;Boss/Boss Configuration&quot;)]&#10;    public class BossConfig : ScriptableObject&#10;    {&#10;        [Header(&quot;General Boss Settings&quot;)]&#10;        public int maxHealthPerPhase = 3;&#10;        public float moveSpeed = 5f;&#10;        public float rotationSpeed = 90f;&#10;        &#10;        [Header(&quot;Phase 1 Settings&quot;)]&#10;        [Space]&#10;        public Phase1Config phase1;&#10;        &#10;        [Header(&quot;Phase 2 Settings&quot;)]&#10;        [Space]&#10;        public Phase2Config phase2;&#10;        &#10;        [Header(&quot;Soul Settings&quot;)]&#10;        [Space]&#10;        public SoulConfig soulConfig;&#10;        &#10;        [Header(&quot;UI Settings&quot;)]&#10;        [Space]&#10;        public UIConfig uiConfig;&#10;        &#10;        [Header(&quot;Audio Settings&quot;)]&#10;        [Space]&#10;        public AudioConfig audioConfig;&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase1Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float idleDuration = 2f;&#10;        public float lureDuration = 3f;&#10;        public float mockDuration = 2f;&#10;        public float decoyCastTime = 2f;&#10;        public float decoyDuration = 10f;&#10;        public float soulStateCastTime = 1.5f;&#10;        &#10;        [Header(&quot;Lure State&quot;)]&#10;        public float lureDistance = 5f;&#10;        public float lureApproachSpeed = 3f;&#10;        public float lureRetreatSpeed = 4f;&#10;        &#10;        [Header(&quot;Decoy State&quot;)]&#10;        public float decoyMoveSpeed = 2f;&#10;        public int decoyCount = 2; // 1 thật, 1 giả&#10;        public float decoySpawnRadius = 8f;&#10;        &#10;        [Header(&quot;State Randomization&quot;)]&#10;        public bool enableRandomStates = true;&#10;        public float[] stateWeights = { 1f, 1f, 1f, 1f }; // Idle, Lure, Mock, Decoy&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase2Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float angryMoveDuration = 5f;&#10;        public float fearZoneCastTime = 2f;&#10;        public float fearZoneDuration = 8f;&#10;        public float fearZoneActivationTime = 3f;&#10;        public float screamCastTime = 3f;&#10;        public float screamDuration = 5f;&#10;        public float cookStateDuration = 3f;&#10;        &#10;        [Header(&quot;Angry State&quot;)]&#10;        public float angryMoveSpeed = 3f;&#10;        public float circleRadius = 10f;&#10;        &#10;        [Header(&quot;Fear Zone&quot;)]&#10;        public float fearZoneRadius = 3f;&#10;        public float visionBlurIntensity = 0.7f;&#10;        &#10;        [Header(&quot;Scream State&quot;)]&#10;        public float screenShakeIntensity = 1f;&#10;        public float visionShrinkAmount = 0.5f;&#10;    }&#10;&#10;    [Serializable]&#10;    public class SoulConfig&#10;    {&#10;        public int maxSouls = 2;&#10;        public float soulMoveSpeed = 4f;&#10;        public float soulSpawnRadius = 15f;&#10;        public float soulFollowDistance = 1f;&#10;        public GameObject soulPrefab;&#10;    }&#10;&#10;    [Serializable]&#10;    public class UIConfig&#10;    {&#10;        [Header(&quot;Health Bar&quot;)]&#10;        public Vector2 bossHealthPosition = new Vector2(0f, 0.8f); // Screen space&#10;        public Vector2 playerHealthPosition = new Vector2(0f, -0.8f);&#10;        public Vector2 healthBarSize = new Vector2(300f, 30f);&#10;        &#10;        [Header(&quot;Skill Cast Bar&quot;)]&#10;        public Vector2 skillCastBarOffset = new Vector2(0f, -50f); // Offset from boss health&#10;        public Vector2 skillCastBarSize = new Vector2(200f, 20f);&#10;        &#10;        [Header(&quot;Colors&quot;)]&#10;        public Color bossHealthColor = Color.red;&#10;        public Color playerHealthColor = Color.green;&#10;        public Color skillCastColor = Color.yellow;&#10;    }&#10;&#10;    [Serializable]&#10;    public class AudioConfig&#10;    {&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#10;        public AudioClip mockLaughSound;&#10;        public AudioClip decoySpawnSound;&#10;        public AudioClip soulSpawnSound;&#10;        &#10;        [Header(&quot;Phase 2 Audio&quot;)]&#10;        public AudioClip screamSound;&#10;        public AudioClip fearZoneSound;&#10;        public AudioClip heartbeatSound;&#10;        &#10;        [Header(&quot;General Audio&quot;)]&#10;        public AudioClip phaseChangeSound;&#10;        public AudioClip damageSound;&#10;        public AudioClip defeatSound;&#10;        &#10;        [Header(&quot;Volume Settings&quot;)]&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#10;        [Range(0f, 1f)] public float sfxVolume = 0.8f;&#10;        [Range(0f, 1f)] public float ambientVolume = 0.6f;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossController.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.AI;&#10;using Code.Boss.States.Phase1;&#10;using Code.Boss.States.Phase2;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Controller chính của Boss - quản lý FSM, health, phases&#10;    /// &lt;/summary&gt;&#10;    public class BossController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)]&#10;        [SerializeField] private BossConfig bossConfig;&#10;        &#10;        [Header(&quot;Components&quot;)]&#10;        [SerializeField] private NavMeshAgent navMeshAgent;&#10;        [SerializeField] private Animator animator;&#10;        [SerializeField] private AudioSource audioSource;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private Transform player;&#10;        [SerializeField] private Transform navMeshCenter;&#10;        &#10;        // Core Systems&#10;        private BossStateMachine stateMachine;&#10;        private BossHealthSystem healthSystem;&#10;        private BossSoulManager soulManager;&#10;        private BossUIManager uiManager;&#10;        &#10;        // Current Phase&#10;        private int currentPhase = 1;&#10;        private List&lt;GameObject&gt; currentDecoys = new List&lt;GameObject&gt;();&#10;        &#10;        // Public Properties&#10;        public BossConfig Config =&gt; bossConfig;&#10;        public NavMeshAgent NavAgent =&gt; navMeshAgent;&#10;        public Animator BossAnimator =&gt; animator;&#10;        public AudioSource AudioSource =&gt; audioSource;&#10;        public Transform Player =&gt; player;&#10;        public Transform NavMeshCenter =&gt; navMeshCenter;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public BossHealthSystem HealthSystem =&gt; healthSystem;&#10;        public BossSoulManager SoulManager =&gt; soulManager;&#10;        public List&lt;GameObject&gt; CurrentDecoys =&gt; currentDecoys;&#10;        &#10;        // Events&#10;        public System.Action&lt;int&gt; OnPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;&#10;        private void Awake()&#10;        {&#10;            InitializeComponents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeSystems();&#10;            StartBoss();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            stateMachine?.Update();&#10;        }&#10;&#10;        private void InitializeComponents()&#10;        {&#10;            // Auto-find components if not assigned&#10;            if (navMeshAgent == null)&#10;                navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();&#10;            &#10;            if (animator == null)&#10;                animator = GetComponent&lt;Animator&gt;();&#10;            &#10;            if (audioSource == null)&#10;                audioSource = GetComponent&lt;AudioSource&gt;();&#10;            &#10;            if (player == null)&#10;                player = GameObject.FindGameObjectWithTag(&quot;Player&quot;)?.transform;&#10;        }&#10;&#10;        private void InitializeSystems()&#10;        {&#10;            // Initialize FSM&#10;            stateMachine = new BossStateMachine();&#10;            stateMachine.Initialize(this);&#10;            &#10;            // Initialize Health System&#10;            healthSystem = new BossHealthSystem(bossConfig.maxHealthPerPhase);&#10;            healthSystem.OnHealthChanged += OnHealthChanged;&#10;            healthSystem.OnPhaseHealthDepleted += OnPhaseCompleted;&#10;            &#10;            // Initialize Soul Manager&#10;            soulManager = new BossSoulManager(this);&#10;            &#10;            // Initialize UI Manager&#10;            uiManager = new BossUIManager(this);&#10;            &#10;            // Setup NavMesh&#10;            if (navMeshAgent != null)&#10;            {&#10;                navMeshAgent.speed = bossConfig.moveSpeed;&#10;                navMeshAgent.angularSpeed = bossConfig.rotationSpeed;&#10;            }&#10;        }&#10;&#10;        private void StartBoss()&#10;        {&#10;            // Trigger boss spawned event&#10;            BossEventSystem.Trigger(BossEventType.BossSpawned);&#10;            &#10;            // Start with Phase 1&#10;            ChangeToPhase(1);&#10;        }&#10;&#10;        private void OnHealthChanged(int newHealth, int maxHealth)&#10;        {&#10;            BossEventSystem.Trigger(BossEventType.HealthChanged, &#10;                new BossEventData { intValue = newHealth, floatValue = maxHealth });&#10;        }&#10;&#10;        private void OnPhaseCompleted()&#10;        {&#10;            if (currentPhase == 1)&#10;            {&#10;                ChangeToPhase(2);&#10;            }&#10;            else if (currentPhase == 2)&#10;            {&#10;                DefeatBoss();&#10;            }&#10;        }&#10;&#10;        public void ChangeToPhase(int newPhase)&#10;        {&#10;            currentPhase = newPhase;&#10;            healthSystem.ResetPhaseHealth();&#10;            &#10;            // Clear any existing decoys&#10;            ClearDecoys();&#10;            &#10;            // Trigger phase change event&#10;            BossEventSystem.Trigger(BossEventType.PhaseChanged, new BossEventData(newPhase));&#10;            OnPhaseChanged?.Invoke(newPhase);&#10;            &#10;            // Change to appropriate starting state&#10;            if (newPhase == 1)&#10;            {&#10;                stateMachine.ChangeState(new IdleState());&#10;            }&#10;            else if (newPhase == 2)&#10;            {&#10;                stateMachine.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public void TakeDamage(int damage = 1)&#10;        {&#10;            healthSystem.TakeDamage(damage);&#10;            stateMachine.OnTakeDamage();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossTakeDamage, new BossEventData(damage));&#10;            &#10;            // Play damage sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.damageSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.damageSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            newState.Initialize(this, bossConfig);&#10;            stateMachine.ChangeState(newState);&#10;        }&#10;&#10;        public void AddDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Add(decoy);&#10;        }&#10;&#10;        public void RemoveDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Remove(decoy);&#10;        }&#10;&#10;        public void ClearDecoys()&#10;        {&#10;            foreach (var decoy in currentDecoys)&#10;            {&#10;                if (decoy != null)&#10;                    Destroy(decoy);&#10;            }&#10;            currentDecoys.Clear();&#10;        }&#10;&#10;        public void InterruptCurrentSkill()&#10;        {&#10;            if (stateMachine.CanInterruptCurrentState())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                &#10;                // Return to appropriate state based on phase&#10;                if (currentPhase == 1)&#10;                {&#10;                    ChangeState(new IdleState());&#10;                }&#10;                else&#10;                {&#10;                    ChangeState(new AngryState());&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DefeatBoss()&#10;        {&#10;            // Trigger defeat events&#10;            BossEventSystem.Trigger(BossEventType.BossDefeated);&#10;            OnBossDefeated?.Invoke();&#10;            &#10;            // Change to cook state for phase 2&#10;            ChangeState(new CookState());&#10;            &#10;            // Play defeat sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.defeatSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.defeatSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void PlayAnimation(string animationName)&#10;        {&#10;            if (animator != null)&#10;            {&#10;                animator.SetTrigger(animationName);&#10;            }&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f)&#10;        {&#10;            if (audioSource &amp;&amp; clip)&#10;            {&#10;                audioSource.PlayOneShot(clip, volume * bossConfig.audioConfig.masterVolume);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup&#10;            if (healthSystem != null)&#10;            {&#10;                healthSystem.OnHealthChanged -= OnHealthChanged;&#10;                healthSystem.OnPhaseHealthDepleted -= OnPhaseCompleted;&#10;            }&#10;            &#10;            ClearDecoys();&#10;            BossEventSystem.ClearAllListeners();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            if (bossConfig != null)&#10;            {&#10;                // Draw decoy spawn radius&#10;                Gizmos.color = Color.yellow;&#10;                DrawWireCircle(transform.position, bossConfig.phase1.decoySpawnRadius);&#10;                &#10;                // Draw soul spawn radius&#10;                Gizmos.color = Color.magenta;&#10;                DrawWireCircle(transform.position, bossConfig.soulConfig.soulSpawnRadius);&#10;                &#10;                // Draw phase 2 circle radius&#10;                if (navMeshCenter != null)&#10;                {&#10;                    Gizmos.color = Color.red;&#10;                    DrawWireCircle(navMeshCenter.position, bossConfig.phase2.circleRadius);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Helper method to draw wire circle in XZ plane&#10;        /// &lt;/summary&gt;&#10;        private void DrawWireCircle(Vector3 center, float radius)&#10;        {&#10;            int segments = 32;&#10;            float angleStep = 360f / segments;&#10;            Vector3 prevPoint = center + new Vector3(radius, 0, 0);&#10;            &#10;            for (int i = 1; i &lt;= segments; i++)&#10;            {&#10;                float angle = angleStep * i * Mathf.Deg2Rad;&#10;                Vector3 newPoint = center + new Vector3(&#10;                    Mathf.Cos(angle) * radius, &#10;                    0, &#10;                    Mathf.Sin(angle) * radius&#10;                );&#10;                &#10;                Gizmos.DrawLine(prevPoint, newPoint);&#10;                prevPoint = newPoint;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.AI;&#10;using Code.Boss.States.Phase1;&#10;using Code.Boss.States.Phase2;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Controller chính của Boss - quản lý FSM, health, phases&#10;    /// &lt;/summary&gt;&#10;    public class BossController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)]&#10;        [SerializeField] private BossConfig bossConfig;&#10;        &#10;        [Header(&quot;Components&quot;)]&#10;        [SerializeField] private NavMeshAgent navMeshAgent;&#10;        [SerializeField] private Animator animator;&#10;        [SerializeField] private AudioSource audioSource;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private Transform player;&#10;        [SerializeField] private Transform navMeshCenter;&#10;        &#10;        // Core Systems&#10;        private BossStateMachine stateMachine;&#10;        private BossHealthSystem healthSystem;&#10;        private BossSoulManager soulManager;&#10;        private BossUIManager uiManager;&#10;        &#10;        // Current Phase&#10;        private int currentPhase = 1;&#10;        private List&lt;GameObject&gt; currentDecoys = new List&lt;GameObject&gt;();&#10;        &#10;        // Public Properties&#10;        public BossConfig Config =&gt; bossConfig;&#10;        public NavMeshAgent NavAgent =&gt; navMeshAgent;&#10;        public Animator BossAnimator =&gt; animator;&#10;        public AudioSource AudioSource =&gt; audioSource;&#10;        public Transform Player =&gt; player;&#10;        public Transform NavMeshCenter =&gt; navMeshCenter;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public BossHealthSystem HealthSystem =&gt; healthSystem;&#10;        public BossSoulManager SoulManager =&gt; soulManager;&#10;        public List&lt;GameObject&gt; CurrentDecoys =&gt; currentDecoys;&#10;        &#10;        // Events&#10;        public System.Action&lt;int&gt; OnPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;&#10;        private void Awake()&#10;        {&#10;            InitializeComponents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeSystems();&#10;            StartBoss();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            stateMachine?.Update();&#10;        }&#10;&#10;        private void InitializeComponents()&#10;        {&#10;            // Auto-find components if not assigned&#10;            if (navMeshAgent == null)&#10;                navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();&#10;            &#10;            if (animator == null)&#10;                animator = GetComponent&lt;Animator&gt;();&#10;            &#10;            if (audioSource == null)&#10;                audioSource = GetComponent&lt;AudioSource&gt;();&#10;            &#10;            if (player == null)&#10;                player = GameObject.FindGameObjectWithTag(&quot;Player&quot;)?.transform;&#10;        }&#10;&#10;        private void InitializeSystems()&#10;        {&#10;            // Initialize FSM&#10;            stateMachine = new BossStateMachine();&#10;            stateMachine.Initialize(this);&#10;            &#10;            // Initialize Health System&#10;            healthSystem = new BossHealthSystem(bossConfig.maxHealthPerPhase);&#10;            healthSystem.OnHealthChanged += OnHealthChanged;&#10;            healthSystem.OnPhaseHealthDepleted += OnPhaseCompleted;&#10;            &#10;            // Initialize Soul Manager&#10;            soulManager = new BossSoulManager(this);&#10;            &#10;            // Initialize UI Manager&#10;            uiManager = new BossUIManager(this);&#10;            &#10;            // Setup NavMesh&#10;            if (navMeshAgent != null)&#10;            {&#10;                navMeshAgent.speed = bossConfig.moveSpeed;&#10;                navMeshAgent.angularSpeed = bossConfig.rotationSpeed;&#10;            }&#10;        }&#10;&#10;        private void StartBoss()&#10;        {&#10;            // Trigger boss spawned event&#10;            BossEventSystem.Trigger(BossEventType.BossSpawned);&#10;            &#10;            // Start with Phase 1&#10;            ChangeToPhase(1);&#10;        }&#10;&#10;        private void OnHealthChanged(int newHealth, int maxHealth)&#10;        {&#10;            BossEventSystem.Trigger(BossEventType.HealthChanged, &#10;                new BossEventData { intValue = newHealth, floatValue = maxHealth });&#10;        }&#10;&#10;        private void OnPhaseCompleted()&#10;        {&#10;            if (currentPhase == 1)&#10;            {&#10;                ChangeToPhase(2);&#10;            }&#10;            else if (currentPhase == 2)&#10;            {&#10;                DefeatBoss();&#10;            }&#10;        }&#10;&#10;        public void ChangeToPhase(int newPhase)&#10;        {&#10;            currentPhase = newPhase;&#10;            healthSystem.ResetPhaseHealth();&#10;            &#10;            // Clear any existing decoys&#10;            ClearDecoys();&#10;            &#10;            // Trigger phase change event&#10;            BossEventSystem.Trigger(BossEventType.PhaseChanged, new BossEventData(newPhase));&#10;            OnPhaseChanged?.Invoke(newPhase);&#10;            &#10;            // Change to appropriate starting state&#10;            if (newPhase == 1)&#10;            {&#10;                stateMachine.ChangeState(new IdleState());&#10;            }&#10;            else if (newPhase == 2)&#10;            {&#10;                stateMachine.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public void TakeDamage(int damage = 1)&#10;        {&#10;            healthSystem.TakeDamage(damage);&#10;            stateMachine.OnTakeDamage();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossTakeDamage, new BossEventData(damage));&#10;            &#10;            // Play damage sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.damageSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.damageSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            newState.Initialize(this, bossConfig);&#10;            stateMachine.ChangeState(newState);&#10;        }&#10;&#10;        public void AddDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Add(decoy);&#10;        }&#10;&#10;        public void RemoveDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Remove(decoy);&#10;        }&#10;&#10;        public void ClearDecoys()&#10;        {&#10;            foreach (var decoy in currentDecoys)&#10;            {&#10;                if (decoy != null)&#10;                    Destroy(decoy);&#10;            }&#10;            currentDecoys.Clear();&#10;        }&#10;&#10;        public void InterruptCurrentSkill()&#10;        {&#10;            if (stateMachine.CanInterruptCurrentState())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                &#10;                // Return to appropriate state based on phase&#10;                if (currentPhase == 1)&#10;                {&#10;                    ChangeState(new IdleState());&#10;                }&#10;                else&#10;                {&#10;                    ChangeState(new AngryState());&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DefeatBoss()&#10;        {&#10;            // Trigger defeat events&#10;            BossEventSystem.Trigger(BossEventType.BossDefeated);&#10;            OnBossDefeated?.Invoke();&#10;            &#10;            // Change to cook state for phase 2&#10;            ChangeState(new CookState());&#10;            &#10;            // Play defeat sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.defeatSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.defeatSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void PlayAnimation(string animationName)&#10;        {&#10;            // Replace animation calls with debug logs since no assets are available&#10;            Debug.Log($&quot;[Boss Animation] Playing animation: {animationName}&quot;);&#10;            &#10;            // Uncomment when animation assets are available:&#10;            // if (animator != null)&#10;            // {&#10;            //     animator.SetTrigger(animationName);&#10;            // }&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f)&#10;        {&#10;            if (audioSource &amp;&amp; clip)&#10;            {&#10;                audioSource.PlayOneShot(clip, volume * bossConfig.audioConfig.masterVolume);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup&#10;            if (healthSystem != null)&#10;            {&#10;                healthSystem.OnHealthChanged -= OnHealthChanged;&#10;                healthSystem.OnPhaseHealthDepleted -= OnPhaseCompleted;&#10;            }&#10;            &#10;            ClearDecoys();&#10;            BossEventSystem.ClearAllListeners();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            if (bossConfig != null)&#10;            {&#10;                // Draw decoy spawn radius&#10;                Gizmos.color = Color.yellow;&#10;                DrawWireCircle(transform.position, bossConfig.phase1.decoySpawnRadius);&#10;                &#10;                // Draw soul spawn radius&#10;                Gizmos.color = Color.magenta;&#10;                DrawWireCircle(transform.position, bossConfig.soulConfig.soulSpawnRadius);&#10;                &#10;                // Draw phase 2 circle radius&#10;                if (navMeshCenter != null)&#10;                {&#10;                    Gizmos.color = Color.red;&#10;                    DrawWireCircle(navMeshCenter.position, bossConfig.phase2.circleRadius);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Helper method to draw wire circle in XZ plane&#10;        /// &lt;/summary&gt;&#10;        private void DrawWireCircle(Vector3 center, float radius)&#10;        {&#10;            int segments = 32;&#10;            float angleStep = 360f / segments;&#10;            Vector3 prevPoint = center + new Vector3(radius, 0, 0);&#10;            &#10;            for (int i = 1; i &lt;= segments; i++)&#10;            {&#10;                float angle = angleStep * i * Mathf.Deg2Rad;&#10;                Vector3 newPoint = center + new Vector3(&#10;                    Mathf.Cos(angle) * radius, &#10;                    0, &#10;                    Mathf.Sin(angle) * radius&#10;                );&#10;                &#10;                Gizmos.DrawLine(prevPoint, newPoint);&#10;                prevPoint = newPoint;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossEventSystem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossEventSystem.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hệ thống sự kiện riêng cho Boss, tách biệt với GameEventSystem&#10;    /// &lt;/summary&gt;&#10;    public static class BossEventSystem&#10;    {&#10;        private static Dictionary&lt;BossEventType, List&lt;Action&lt;BossEventData&gt;&gt;&gt; eventListeners = &#10;            new Dictionary&lt;BossEventType, List&lt;Action&lt;BossEventData&gt;&gt;&gt;();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Đăng ký lắng nghe một sự kiện boss&#10;        /// &lt;/summary&gt;&#10;        public static void Subscribe(BossEventType eventType, Action&lt;BossEventData&gt; listener)&#10;        {&#10;            if (!eventListeners.ContainsKey(eventType))&#10;            {&#10;                eventListeners[eventType] = new List&lt;Action&lt;BossEventData&gt;&gt;();&#10;            }&#10;            &#10;            eventListeners[eventType].Add(listener);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Hủy đăng ký lắng nghe sự kiện&#10;        /// &lt;/summary&gt;&#10;        public static void Unsubscribe(BossEventType eventType, Action&lt;BossEventData&gt; listener)&#10;        {&#10;            if (eventListeners.ContainsKey(eventType))&#10;            {&#10;                eventListeners[eventType].Remove(listener);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Phát sự kiện boss&#10;        /// &lt;/summary&gt;&#10;        public static void Trigger(BossEventType eventType, BossEventData data = null)&#10;        {&#10;            if (eventListeners.ContainsKey(eventType))&#10;            {&#10;                foreach (var listener in eventListeners[eventType])&#10;                {&#10;                    try&#10;                    {&#10;                        listener?.Invoke(data);&#10;                    }&#10;                    catch (Exception e)&#10;                    {&#10;                        Debug.LogError($&quot;Error in BossEvent listener for {eventType}: {e.Message}&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Xóa tất cả listeners&#10;        /// &lt;/summary&gt;&#10;        public static void ClearAllListeners()&#10;        {&#10;            eventListeners.Clear();&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Các loại sự kiện boss&#10;    /// &lt;/summary&gt;&#10;    public enum BossEventType&#10;    {&#10;        // Phase Events&#10;        PhaseChanged,&#10;        BossSpawned,&#10;        BossDefeated,&#10;        &#10;        // State Events&#10;        StateChanged,&#10;        SkillCasted,&#10;        SkillInterrupted,&#10;        &#10;        // Combat Events&#10;        BossTakeDamage,&#10;        PlayerTakeDamage,&#10;        DecoyHit,&#10;        RealDecoyHit,&#10;        FakeDecoyHit,&#10;        &#10;        // Soul Events&#10;        SoulSpawned,&#10;        SoulDestroyed,&#10;        &#10;        // Skill-specific Events&#10;        LureStarted,&#10;        MockStarted,&#10;        DecoyStarted,&#10;        SoulStateStarted,&#10;        FearZoneCreated,&#10;        ScreamStarted,&#10;        &#10;        // UI Events&#10;        HealthChanged,&#10;        SkillCastProgress,&#10;        &#10;        // Fa Integration Events&#10;        RequestRadarSkill, // Yêu cầu Fa sử dụng Radar skill&#10;        RequestOtherSkill, // Yêu cầu Fa sử dụng skill khác&#10;        FaSkillUsed        // Fa đã sử dụng skill&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Dữ liệu kèm theo sự kiện boss&#10;    /// &lt;/summary&gt;&#10;    [Serializable]&#10;    public class BossEventData&#10;    {&#10;        public int intValue;&#10;        public float floatValue;&#10;        public string stringValue;&#10;        public Vector3 position;&#10;        public GameObject gameObject;&#10;        public object customData;&#10;&#10;        public BossEventData() { }&#10;&#10;        public BossEventData(int value)&#10;        {&#10;            intValue = value;&#10;        }&#10;&#10;        public BossEventData(float value)&#10;        {&#10;            floatValue = value;&#10;        }&#10;&#10;        public BossEventData(string value)&#10;        {&#10;            stringValue = value;&#10;        }&#10;&#10;        public BossEventData(Vector3 pos)&#10;        {&#10;            position = pos;&#10;        }&#10;&#10;        public BossEventData(GameObject obj)&#10;        {&#10;            gameObject = obj;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manager tổng thể cho Boss system - điểm tích hợp chính&#10;    /// &lt;/summary&gt;&#10;    public class BossManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Boss Setup&quot;)]&#10;        [SerializeField] private BossController bossController;&#10;        [SerializeField] private BossConfig bossConfig;&#10;        &#10;        [Header(&quot;UI Setup&quot;)]&#10;        [SerializeField] private GameObject bossHealthBarPrefab;&#10;        [SerializeField] private GameObject skillCastBarPrefab;&#10;        [SerializeField] private GameObject playerHealthBarPrefab;&#10;        &#10;        [Header(&quot;Player Settings&quot;)]&#10;        [SerializeField] private int playerMaxHealth = 3;&#10;        &#10;        private BossHealthBar bossHealthBar;&#10;        private BossSkillCastBar skillCastBar;&#10;        private PlayerHealthBar playerHealthBar;&#10;        &#10;        public static BossManager Instance { get; private set; }&#10;        &#10;        // Events for external systems&#10;        public System.Action&lt;int&gt; OnBossPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;        public System.Action&lt;int&gt; OnPlayerHealthChanged;&#10;&#10;        private void Awake()&#10;        {&#10;            // Singleton pattern&#10;            if (Instance != null &amp;&amp; Instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;            Instance = this;&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeBossSystem();&#10;        }&#10;&#10;        private void InitializeBossSystem()&#10;        {&#10;            // Setup boss controller if not assigned&#10;            if (bossController == null)&#10;            {&#10;                bossController = FindObjectOfType&lt;BossController&gt;();&#10;            }&#10;            &#10;            if (bossController == null)&#10;            {&#10;                Debug.LogError(&quot;BossController not found! Please assign it in the inspector.&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Initialize UI components&#10;            InitializeUI();&#10;            &#10;            // Register for boss events&#10;            RegisterBossEvents();&#10;            &#10;            // Register for Fa integration events&#10;            RegisterFaIntegrationEvents();&#10;            &#10;            Debug.Log(&quot;Boss System initialized successfully!&quot;);&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Create Boss Health Bar&#10;            if (bossHealthBarPrefab != null)&#10;            {&#10;                GameObject healthBarGO = Instantiate(bossHealthBarPrefab);&#10;                bossHealthBar = healthBarGO.GetComponent&lt;BossHealthBar&gt;();&#10;                if (bossHealthBar == null)&#10;                    bossHealthBar = healthBarGO.AddComponent&lt;BossHealthBar&gt;();&#10;                &#10;                bossHealthBar.Initialize(bossController);&#10;            }&#10;            &#10;            // Create Skill Cast Bar&#10;            if (skillCastBarPrefab != null)&#10;            {&#10;                GameObject castBarGO = Instantiate(skillCastBarPrefab);&#10;                skillCastBar = castBarGO.GetComponent&lt;BossSkillCastBar&gt;();&#10;                if (skillCastBar == null)&#10;                    skillCastBar = castBarGO.AddComponent&lt;BossSkillCastBar&gt;();&#10;                &#10;                skillCastBar.Initialize(bossController);&#10;            }&#10;            &#10;            // Create Player Health Bar&#10;            if (playerHealthBarPrefab != null)&#10;            {&#10;                GameObject playerBarGO = Instantiate(playerHealthBarPrefab);&#10;                playerHealthBar = playerBarGO.GetComponent&lt;PlayerHealthBar&gt;();&#10;                if (playerHealthBar == null)&#10;                    playerHealthBar = playerBarGO.AddComponent&lt;PlayerHealthBar&gt;();&#10;                &#10;                playerHealthBar.Initialize(playerMaxHealth);&#10;            }&#10;        }&#10;&#10;        private void RegisterBossEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Subscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Subscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Subscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;        }&#10;&#10;        private void RegisterFaIntegrationEvents()&#10;        {&#10;            // Listen for Fa skill requests&#10;            BossEventSystem.Subscribe(BossEventType.RequestRadarSkill, OnRequestRadarSkill);&#10;            BossEventSystem.Subscribe(BossEventType.RequestOtherSkill, OnRequestOtherSkill);&#10;        }&#10;&#10;        private void OnPhaseChanged(BossEventData data)&#10;        {&#10;            int newPhase = data.intValue;&#10;            OnBossPhaseChanged?.Invoke(newPhase);&#10;            &#10;            Debug.Log($&quot;Boss entered Phase {newPhase}&quot;);&#10;        }&#10;&#10;        private void OnBossDefeatedEvent(BossEventData data)&#10;        {&#10;            OnBossDefeated?.Invoke();&#10;            Debug.Log(&quot;Boss has been defeated!&quot;);&#10;        }&#10;&#10;        private void OnPlayerTakeDamageEvent(BossEventData data)&#10;        {&#10;            int damage = data.intValue;&#10;            OnPlayerHealthChanged?.Invoke(damage);&#10;        }&#10;&#10;        private void OnBossSpawned(BossEventData data)&#10;        {&#10;            Debug.Log(&quot;Boss has spawned and is ready for battle!&quot;);&#10;        }&#10;&#10;        private void OnRequestRadarSkill(BossEventData data)&#10;        {&#10;            // Request Fa to use Radar skill to destroy souls&#10;            Debug.Log(&quot;Requesting Fa to use Radar skill to destroy souls&quot;);&#10;            &#10;            // This will be handled by Fa's system&#10;            // For now, we can simulate the request&#10;            RequestFaSkill(&quot;Radar&quot;);&#10;        }&#10;&#10;        private void OnRequestOtherSkill(BossEventData data)&#10;        {&#10;            string skillName = data.stringValue ?? &quot;Unknown&quot;;&#10;            Debug.Log($&quot;Requesting Fa to use skill: {skillName}&quot;);&#10;            &#10;            RequestFaSkill(skillName);&#10;        }&#10;&#10;        private void RequestFaSkill(string skillName)&#10;        {&#10;            // This method will be called by Fa's system when skill is used&#10;            // For now, we can simulate skill usage for testing&#10;            &#10;            // In actual implementation, this would communicate with Fa's skill system&#10;            // Example: FaSkillManager.Instance.RequestSkill(skillName, OnFaSkillComplete);&#10;        }&#10;&#10;        // This method should be called by Fa's system when a skill is completed&#10;        public void OnFaSkillCompleted(string skillName, bool success)&#10;        {&#10;            if (success)&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.FaSkillUsed, &#10;                    new BossEventData { stringValue = skillName });&#10;                &#10;                Debug.Log($&quot;Fa successfully used skill: {skillName}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;Fa failed to use skill: {skillName}&quot;);&#10;            }&#10;        }&#10;&#10;        // Public methods for external interaction&#10;        public void PlayerAttackBoss()&#10;        {&#10;            if (bossController != null)&#10;            {&#10;                bossController.TakeDamage(1);&#10;            }&#10;        }&#10;&#10;        public void PlayerAttackDecoy(GameObject decoy, bool hitReal)&#10;        {&#10;            var decoyBehavior = decoy.GetComponent&lt;DecoyBehavior&gt;();&#10;            if (decoyBehavior != null)&#10;            {&#10;                if (hitReal)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.RealDecoyHit);&#10;                    bossController.TakeDamage(1);&#10;                }&#10;                else&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.FakeDecoyHit);&#10;                    BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                }&#10;            }&#10;        }&#10;&#10;        public void InterruptBossSkill()&#10;        {&#10;            if (bossController != null)&#10;            {&#10;                bossController.InterruptCurrentSkill();&#10;            }&#10;        }&#10;&#10;        // Heal player (for testing or power-ups)&#10;        public void HealPlayer(int amount)&#10;        {&#10;            if (playerHealthBar != null)&#10;            {&#10;                playerHealthBar.HealPlayer(amount);&#10;            }&#10;        }&#10;&#10;        // Get current boss state for external systems&#10;        public string GetCurrentBossState()&#10;        {&#10;            if (bossController != null &amp;&amp; bossController.GetComponent&lt;BossStateMachine&gt;() != null)&#10;            {&#10;                return bossController.GetComponent&lt;BossStateMachine&gt;().CurrentState?.GetType().Name ?? &quot;Unknown&quot;;&#10;            }&#10;            return &quot;No Boss&quot;;&#10;        }&#10;&#10;        // Get current boss phase&#10;        public int GetCurrentBossPhase()&#10;        {&#10;            return bossController != null ? bossController.CurrentPhase : 0;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup events&#10;            BossEventSystem.Unsubscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestRadarSkill, OnRequestRadarSkill);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestOtherSkill, OnRequestOtherSkill);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossStateMachine.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossStateMachine.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Base class cho tất cả các state của boss&#10;    /// &lt;/summary&gt;&#10;    public abstract class BossState&#10;    {&#10;        protected BossController bossController;&#10;        protected BossConfig config;&#10;        &#10;        public abstract void Enter();&#10;        public abstract void Update();&#10;        public abstract void Exit();&#10;        public abstract void OnTakeDamage();&#10;        public abstract bool CanBeInterrupted();&#10;&#10;        public virtual void Initialize(BossController controller, BossConfig bossConfig)&#10;        {&#10;            bossController = controller;&#10;            config = bossConfig;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Finite State Machine cho Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossStateMachine&#10;    {&#10;        private BossState currentState;&#10;        private BossController bossController;&#10;        &#10;        public BossState CurrentState =&gt; currentState;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            bossController = controller;&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            currentState?.Exit();&#10;            &#10;            BossState previousState = currentState;&#10;            currentState = newState;&#10;            currentState?.Enter();&#10;            &#10;            // Trigger state change event&#10;            BossEventSystem.Trigger(BossEventType.StateChanged, &#10;                new BossEventData { stringValue = newState?.GetType().Name });&#10;        }&#10;&#10;        public void Update()&#10;        {&#10;            currentState?.Update();&#10;        }&#10;&#10;        public void OnTakeDamage()&#10;        {&#10;            currentState?.OnTakeDamage();&#10;        }&#10;&#10;        public bool CanInterruptCurrentState()&#10;        {&#10;            return currentState?.CanBeInterrupted() ?? false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss.States.Phase1;&#10;using Code.Boss.States.Phase2;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Base class cho tất cả các state của boss&#10;    /// &lt;/summary&gt;&#10;    public abstract class BossState&#10;    {&#10;        protected BossController bossController;&#10;        protected BossConfig config;&#10;        &#10;        public abstract void Enter();&#10;        public abstract void Update();&#10;        public abstract void Exit();&#10;        public abstract void OnTakeDamage();&#10;        public abstract bool CanBeInterrupted();&#10;&#10;        public virtual void Initialize(BossController controller, BossConfig bossConfig)&#10;        {&#10;            bossController = controller;&#10;            config = bossConfig;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Finite State Machine cho Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossStateMachine&#10;    {&#10;        private BossState currentState;&#10;        private BossController bossController;&#10;        &#10;        public BossState CurrentState =&gt; currentState;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            bossController = controller;&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            currentState?.Exit();&#10;            &#10;            BossState previousState = currentState;&#10;            currentState = newState;&#10;            currentState?.Enter();&#10;            &#10;            // Trigger state change event&#10;            BossEventSystem.Trigger(BossEventType.StateChanged, &#10;                new BossEventData { stringValue = newState?.GetType().Name });&#10;        }&#10;&#10;        public void Update()&#10;        {&#10;            currentState?.Update();&#10;        }&#10;&#10;        public void OnTakeDamage()&#10;        {&#10;            currentState?.OnTakeDamage();&#10;        }&#10;&#10;        public bool CanInterruptCurrentState()&#10;        {&#10;            return currentState?.CanBeInterrupted() ?? false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossSubSystems.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossSubSystems.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý hệ thống máu của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthSystem&#10;    {&#10;        private int maxHealthPerPhase;&#10;        private int currentHealth;&#10;        private int currentPhase = 1;&#10;        &#10;        public int CurrentHealth =&gt; currentHealth;&#10;        public int MaxHealthPerPhase =&gt; maxHealthPerPhase;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public float HealthPercentage =&gt; (float)currentHealth / maxHealthPerPhase;&#10;        &#10;        public event Action&lt;int, int&gt; OnHealthChanged; // current, max&#10;        public event Action OnPhaseHealthDepleted;&#10;&#10;        public BossHealthSystem(int maxHealthPerPhase)&#10;        {&#10;            this.maxHealthPerPhase = maxHealthPerPhase;&#10;            currentHealth = maxHealthPerPhase;&#10;        }&#10;&#10;        public void TakeDamage(int damage)&#10;        {&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPhaseHealthDepleted?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void ResetPhaseHealth()&#10;        {&#10;            currentHealth = maxHealthPerPhase;&#10;            currentPhase++;&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealthPerPhase, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý Soul entities&#10;    /// &lt;/summary&gt;&#10;    public class BossSoulManager&#10;    {&#10;        private BossController bossController;&#10;        private List&lt;GameObject&gt; activeSouls = new List&lt;GameObject&gt;();&#10;        &#10;        public int ActiveSoulCount =&gt; activeSouls.Count;&#10;        public int MaxSouls =&gt; bossController.Config.soulConfig.maxSouls;&#10;&#10;        public BossSoulManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            &#10;            // Listen for Fa skill usage to destroy souls&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public void SpawnSoul()&#10;        {&#10;            if (activeSouls.Count &gt;= MaxSouls) return;&#10;            &#10;            var soulConfig = bossController.Config.soulConfig;&#10;            if (soulConfig.soulPrefab == null) return;&#10;            &#10;            // Find spawn position around boss&#10;            Vector3 spawnPos = GetRandomSpawnPosition();&#10;            GameObject soul = GameObject.Instantiate(soulConfig.soulPrefab, spawnPos, Quaternion.identity);&#10;            &#10;            // Setup soul behavior&#10;            var soulBehavior = soul.GetComponent&lt;SoulBehavior&gt;();&#10;            if (soulBehavior == null)&#10;                soulBehavior = soul.AddComponent&lt;SoulBehavior&gt;();&#10;            &#10;            soulBehavior.Initialize(bossController.Player, soulConfig);&#10;            &#10;            activeSouls.Add(soul);&#10;            BossEventSystem.Trigger(BossEventType.SoulSpawned, new BossEventData(soul));&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition()&#10;        {&#10;            var config = bossController.Config.soulConfig;&#10;            Vector3 randomDirection = UnityEngine.Random.insideUnitCircle.normalized;&#10;            Vector3 spawnPos = bossController.transform.position + &#10;                              new Vector3(randomDirection.x, 0, randomDirection.y) * config.soulSpawnRadius;&#10;            return spawnPos;&#10;        }&#10;&#10;        public void DestroyAllSouls()&#10;        {&#10;            foreach (var soul in activeSouls)&#10;            {&#10;                if (soul != null)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.SoulDestroyed, new BossEventData(soul));&#10;                    GameObject.Destroy(soul);&#10;                }&#10;            }&#10;            activeSouls.Clear();&#10;        }&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            // Assuming Fa's radar skill destroys all souls&#10;            if (data.stringValue == &quot;Radar&quot;)&#10;            {&#10;                DestroyAllSouls();&#10;            }&#10;        }&#10;&#10;        public void CleanupDestroyed()&#10;        {&#10;            activeSouls.RemoveAll(soul =&gt; soul == null);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý UI của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossUIManager&#10;    {&#10;        private BossController bossController;&#10;        private BossHealthBar bossHealthBar;&#10;        private SkillCastBar skillCastBar;&#10;        &#10;        public BossUIManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            InitializeUI();&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Tạo UI elements sẽ được implement trong các class riêng&#10;            CreateBossHealthBar();&#10;            CreateSkillCastBar();&#10;        }&#10;&#10;        private void CreateBossHealthBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;&#10;        private void CreateSkillCastBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý hệ thống máu của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthSystem&#10;    {&#10;        private int maxHealthPerPhase;&#10;        private int currentHealth;&#10;        private int currentPhase = 1;&#10;        &#10;        public int CurrentHealth =&gt; currentHealth;&#10;        public int MaxHealthPerPhase =&gt; maxHealthPerPhase;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public float HealthPercentage =&gt; (float)currentHealth / maxHealthPerPhase;&#10;        &#10;        public event Action&lt;int, int&gt; OnHealthChanged; // current, max&#10;        public event Action OnPhaseHealthDepleted;&#10;&#10;        public BossHealthSystem(int maxHealthPerPhase)&#10;        {&#10;            this.maxHealthPerPhase = maxHealthPerPhase;&#10;            currentHealth = maxHealthPerPhase;&#10;        }&#10;&#10;        public void TakeDamage(int damage)&#10;        {&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPhaseHealthDepleted?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void ResetPhaseHealth()&#10;        {&#10;            currentHealth = maxHealthPerPhase;&#10;            currentPhase++;&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealthPerPhase, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý Soul entities&#10;    /// &lt;/summary&gt;&#10;    public class BossSoulManager&#10;    {&#10;        private BossController bossController;&#10;        private List&lt;GameObject&gt; activeSouls = new List&lt;GameObject&gt;();&#10;        &#10;        public int ActiveSoulCount =&gt; activeSouls.Count;&#10;        public int MaxSouls =&gt; bossController.Config.soulConfig.maxSouls;&#10;&#10;        public BossSoulManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            &#10;            // Listen for Fa skill usage to destroy souls&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public void SpawnSoul()&#10;        {&#10;            if (activeSouls.Count &gt;= MaxSouls) return;&#10;            &#10;            var soulConfig = bossController.Config.soulConfig;&#10;            if (soulConfig.soulPrefab == null) return;&#10;            &#10;            // Find spawn position around boss&#10;            Vector3 spawnPos = GetRandomSpawnPosition();&#10;            GameObject soul = GameObject.Instantiate(soulConfig.soulPrefab, spawnPos, Quaternion.identity);&#10;            &#10;            // Setup soul behavior&#10;            var soulBehavior = soul.GetComponent&lt;SoulBehavior&gt;();&#10;            if (soulBehavior == null)&#10;                soulBehavior = soul.AddComponent&lt;SoulBehavior&gt;();&#10;            &#10;            soulBehavior.Initialize(bossController.Player, soulConfig);&#10;            &#10;            activeSouls.Add(soul);&#10;            BossEventSystem.Trigger(BossEventType.SoulSpawned, new BossEventData(soul));&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition()&#10;        {&#10;            var config = bossController.Config.soulConfig;&#10;            Vector3 randomDirection = UnityEngine.Random.insideUnitCircle.normalized;&#10;            Vector3 spawnPos = bossController.transform.position + &#10;                              new Vector3(randomDirection.x, 0, randomDirection.y) * config.soulSpawnRadius;&#10;            return spawnPos;&#10;        }&#10;&#10;        public void DestroyAllSouls()&#10;        {&#10;            foreach (var soul in activeSouls)&#10;            {&#10;                if (soul != null)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.SoulDestroyed, new BossEventData(soul));&#10;                    GameObject.Destroy(soul);&#10;                }&#10;            }&#10;            activeSouls.Clear();&#10;        }&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            // Assuming Fa's radar skill destroys all souls&#10;            if (data.stringValue == &quot;Radar&quot;)&#10;            {&#10;                DestroyAllSouls();&#10;            }&#10;        }&#10;&#10;        public void CleanupDestroyed()&#10;        {&#10;            activeSouls.RemoveAll(soul =&gt; soul == null);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý UI của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossUIManager&#10;    {&#10;        private BossController bossController;&#10;        private BossHealthBar bossHealthBar;&#10;        private BossSkillCastBar skillCastBar;&#10;        &#10;        public BossUIManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            InitializeUI();&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Tạo UI elements sẽ được implement trong các class riêng&#10;            CreateBossHealthBar();&#10;            CreateSkillCastBar();&#10;        }&#10;&#10;        private void CreateBossHealthBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;&#10;        private void CreateSkillCastBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossUIComponents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossUIComponents.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Thanh máu của Boss ở giữa trên màn hình&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthBar : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Components&quot;)]&#10;        [SerializeField] private Canvas canvas;&#10;        [SerializeField] private Slider healthSlider;&#10;        [SerializeField] private TextMeshProUGUI healthText;&#10;        [SerializeField] private TextMeshProUGUI phaseText;&#10;        &#10;        private BossController bossController;&#10;        private UIConfig uiConfig;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            uiConfig = controller.Config.uiConfig;&#10;            &#10;            SetupUI();&#10;            RegisterEvents();&#10;        }&#10;&#10;        private void SetupUI()&#10;        {&#10;            // Create canvas if not assigned&#10;            if (canvas == null)&#10;            {&#10;                CreateCanvas();&#10;            }&#10;            &#10;            // Position at top center of screen&#10;            RectTransform rectTransform = GetComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(0.5f, 1f);&#10;            rectTransform.anchorMax = new Vector2(0.5f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(0, -50); // 50 pixels from top&#10;            rectTransform.sizeDelta = uiConfig.healthBarSize;&#10;            &#10;            // Setup health slider&#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.maxValue = bossController.Config.maxHealthPerPhase;&#10;                healthSlider.value = bossController.Config.maxHealthPerPhase;&#10;                &#10;                // Set colors&#10;                var fillImage = healthSlider.fillRect.GetComponent&lt;Image&gt;();&#10;                if (fillImage != null)&#10;                {&#10;                    fillImage.color = uiConfig.bossHealthColor;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void CreateCanvas()&#10;        {&#10;            GameObject canvasGO = new GameObject(&quot;BossHealthCanvas&quot;);&#10;            canvas = canvasGO.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 100;&#10;            &#10;            canvasGO.AddComponent&lt;CanvasScaler&gt;();&#10;            canvasGO.AddComponent&lt;GraphicRaycaster&gt;();&#10;        }&#10;&#10;        private void RegisterEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.HealthChanged, OnHealthChanged);&#10;            BossEventSystem.Subscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;        }&#10;&#10;        private void OnHealthChanged(BossEventData data)&#10;        {&#10;            int currentHealth = data.intValue;&#10;            int maxHealth = (int)data.floatValue;&#10;            &#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.maxValue = maxHealth;&#10;                healthSlider.value = currentHealth;&#10;            }&#10;            &#10;            if (healthText != null)&#10;            {&#10;                healthText.text = $&quot;{currentHealth}/{maxHealth}&quot;;&#10;            }&#10;        }&#10;&#10;        private void OnPhaseChanged(BossEventData data)&#10;        {&#10;            int newPhase = data.intValue;&#10;            &#10;            if (phaseText != null)&#10;            {&#10;                phaseText.text = $&quot;Phase {newPhase}&quot;;&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.HealthChanged, OnHealthChanged);&#10;            BossEventSystem.Unsubscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Thanh cast skill ở dưới thanh máu boss&#10;    /// &lt;/summary&gt;&#10;    public class BossSkillCastBar : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Components&quot;)]&#10;        [SerializeField] private Slider castSlider;&#10;        [SerializeField] private TextMeshProUGUI skillNameText;&#10;        [SerializeField] private GameObject castBarContainer;&#10;        &#10;        private UIConfig uiConfig;&#10;        private bool isVisible = false;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            uiConfig = controller.Config.uiConfig;&#10;            &#10;            SetupUI();&#10;            RegisterEvents();&#10;            &#10;            // Hide initially&#10;            SetVisible(false);&#10;        }&#10;&#10;        private void SetupUI()&#10;        {&#10;            // Position below boss health bar&#10;            RectTransform rectTransform = GetComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(0.5f, 1f);&#10;            rectTransform.anchorMax = new Vector2(0.5f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(0, -100); // Below health bar&#10;            rectTransform.sizeDelta = uiConfig.skillCastBarSize;&#10;            &#10;            // Setup cast slider&#10;            if (castSlider != null)&#10;            {&#10;                castSlider.maxValue = 1f;&#10;                castSlider.value = 0f;&#10;                &#10;                // Set colors&#10;                var fillImage = castSlider.fillRect.GetComponent&lt;Image&gt;();&#10;                if (fillImage != null)&#10;                {&#10;                    fillImage.color = uiConfig.skillCastColor;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void RegisterEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.SkillCasted, OnSkillCasted);&#10;            BossEventSystem.Subscribe(BossEventType.SkillCastProgress, OnSkillCastProgress);&#10;            BossEventSystem.Subscribe(BossEventType.SkillInterrupted, OnSkillInterrupted);&#10;            BossEventSystem.Subscribe(BossEventType.StateChanged, OnStateChanged);&#10;        }&#10;&#10;        private void OnSkillCasted(BossEventData data)&#10;        {&#10;            SetVisible(true);&#10;            &#10;            if (skillNameText != null &amp;&amp; data != null)&#10;            {&#10;                skillNameText.text = data.stringValue ?? &quot;Casting Skill...&quot;;&#10;            }&#10;            &#10;            if (castSlider != null)&#10;            {&#10;                castSlider.value = 0f;&#10;            }&#10;        }&#10;&#10;        private void OnSkillCastProgress(BossEventData data)&#10;        {&#10;            if (castSlider != null &amp;&amp; isVisible)&#10;            {&#10;                castSlider.value = data.floatValue;&#10;            }&#10;        }&#10;&#10;        private void OnSkillInterrupted(BossEventData data)&#10;        {&#10;            SetVisible(false);&#10;        }&#10;&#10;        private void OnStateChanged(BossEventData data)&#10;        {&#10;            // Hide cast bar when state changes (skill completed)&#10;            if (isVisible)&#10;            {&#10;                SetVisible(false);&#10;            }&#10;        }&#10;&#10;        private void SetVisible(bool visible)&#10;        {&#10;            isVisible = visible;&#10;            if (castBarContainer != null)&#10;            {&#10;                castBarContainer.SetActive(visible);&#10;            }&#10;            else&#10;            {&#10;                gameObject.SetActive(visible);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.SkillCasted, OnSkillCasted);&#10;            BossEventSystem.Unsubscribe(BossEventType.SkillCastProgress, OnSkillCastProgress);&#10;            BossEventSystem.Unsubscribe(BossEventType.SkillInterrupted, OnSkillInterrupted);&#10;            BossEventSystem.Unsubscribe(BossEventType.StateChanged, OnStateChanged);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Thanh máu người chơi ở giữa dưới màn hình&#10;    /// &lt;/summary&gt;&#10;    public class PlayerHealthBar : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Components&quot;)]&#10;        [SerializeField] private Slider healthSlider;&#10;        [SerializeField] private TextMeshProUGUI healthText;&#10;        &#10;        private int maxHealth = 3; // Default player health&#10;        private int currentHealth = 3;&#10;&#10;        public void Initialize(int playerMaxHealth)&#10;        {&#10;            maxHealth = playerMaxHealth;&#10;            currentHealth = playerMaxHealth;&#10;            &#10;            SetupUI();&#10;            RegisterEvents();&#10;        }&#10;&#10;        private void SetupUI()&#10;        {&#10;            // Position at bottom center of screen&#10;            RectTransform rectTransform = GetComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(0.5f, 0f);&#10;            rectTransform.anchorMax = new Vector2(0.5f, 0f);&#10;            rectTransform.anchoredPosition = new Vector2(0, 50); // 50 pixels from bottom&#10;            &#10;            // Setup health slider&#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.maxValue = maxHealth;&#10;                healthSlider.value = currentHealth;&#10;                &#10;                // Set green color for player health&#10;                var fillImage = healthSlider.fillRect.GetComponent&lt;Image&gt;();&#10;                if (fillImage != null)&#10;                {&#10;                    fillImage.color = Color.green;&#10;                }&#10;            }&#10;            &#10;            UpdateHealthText();&#10;        }&#10;&#10;        private void RegisterEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamage);&#10;        }&#10;&#10;        private void OnPlayerTakeDamage(BossEventData data)&#10;        {&#10;            int damage = data.intValue;&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            &#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.value = currentHealth;&#10;            }&#10;            &#10;            UpdateHealthText();&#10;            &#10;            // Check if player is defeated&#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPlayerDefeated();&#10;            }&#10;        }&#10;&#10;        private void UpdateHealthText()&#10;        {&#10;            if (healthText != null)&#10;            {&#10;                healthText.text = $&quot;{currentHealth}/{maxHealth}&quot;;&#10;            }&#10;        }&#10;&#10;        private void OnPlayerDefeated()&#10;        {&#10;            // Handle player defeat&#10;            Debug.Log(&quot;Player Defeated!&quot;);&#10;            // This could trigger game over screen, respawn, etc.&#10;        }&#10;&#10;        public void HealPlayer(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealth, currentHealth + amount);&#10;            &#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.value = currentHealth;&#10;            }&#10;            &#10;            UpdateHealthText();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamage);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossConfig.cs" />
              <option name="originalContent" value="using System;&#10;using FMODUnity;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Cấu hình toàn bộ boss - File config duy nhất để điều chỉnh toàn bộ boss&#10;    /// &lt;/summary&gt;&#10;    [CreateAssetMenu(fileName = &quot;BossConfig&quot;, menuName = &quot;Boss/Boss Configuration&quot;)]&#10;    public class BossConfig : ScriptableObject&#10;    {&#10;        [Header(&quot;Debug&quot;)]&#10;        [Tooltip(&quot;Chọn phase để test nhanh. None: Bình thường, Phase1: Phase 1, Phase2: Phase 2, ...&quot;)]&#10;        public BossDebugPhase debugStartPhase = BossDebugPhase.None;&#10;        &#10;        [Header(&quot;General Boss Settings&quot;)]&#10;        public int maxHealthPerPhase = 3;&#10;        public float moveSpeed = 5f;&#10;        public float rotationSpeed = 90f;&#10;        &#10;        [Header(&quot;Phase 1 Settings&quot;)]&#10;        [Space]&#10;        public Phase1Config phase1;&#10;        &#10;        [Header(&quot;Phase 2 Settings&quot;)]&#10;        [Space]&#10;        public Phase2Config phase2;&#10;        &#10;        [Header(&quot;Soul Settings&quot;)]&#10;        [Space]&#10;        public SoulConfig soulConfig;&#10;        &#10;        [Header(&quot;UI Settings&quot;)]&#10;        [Space]&#10;        public UIConfig uiConfig;&#10;        &#10;        [Header(&quot;Audio Settings&quot;)]&#10;        [Space]&#10;        public AudioConfig audioConfig;&#10;        &#10;        [Header(&quot;FMOD Studio Settings&quot;)]&#10;        [Space]&#10;        public FMODAudioConfig fmodAudioConfig;&#10;        &#10;&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase1Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float idleDuration = 2f;&#10;        public float lureDuration = 3f;&#10;        public float mockDuration = 2f;&#10;        public float decoyCastTime = 2f;&#10;        public float decoyDuration = 10f;&#10;        public float soulStateCastTime = 1.5f;&#10;        &#10;        [Header(&quot;Lure State&quot;)]&#10;        public float lureDistance = 5f;&#10;        public float lureApproachSpeed = 3f;&#10;        public float lureRetreatSpeed = 4f;&#10;        &#10;        [Header(&quot;Decoy State&quot;)]&#10;        public float decoyMoveSpeed = 2f;&#10;        public int decoyCount = 2; // 1 thật, 1 giả&#10;        public float decoySpawnRadius = 8f;&#10;        public GameObject decoyPrefab; // Prefab cho decoy&#10;        public GameObject decoySpawnEffectPrefab; // Prefab hiệu ứng khi spawn decoy&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase2Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float angryMoveDuration = 5f;&#10;        public float fearZoneCastTime = 2f;&#10;        public float fearZoneDuration = 8f;&#10;        public float screamCastTime = 3f;&#10;        public float screamDuration = 5f;&#10;        public float cookStateDuration = 3f;&#10;        &#10;        [Header(&quot;Angry State&quot;)]&#10;        public float angryMoveSpeed = 3f;&#10;        public float circleRadius = 10f;&#10;        &#10;        [Header(&quot;Fear Zone&quot;)]&#10;        public float fearZoneRadius = 3f;&#10;        public GameObject fearZoneCastEffectPrefab; // Prefab hiệu ứng khi cast skill&#10;        public GameObject fearZoneZoneEffectPrefab; // Prefab hiệu ứng khi zone xuất hiện&#10;        &#10;        [Header(&quot;Scream State&quot;)]&#10;        public float screenShakeIntensity = 1f;&#10;        public float visionShrinkAmount = 0.5f;&#10;    }&#10;&#10;    [Serializable]&#10;    public class SoulConfig&#10;    {&#10;        public int maxSouls = 2;&#10;        public float soulMoveSpeed = 4f;&#10;        public float soulSpawnRadius = 15f;&#10;        public float soulFollowDistance = 1f;&#10;        public GameObject soulPrefab;&#10;        public GameObject soulSpawnEffectPrefab; // Prefab hiệu ứng khi spawn soul&#10;    }&#10;&#10;    [Serializable]&#10;    public class UIConfig&#10;    {&#10;        [Header(&quot;Colors&quot;)]&#10;        public Color bossHealthColor = Color.red;&#10;        public Color playerHealthColor = Color.green;&#10;        public Color skillCastColor = Color.yellow;&#10;        &#10;        [Header(&quot;Animation Settings&quot;)]&#10;        public float uiAnimationSpeed = 1f;                                                                     // Tốc độ animation chung cho UI&#10;        public AnimationCurve uiAnimationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);          // Curve cho smooth animation&#10;    }&#10;&#10;    [Serializable]&#10;    public class AudioConfig&#10;    {&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#10;        public AudioClip mockLaughSound;&#10;        public AudioClip decoySpawnSound;&#10;        public AudioClip soulSpawnSound;&#10;        &#10;        [Header(&quot;Phase 2 Audio&quot;)]&#10;        public AudioClip screamSound;&#10;        public AudioClip fearZoneSound;&#10;        public AudioClip heartbeatSound;&#10;        &#10;        [Header(&quot;General Audio&quot;)]&#10;        public AudioClip phaseChangeSound;&#10;        public AudioClip damageSound;&#10;        public AudioClip defeatSound;&#10;        &#10;        [Header(&quot;Volume Settings&quot;)]&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#10;        [Range(0f, 1f)] public float sfxVolume = 0.8f;&#10;        [Range(0f, 1f)] public float ambientVolume = 0.6f;&#10;    }&#10;    &#10;    [Serializable]&#10;    public class FMODAudioConfig&#10;    {&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#10;        public EventReference mockLaughEvent;&#10;        public EventReference decoySpawnEvent;&#10;        public EventReference soulSpawnEvent;&#10;        [Header(&quot;Phase 2 Audio&quot;)]&#10;        public EventReference screamEvent;&#10;        public EventReference fearZoneEvent;&#10;        public EventReference heartbeatEvent;&#10;        [Header(&quot;General Audio&quot;)]&#10;        public EventReference phaseChangeEvent;&#10;        public EventReference damageEvent;&#10;        public EventReference defeatEvent;&#10;    }&#10;&#10;    public enum BossDebugPhase&#10;    {&#10;        None = -1,&#10;        Phase1 = 0,&#10;        Phase2 = 1&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using FMODUnity;&#13;&#10;using UnityEngine;&#13;&#10;&#13;&#10;namespace Code.Boss&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Cấu hình toàn bộ boss - File config duy nhất để điều chỉnh toàn bộ boss&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    [CreateAssetMenu(fileName = &quot;BossConfig&quot;, menuName = &quot;Boss/Boss Configuration&quot;)]&#13;&#10;    public class BossConfig : ScriptableObject&#13;&#10;    {&#13;&#10;        [Header(&quot;Debug&quot;)]&#13;&#10;        [Tooltip(&quot;Chọn phase để test nhanh. None: Bình thường, Phase1: Phase 1, Phase2: Phase 2, ...&quot;)]&#13;&#10;        public BossDebugPhase debugStartPhase = BossDebugPhase.None;&#13;&#10;        &#13;&#10;        [Header(&quot;General Boss Settings&quot;)]&#13;&#10;        public int maxHealthPerPhase = 3;&#13;&#10;        public float moveSpeed = 5f;&#13;&#10;        public float rotationSpeed = 90f;&#13;&#10;        &#13;&#10;        [Header(&quot;Phase 1 Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public Phase1Config phase1;&#13;&#10;        &#13;&#10;        [Header(&quot;Phase 2 Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public Phase2Config phase2;&#13;&#10;        &#13;&#10;        [Header(&quot;Soul Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public SoulConfig soulConfig;&#13;&#10;        &#13;&#10;        [Header(&quot;UI Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public UIConfig uiConfig;&#13;&#10;        &#13;&#10;        [Header(&quot;Audio Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public AudioConfig audioConfig;&#13;&#10;        &#13;&#10;        [Header(&quot;FMOD Studio Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public FMODAudioConfig fmodAudioConfig;&#13;&#10;        &#13;&#10;&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class Phase1Config&#13;&#10;    {&#13;&#10;        [Header(&quot;State Durations&quot;)]&#13;&#10;        public float idleDuration = 2f;&#13;&#10;        public float lureDuration = 3f;&#13;&#10;        public float mockDuration = 2f;&#13;&#10;        public float decoyCastTime = 2f;&#13;&#10;        public float decoyDuration = 10f;&#13;&#10;        public float soulStateCastTime = 1.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;Lure State&quot;)]&#13;&#10;        public float lureDistance = 5f;&#13;&#10;        public float lureApproachSpeed = 3f;&#13;&#10;        public float lureRetreatSpeed = 4f;&#13;&#10;        &#13;&#10;        [Header(&quot;Decoy State&quot;)]&#13;&#10;        public float decoyMoveSpeed = 2f;&#13;&#10;        public int decoyCount = 2; // 1 thật, 1 giả&#13;&#10;        public float decoySpawnRadius = 8f;&#13;&#10;        public GameObject decoyPrefab; // Prefab cho decoy&#13;&#10;        public GameObject decoySpawnEffectPrefab; // Prefab hiệu ứng khi spawn decoy&#13;&#10;        public GameObject realDecoyRevealEffectPrefab; // Prefab hiệu ứng khi reveal decoy thật&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class Phase2Config&#13;&#10;    {&#13;&#10;        [Header(&quot;State Durations&quot;)]&#13;&#10;        public float angryMoveDuration = 5f;&#13;&#10;        public float fearZoneCastTime = 2f;&#13;&#10;        public float fearZoneDuration = 8f;&#13;&#10;        public float screamCastTime = 3f;&#13;&#10;        public float screamDuration = 5f;&#13;&#10;        public float cookStateDuration = 3f;&#13;&#10;        &#13;&#10;        [Header(&quot;Angry State&quot;)]&#13;&#10;        public float angryMoveSpeed = 3f;&#13;&#10;        public float circleRadius = 10f;&#13;&#10;        &#13;&#10;        [Header(&quot;Fear Zone&quot;)]&#13;&#10;        public float fearZoneRadius = 3f;&#13;&#10;        public GameObject fearZoneCastEffectPrefab; // Prefab hiệu ứng khi cast skill&#13;&#10;        public GameObject fearZoneZoneEffectPrefab; // Prefab hiệu ứng khi zone xuất hiện&#13;&#10;        &#13;&#10;        [Header(&quot;Scream State&quot;)]&#13;&#10;        public float screenShakeIntensity = 1f;&#13;&#10;        public float visionShrinkAmount = 0.5f;&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class SoulConfig&#13;&#10;    {&#13;&#10;        public int maxSouls = 2;&#13;&#10;        public float soulMoveSpeed = 4f;&#13;&#10;        public float soulSpawnRadius = 15f;&#13;&#10;        public float soulFollowDistance = 1f;&#13;&#10;        public GameObject soulPrefab;&#13;&#10;        public GameObject soulSpawnEffectPrefab; // Prefab hiệu ứng khi spawn soul&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class UIConfig&#13;&#10;    {&#13;&#10;        [Header(&quot;Colors&quot;)]&#13;&#10;        public Color bossHealthColor = Color.red;&#13;&#10;        public Color playerHealthColor = Color.green;&#13;&#10;        public Color skillCastColor = Color.yellow;&#13;&#10;        &#13;&#10;        [Header(&quot;Animation Settings&quot;)]&#13;&#10;        public float uiAnimationSpeed = 1f;                                                                     // Tốc độ animation chung cho UI&#13;&#10;        public AnimationCurve uiAnimationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);          // Curve cho smooth animation&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class AudioConfig&#13;&#10;    {&#13;&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#13;&#10;        public AudioClip mockLaughSound;&#13;&#10;        public AudioClip decoySpawnSound;&#13;&#10;        public AudioClip soulSpawnSound;&#13;&#10;        &#13;&#10;        [Header(&quot;Phase 2 Audio&quot;)]&#13;&#10;        public AudioClip screamSound;&#13;&#10;        public AudioClip fearZoneSound;&#13;&#10;        public AudioClip heartbeatSound;&#13;&#10;        &#13;&#10;        [Header(&quot;General Audio&quot;)]&#13;&#10;        public AudioClip phaseChangeSound;&#13;&#10;        public AudioClip damageSound;&#13;&#10;        public AudioClip defeatSound;&#13;&#10;        &#13;&#10;        [Header(&quot;Volume Settings&quot;)]&#13;&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#13;&#10;        [Range(0f, 1f)] public float sfxVolume = 0.8f;&#13;&#10;        [Range(0f, 1f)] public float ambientVolume = 0.6f;&#13;&#10;    }&#13;&#10;    &#13;&#10;    [Serializable]&#13;&#10;    public class FMODAudioConfig&#13;&#10;    {&#13;&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#13;&#10;        public EventReference mockLaughEvent;&#13;&#10;        public EventReference decoySpawnEvent;&#13;&#10;        public EventReference soulSpawnEvent;&#13;&#10;        [Header(&quot;Phase 2 Audio&quot;)]&#13;&#10;        public EventReference screamEvent;&#13;&#10;        public EventReference fearZoneEvent;&#13;&#10;        public EventReference heartbeatEvent;&#13;&#10;        [Header(&quot;General Audio&quot;)]&#13;&#10;        public EventReference phaseChangeEvent;&#13;&#10;        public EventReference damageEvent;&#13;&#10;        public EventReference defeatEvent;&#13;&#10;    }&#13;&#10;&#13;&#10;    public enum BossDebugPhase&#13;&#10;    {&#13;&#10;        None = -1,&#13;&#10;        Phase1 = 0,&#13;&#10;        Phase2 = 1&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossSubSystems.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossSubSystems.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý hệ thống máu của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthSystem&#10;    {&#10;        private int maxHealthPerPhase;&#10;        private int currentHealth;&#10;        private int currentPhase = 1;&#10;        &#10;        public int CurrentHealth =&gt; currentHealth;&#10;        public int MaxHealthPerPhase =&gt; maxHealthPerPhase;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public float HealthPercentage =&gt; (float)currentHealth / maxHealthPerPhase;&#10;        &#10;        public event Action&lt;int, int&gt; OnHealthChanged; // current, max&#10;        public event Action OnPhaseHealthDepleted;&#10;&#10;        public BossHealthSystem(int maxHealthPerPhase)&#10;        {&#10;            this.maxHealthPerPhase = maxHealthPerPhase;&#10;            currentHealth = maxHealthPerPhase;&#10;        }&#10;&#10;        public void TakeDamage(int damage)&#10;        {&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPhaseHealthDepleted?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void ResetPhaseHealth()&#10;        {&#10;            currentHealth = maxHealthPerPhase;&#10;            currentPhase++;&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealthPerPhase, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý Soul entities&#10;    /// &lt;/summary&gt;&#10;    public class BossSoulManager&#10;    {&#10;        private BossController bossController;&#10;        private List&lt;GameObject&gt; activeSouls = new List&lt;GameObject&gt;();&#10;        &#10;        public int ActiveSoulCount =&gt; activeSouls.Count;&#10;        public int MaxSouls =&gt; bossController.Config.soulConfig.maxSouls;&#10;&#10;        public BossSoulManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            &#10;            // Listen for Fa skill usage to destroy souls&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public void SpawnSoul()&#10;        {&#10;            if (activeSouls.Count &gt;= MaxSouls) return;&#10;            &#10;            var soulConfig = bossController.Config.soulConfig;&#10;            if (soulConfig.soulPrefab == null) return;&#10;            &#10;            // Find spawn position around boss&#10;            Vector3 spawnPos = GetRandomSpawnPosition();&#10;            GameObject soul = GameObject.Instantiate(soulConfig.soulPrefab, spawnPos, Quaternion.identity);&#10;            &#10;            // Setup soul behavior&#10;            var soulBehavior = soul.GetComponent&lt;SoulBehavior&gt;();&#10;            if (soulBehavior == null)&#10;                soulBehavior = soul.AddComponent&lt;SoulBehavior&gt;();&#10;            &#10;            soulBehavior.Initialize(bossController.Player, soulConfig);&#10;            &#10;            activeSouls.Add(soul);&#10;            BossEventSystem.Trigger(BossEventType.SoulSpawned, new BossEventData(soul));&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition()&#10;        {&#10;            var config = bossController.Config.soulConfig;&#10;            Vector3 randomDirection = UnityEngine.Random.insideUnitCircle.normalized;&#10;            Vector3 spawnPos = bossController.transform.position + &#10;                              new Vector3(randomDirection.x, 0, randomDirection.y) * config.soulSpawnRadius;&#10;            return spawnPos;&#10;        }&#10;&#10;        public void DestroyAllSouls()&#10;        {&#10;            foreach (var soul in activeSouls)&#10;            {&#10;                if (soul != null)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.SoulDestroyed, new BossEventData(soul));&#10;                    GameObject.Destroy(soul);&#10;                }&#10;            }&#10;            activeSouls.Clear();&#10;        }&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            // Assuming Fa's radar skill destroys all souls&#10;            if (data.stringValue == &quot;Radar&quot;)&#10;            {&#10;                DestroyAllSouls();&#10;            }&#10;        }&#10;&#10;        public void CleanupDestroyed()&#10;        {&#10;            activeSouls.RemoveAll(soul =&gt; soul == null);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý UI của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossUIManager&#10;    {&#10;        private BossController bossController;&#10;        private BossHealthBar bossHealthBar;&#10;        private BossSkillCastBar skillCastBar;&#10;        private PlayerHealthBar playerHealthBar;&#10;        &#10;        public BossUIManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            InitializeUI();&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Tìm và khởi tạo UI components đã được gán trong scene&#10;            FindAndInitializeUIComponents();&#10;        }&#10;&#10;        private void FindAndInitializeUIComponents()&#10;        {&#10;            // Tìm BossHealthBar trong scene&#10;            bossHealthBar = UnityEngine.Object.FindObjectOfType&lt;BossHealthBar&gt;();&#10;            if (bossHealthBar != null)&#10;            {&#10;                bossHealthBar.Initialize(bossController);&#10;                Debug.Log(&quot;Boss Health Bar found and initialized&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;BossHealthBar not found in scene! Please add BossHealthBar component to a UI GameObject.&quot;);&#10;            }&#10;&#10;            // Tìm BossSkillCastBar trong scene&#10;            skillCastBar = UnityEngine.Object.FindObjectOfType&lt;BossSkillCastBar&gt;();&#10;            if (skillCastBar != null)&#10;            {&#10;                skillCastBar.Initialize(bossController);&#10;                Debug.Log(&quot;Boss Skill Cast Bar found and initialized&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;BossSkillCastBar not found in scene! Please add BossSkillCastBar component to a UI GameObject.&quot;);&#10;            }&#10;&#10;            // Tìm PlayerHealthBar trong scene&#10;            playerHealthBar = UnityEngine.Object.FindObjectOfType&lt;PlayerHealthBar&gt;();&#10;            if (playerHealthBar != null)&#10;            {&#10;                playerHealthBar.Initialize(3); // Default player health&#10;                Debug.Log(&quot;Player Health Bar found and initialized&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;PlayerHealthBar not found in scene! Please add PlayerHealthBar component to a UI GameObject.&quot;);&#10;            }&#10;        }&#10;&#10;        // Methods để show/hide UI&#10;        public void ShowBossHealthBar(bool show)&#10;        {&#10;            if (bossHealthBar != null)&#10;                bossHealthBar.gameObject.SetActive(show);&#10;        }&#10;&#10;        public void ShowSkillCastBar(bool show)&#10;        {&#10;            if (skillCastBar != null)&#10;                skillCastBar.gameObject.SetActive(show);&#10;        }&#10;&#10;        public void ShowPlayerHealthBar(bool show)&#10;        {&#10;            if (playerHealthBar != null)&#10;                playerHealthBar.gameObject.SetActive(show);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    // File này giờ chỉ chứa các using statements và namespace&#10;    // Các systems đã được tách ra thành files riêng:&#10;    // - BossHealthSystem.cs&#10;    // - BossSoulManager.cs  &#10;    // - BossUIManager.cs&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/FaBossIntegration.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/FaBossIntegration.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Interface tích hợp với hệ thống kỹ năng của Fa&#10;    /// &lt;/summary&gt;&#10;    public class FaBossIntegration : MonoBehaviour&#10;    {&#10;        [Header(&quot;Integration Settings&quot;)]&#10;        [SerializeField] private bool enableFaIntegration = true;&#10;        &#10;        private BossManager bossManager;&#10;        &#10;        // Events để thông báo cho Fa system&#10;        public static System.Action&lt;string&gt; OnRequestFaSkill;&#10;        public static System.Action&lt;int&gt; OnSoulCountChanged;&#10;        public static System.Action&lt;bool&gt; OnBossVulnerable; // Khi boss có thể bị tấn công&#10;&#10;        private void Start()&#10;        {&#10;            bossManager = BossManager.Instance;&#10;            &#10;            if (enableFaIntegration)&#10;            {&#10;                RegisterForBossEvents();&#10;            }&#10;        }&#10;&#10;        private void RegisterForBossEvents()&#10;        {&#10;            // Lắng nghe các sự kiện boss để thông báo cho Fa&#10;            BossEventSystem.Subscribe(BossEventType.SoulSpawned, OnSoulSpawned);&#10;            BossEventSystem.Subscribe(BossEventType.SoulDestroyed, OnSoulDestroyed);&#10;            BossEventSystem.Subscribe(BossEventType.DecoyStarted, OnDecoyStarted);&#10;            BossEventSystem.Subscribe(BossEventType.ScreamStarted, OnScreamStarted);&#10;            BossEventSystem.Subscribe(BossEventType.RequestRadarSkill, OnRadarSkillRequested);&#10;        }&#10;&#10;        private void OnSoulSpawned(BossEventData data)&#10;        {&#10;            // Thông báo cho Fa rằng có soul mới được spawn&#10;            int currentSoulCount = FindObjectsOfType&lt;SoulBehavior&gt;().Length;&#10;            OnSoulCountChanged?.Invoke(currentSoulCount);&#10;            &#10;            // Nếu có &gt;= 2 souls, suggest Fa use Radar skill&#10;            if (currentSoulCount &gt;= 2)&#10;            {&#10;                SuggestRadarSkill();&#10;            }&#10;        }&#10;&#10;        private void OnSoulDestroyed(BossEventData data)&#10;        {&#10;            int currentSoulCount = FindObjectsOfType&lt;SoulBehavior&gt;().Length - 1; // -1 vì soul sắp bị destroy&#10;            OnSoulCountChanged?.Invoke(currentSoulCount);&#10;        }&#10;&#10;        private void OnDecoyStarted(BossEventData data)&#10;        {&#10;            // Boss bắt đầu cast Decoy - đây là thời điểm boss có thể bị tấn công&#10;            OnBossVulnerable?.Invoke(true);&#10;        }&#10;&#10;        private void OnScreamStarted(BossEventData data)&#10;        {&#10;            // Boss bắt đầu cast Scream - đây cũng là thời điểm boss có thể bị tấn công&#10;            OnBossVulnerable?.Invoke(true);&#10;        }&#10;&#10;        private void OnRadarSkillRequested(BossEventData data)&#10;        {&#10;            SuggestRadarSkill();&#10;        }&#10;&#10;        private void SuggestRadarSkill()&#10;        {&#10;            // Gửi signal cho Fa system để suggest sử dụng Radar skill&#10;            OnRequestFaSkill?.Invoke(&quot;Radar&quot;);&#10;            &#10;            Debug.Log(&quot;Suggesting Fa to use Radar skill to clear souls&quot;);&#10;        }&#10;&#10;        // Method để Fa system gọi khi skill được sử dụng&#10;        public static void NotifyFaSkillUsed(string skillName, bool success = true)&#10;        {&#10;            if (BossManager.Instance != null)&#10;            {&#10;                BossManager.Instance.OnFaSkillCompleted(skillName, success);&#10;            }&#10;        }&#10;&#10;        // Method để Fa system kiểm tra trạng thái boss&#10;        public static bool IsBossVulnerable()&#10;        {&#10;            if (BossManager.Instance == null) return false;&#10;            &#10;            string currentState = BossManager.Instance.GetCurrentBossState();&#10;            return currentState == &quot;DecoyState&quot; || currentState == &quot;ScreamState&quot;;&#10;        }&#10;&#10;        // Method để Fa system kiểm tra số lượng soul&#10;        public static int GetCurrentSoulCount()&#10;        {&#10;            return FindObjectsOfType&lt;SoulBehavior&gt;().Length;&#10;        }&#10;&#10;        // Method để Fa system kiểm tra phase hiện tại&#10;        public static int GetCurrentBossPhase()&#10;        {&#10;            return BossManager.Instance?.GetCurrentBossPhase() ?? 0;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.SoulSpawned, OnSoulSpawned);&#10;            BossEventSystem.Unsubscribe(BossEventType.SoulDestroyed, OnSoulDestroyed);&#10;            BossEventSystem.Unsubscribe(BossEventType.DecoyStarted, OnDecoyStarted);&#10;            BossEventSystem.Unsubscribe(BossEventType.ScreamStarted, OnScreamStarted);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestRadarSkill, OnRadarSkillRequested);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Example integration với Fa skill system&#10;    /// &lt;/summary&gt;&#10;    public static class FaSkillIntegrationExample&#10;    {&#10;        // Ví dụ cách Fa system có thể tích hợp&#10;        public static void InitializeFaIntegration()&#10;        {&#10;            // Đăng ký lắng nghe boss events&#10;            FaBossIntegration.OnRequestFaSkill += HandleFaSkillRequest;&#10;            FaBossIntegration.OnSoulCountChanged += HandleSoulCountChanged;&#10;            FaBossIntegration.OnBossVulnerable += HandleBossVulnerabilityChanged;&#10;        }&#10;&#10;        private static void HandleFaSkillRequest(string skillName)&#10;        {&#10;            Debug.Log($&quot;Boss system is requesting Fa to use skill: {skillName}&quot;);&#10;            &#10;            // Fa system logic here&#10;            // Example:&#10;            // if (FaSkillManager.CanUseSkill(skillName))&#10;            // {&#10;            //     FaSkillManager.UseSkill(skillName, OnFaSkillComplete);&#10;            // }&#10;        }&#10;&#10;        private static void HandleSoulCountChanged(int soulCount)&#10;        {&#10;            Debug.Log($&quot;Soul count changed to: {soulCount}&quot;);&#10;            &#10;            // Fa system có thể update UI hoặc AI logic dựa trên số soul&#10;        }&#10;&#10;        private static void HandleBossVulnerabilityChanged(bool isVulnerable)&#10;        {&#10;            Debug.Log($&quot;Boss vulnerability changed to: {isVulnerable}&quot;);&#10;            &#10;            // Fa system có thể update UI để hiển thị cơ hội tấn công&#10;        }&#10;&#10;        // Callback khi Fa skill hoàn thành&#10;        private static void OnFaSkillComplete(string skillName, bool success)&#10;        {&#10;            // Thông báo lại cho boss system&#10;            FaBossIntegration.NotifyFaSkillUsed(skillName, success);&#10;        }&#10;&#10;        public static void CleanupFaIntegration()&#10;        {&#10;            FaBossIntegration.OnRequestFaSkill -= HandleFaSkillRequest;&#10;            FaBossIntegration.OnSoulCountChanged -= HandleSoulCountChanged;&#10;            FaBossIntegration.OnBossVulnerable -= HandleBossVulnerabilityChanged;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Integration/BossManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Integration/BossManager.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manager tổng thể cho Boss system - điểm tích hợp chính&#10;    /// &lt;/summary&gt;&#10;    public class BossManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Boss Setup&quot;)]&#10;        [SerializeField] private BossController bossController;&#10;        &#10;        [Header(&quot;Fa Agent Reference&quot;)]&#10;        [SerializeField] private Tu_Develop.Import.Scripts.FaAgent faAgent;&#10;&#10;        public static BossManager Instance { get; private set; }&#10;        &#10;        // Events for external systems&#10;        public System.Action&lt;int&gt; OnBossPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;        public System.Action&lt;int&gt; OnPlayerHealthChanged;&#10;&#10;        private void Awake()&#10;        {&#10;            // Singleton pattern&#10;            if (Instance != null &amp;&amp; Instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;            Instance = this;&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeBossSystem();&#10;        }&#10;&#10;        private void InitializeBossSystem()&#10;        {&#10;            // Setup boss controller if not assigned&#10;            if (bossController == null) bossController = FindFirstObjectByType&lt;BossController&gt;();&#10;            if (bossController == null)&#10;            {&#10;                Debug.LogError(&quot;BossController not found! Please assign it in the inspector.&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Setup FaAgent if not assigned&#10;            if (faAgent == null) faAgent = FindFirstObjectByType&lt;Tu_Develop.Import.Scripts.FaAgent&gt;();&#10;            if (faAgent == null)&#10;            {&#10;                Debug.LogError(&quot;FaAgent not found! Please assign it in the inspector.&quot;);&#10;            }&#10;            &#10;            // Register for boss events&#10;            RegisterBossEvents();&#10;        }&#10;&#10;       &#10;        private void RegisterBossEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Subscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Subscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Subscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;        }&#10;        &#10;        private void OnPhaseChanged(BossEventData data)&#10;        {&#10;            var newPhase = data.intValue;&#10;            OnBossPhaseChanged?.Invoke(newPhase);&#10;            &#10;            Debug.Log($&quot;Boss entered Phase {newPhase}&quot;);&#10;        }&#10;&#10;        private void OnBossDefeatedEvent(BossEventData data)&#10;        {&#10;            OnBossDefeated?.Invoke();&#10;            Debug.Log(&quot;Boss has been defeated!&quot;);&#10;        }&#10;&#10;        private void OnPlayerTakeDamageEvent(BossEventData data)&#10;        {&#10;            var damage = data.intValue;&#10;            OnPlayerHealthChanged?.Invoke(damage);&#10;        }&#10;&#10;        private void OnBossSpawned(BossEventData data)&#10;        {&#10;            Debug.Log(&quot;Boss has spawned and is ready for battle!&quot;);&#10;        }&#10;&#10;        private void OnRequestRadarSkill(BossEventData data)&#10;        {&#10;            Debug.Log(&quot;Requesting Fa to use Radar skill to destroy souls&quot;);&#10;            if (faAgent != null)&#10;            {&#10;                faAgent.UseGuideSignal();&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;FaAgent reference missing, cannot use Radar skill.&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnRequestOtherSkill(BossEventData data)&#10;        {&#10;            var skillName = data.stringValue ?? &quot;Unknown&quot;;&#10;            Debug.Log($&quot;Requesting Fa to use skill: {skillName}&quot;);&#10;            if (faAgent != null)&#10;            {&#10;                switch (skillName)&#10;                {&#10;                    case &quot;GuideSignal&quot;:&#10;                        faAgent.UseGuideSignal();&#10;                        break;&#10;                    case &quot;KnowledgeLight&quot;:&#10;                        faAgent.UseKnowledgeLight();&#10;                        break;&#10;                    case &quot;ProtectiveAura&quot;:&#10;                        faAgent.UseProtectiveAura();&#10;                        break;&#10;                    default:&#10;                        Debug.LogWarning($&quot;Skill '{skillName}' is not recognized by FaAgent.&quot;);&#10;                        break;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;FaAgent reference missing, cannot use skill.&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup events&#10;            BossEventSystem.Unsubscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestRadarSkill, OnRequestRadarSkill);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestOtherSkill, OnRequestOtherSkill);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manager tổng thể cho Boss system - điểm tích hợp chính&#10;    /// &lt;/summary&gt;&#10;    public class BossManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Boss Setup&quot;)]&#10;        [SerializeField] private BossController bossController;&#10;        &#10;        [Header(&quot;Fa Agent Reference&quot;)]&#10;        [SerializeField] private Tu_Develop.Import.Scripts.FaAgent faAgent;&#10;&#10;        public static BossManager Instance { get; private set; }&#10;        &#10;        // Events for external systems&#10;        public System.Action&lt;int&gt; OnBossPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;        public System.Action&lt;int&gt; OnPlayerHealthChanged;&#10;&#10;        private void Awake()&#10;        {&#10;            // Singleton pattern&#10;            if (Instance != null &amp;&amp; Instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;            Instance = this;&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeBossSystem();&#10;        }&#10;&#10;        private void InitializeBossSystem()&#10;        {&#10;            // Setup boss controller if not assigned&#10;            if (bossController == null) bossController = FindFirstObjectByType&lt;BossController&gt;();&#10;            if (bossController == null)&#10;            {&#10;                Debug.LogError(&quot;BossController not found! Please assign it in the inspector.&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Setup FaAgent if not assigned&#10;            if (faAgent == null) faAgent = FindFirstObjectByType&lt;Tu_Develop.Import.Scripts.FaAgent&gt;();&#10;            if (faAgent == null)&#10;            {&#10;                Debug.LogError(&quot;FaAgent not found! Please assign it in the inspector.&quot;);&#10;            }&#10;            &#10;            // Register for boss events&#10;            RegisterBossEvents();&#10;        }&#10;&#10;       &#10;        private void RegisterBossEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Subscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Subscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Subscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;        }&#10;        &#10;        private void OnPhaseChanged(BossEventData data)&#10;        {&#10;            var newPhase = data.intValue;&#10;            OnBossPhaseChanged?.Invoke(newPhase);&#10;            &#10;            Debug.Log($&quot;Boss entered Phase {newPhase}&quot;);&#10;        }&#10;&#10;        private void OnBossDefeatedEvent(BossEventData data)&#10;        {&#10;            OnBossDefeated?.Invoke();&#10;            Debug.Log(&quot;Boss has been defeated!&quot;);&#10;        }&#10;&#10;        private void OnPlayerTakeDamageEvent(BossEventData data)&#10;        {&#10;            var damage = data.intValue;&#10;            OnPlayerHealthChanged?.Invoke(damage);&#10;        }&#10;&#10;        private void OnBossSpawned(BossEventData data)&#10;        {&#10;            Debug.Log(&quot;Boss has spawned and is ready for battle!&quot;);&#10;        }&#10;&#10;        private void OnRequestRadarSkill(BossEventData data)&#10;        {&#10;            Debug.Log(&quot;Requesting Fa to use Radar skill to destroy souls&quot;);&#10;            if (faAgent != null)&#10;            {&#10;                faAgent.UseGuideSignal();&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;FaAgent reference missing, cannot use Radar skill.&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnRequestOtherSkill(BossEventData data)&#10;        {&#10;            var skillName = data.stringValue ?? &quot;Unknown&quot;;&#10;            Debug.Log($&quot;Requesting Fa to use skill: {skillName}&quot;);&#10;            if (faAgent != null)&#10;            {&#10;                switch (skillName)&#10;                {&#10;                    case &quot;GuideSignal&quot;:&#10;                        faAgent.UseGuideSignal();&#10;                        BossEventSystem.Trigger(BossEventType.FaSkillUsed, new BossEventData(&quot;GuideSignal&quot;));&#10;                        break;&#10;                    case &quot;KnowledgeLight&quot;:&#10;                        faAgent.UseKnowledgeLight();&#10;                        BossEventSystem.Trigger(BossEventType.FaSkillUsed, new BossEventData(&quot;KnowledgeLight&quot;));&#10;                        break;&#10;                    case &quot;ProtectiveAura&quot;:&#10;                        faAgent.UseProtectiveAura();&#10;                        BossEventSystem.Trigger(BossEventType.FaSkillUsed, new BossEventData(&quot;ProtectiveAura&quot;));&#10;                        break;&#10;                    default:&#10;                        Debug.LogWarning($&quot;Skill '{skillName}' is not recognized by FaAgent.&quot;);&#10;                        break;&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;FaAgent reference missing, cannot use skill.&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup events&#10;            BossEventSystem.Unsubscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestRadarSkill, OnRequestRadarSkill);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestOtherSkill, OnRequestOtherSkill);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Phase1States.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Phase1States.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Idle State: Boss đứng yên tại chỗ&#10;    /// &lt;/summary&gt;&#10;    public class IdleState : BossState&#10;    {&#10;        private float idleTimer;&#10;        private bool canTransition = true;&#10;&#10;        public override void Enter()&#10;        {&#10;            idleTimer = 0f;&#10;            bossController.PlayAnimation(&quot;Idle&quot;);&#10;            &#10;            // Stop movement&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(bossController.transform.position);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            idleTimer += Time.deltaTime;&#10;            &#10;            if (idleTimer &gt;= config.phase1.idleDuration &amp;&amp; canTransition)&#10;            {&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        private void TransitionToNextState()&#10;        {&#10;            if (config.phase1.enableRandomStates)&#10;            {&#10;                BossState nextState = GetRandomNextState();&#10;                bossController.ChangeState(nextState);&#10;            }&#10;            else&#10;            {&#10;                // Default sequence: Idle -&gt; Lure -&gt; Mock -&gt; Decoy&#10;                bossController.ChangeState(new LureState());&#10;            }&#10;        }&#10;&#10;        private BossState GetRandomNextState()&#10;        {&#10;            float[] weights = config.phase1.stateWeights;&#10;            float totalWeight = weights[1] + weights[2] + weights[3]; // Exclude Idle weight&#10;            float randomValue = Random.Range(0f, totalWeight);&#10;            &#10;            float currentWeight = 0f;&#10;            &#10;            currentWeight += weights[1]; // Lure&#10;            if (randomValue &lt;= currentWeight)&#10;                return new LureState();&#10;                &#10;            currentWeight += weights[2]; // Mock&#10;            if (randomValue &lt;= currentWeight)&#10;                return new MockState();&#10;                &#10;            return new DecoyState(); // Decoy&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Idle state (only in Decoy state)&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false; // Idle state cannot be interrupted&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Lure State: Boss tiến lại gần người chơi rồi rút lui&#10;    /// &lt;/summary&gt;&#10;    public class LureState : BossState&#10;    {&#10;        private enum LurePhase { Approaching, Retreating, Completed }&#10;        private LurePhase currentPhase = LurePhase.Approaching;&#10;        private Vector3 originalPosition;&#10;        private Vector3 targetPosition;&#10;        private float stateTimer;&#10;&#10;        public override void Enter()&#10;        {&#10;            originalPosition = bossController.transform.position;&#10;            currentPhase = LurePhase.Approaching;&#10;            stateTimer = 0f;&#10;            &#10;            bossController.PlayAnimation(&quot;Lure&quot;);&#10;            BossEventSystem.Trigger(BossEventType.LureStarted);&#10;            &#10;            CalculateTargetPosition();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            stateTimer += Time.deltaTime;&#10;            &#10;            switch (currentPhase)&#10;            {&#10;                case LurePhase.Approaching:&#10;                    HandleApproaching();&#10;                    break;&#10;                case LurePhase.Retreating:&#10;                    HandleRetreating();&#10;                    break;&#10;                case LurePhase.Completed:&#10;                    // Transition to next state&#10;                    bossController.ChangeState(new MockState());&#10;                    break;&#10;            }&#10;        }&#10;&#10;        private void CalculateTargetPosition()&#10;        {&#10;            Vector3 directionToPlayer = (bossController.Player.position - bossController.transform.position).normalized;&#10;            targetPosition = bossController.Player.position - directionToPlayer * config.phase1.lureDistance;&#10;        }&#10;&#10;        private void HandleApproaching()&#10;        {&#10;            MoveTowards(targetPosition, config.phase1.lureApproachSpeed);&#10;            &#10;            float distanceToTarget = Vector3.Distance(bossController.transform.position, targetPosition);&#10;            if (distanceToTarget &lt; 0.5f || stateTimer &gt; config.phase1.lureDuration * 0.6f)&#10;            {&#10;                currentPhase = LurePhase.Retreating;&#10;            }&#10;        }&#10;&#10;        private void HandleRetreating()&#10;        {&#10;            MoveTowards(originalPosition, config.phase1.lureRetreatSpeed);&#10;            &#10;            float distanceToOriginal = Vector3.Distance(bossController.transform.position, originalPosition);&#10;            if (distanceToOriginal &lt; 0.5f || stateTimer &gt; config.phase1.lureDuration)&#10;            {&#10;                currentPhase = LurePhase.Completed;&#10;            }&#10;        }&#10;&#10;        private void MoveTowards(Vector3 target, float speed)&#10;        {&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = speed;&#10;                bossController.NavAgent.SetDestination(target);&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Reset movement speed&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = config.moveSpeed;&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Lure state&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Mock State: Boss phát tư thế vặn vẹo và tiếng cười méo mó&#10;    /// &lt;/summary&gt;&#10;    public class MockState : BossState&#10;    {&#10;        private float mockTimer;&#10;&#10;        public override void Enter()&#10;        {&#10;            mockTimer = 0f;&#10;            bossController.PlayAnimation(&quot;Mock&quot;);&#10;            BossEventSystem.Trigger(BossEventType.MockStarted);&#10;            &#10;            // Play mock laugh sound&#10;            if (config.audioConfig.mockLaughSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.mockLaughSound, config.audioConfig.sfxVolume);&#10;            }&#10;            &#10;            // Stop movement&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(bossController.transform.position);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            mockTimer += Time.deltaTime;&#10;            &#10;            if (mockTimer &gt;= config.phase1.mockDuration)&#10;            {&#10;                bossController.ChangeState(new DecoyState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Mock state&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Decoy State: Spawn 2 bóng ảo (1 thật 1 giả) truy đuổi người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated = false;&#10;        private GameObject realDecoy;&#10;        private GameObject fakeDecoy;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            &#10;            bossController.PlayAnimation(&quot;DecoyCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.DecoyStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;            &#10;            // Play decoy spawn sound&#10;            if (config.audioConfig.decoySpawnSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.decoySpawnSound, config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                HandleSkillActive();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase1.decoyCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase1.decoyCastTime)&#10;            {&#10;                ActivateSkill();&#10;            }&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            &#10;            SpawnDecoys();&#10;            bossController.PlayAnimation(&quot;DecoyActive&quot;);&#10;        }&#10;&#10;        private void SpawnDecoys()&#10;        {&#10;            Vector3 spawnCenter = bossController.Player.position;&#10;            float spawnRadius = config.phase1.decoySpawnRadius;&#10;            &#10;            // Spawn real decoy (this is actually the boss)&#10;            Vector3 realPos = GetRandomSpawnPosition(spawnCenter, spawnRadius);&#10;            realDecoy = CreateDecoy(realPos, true);&#10;            &#10;            // Spawn fake decoy&#10;            Vector3 fakePos = GetRandomSpawnPosition(spawnCenter, spawnRadius);&#10;            fakeDecoy = CreateDecoy(fakePos, false);&#10;            &#10;            // Hide original boss&#10;            bossController.gameObject.SetActive(false);&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition(Vector3 center, float radius)&#10;        {&#10;            Vector2 randomCircle = Random.insideUnitCircle.normalized * radius;&#10;            return center + new Vector3(randomCircle.x, 0, randomCircle.y);&#10;        }&#10;&#10;        private GameObject CreateDecoy(Vector3 position, bool isReal)&#10;        {&#10;            // Create decoy GameObject (assuming we have a prefab)&#10;            GameObject decoy = new GameObject(isReal ? &quot;RealDecoy&quot; : &quot;FakeDecoy&quot;);&#10;            decoy.transform.position = position;&#10;            &#10;            // Add decoy behavior&#10;            var decoyBehavior = decoy.AddComponent&lt;DecoyBehavior&gt;();&#10;            decoyBehavior.Initialize(bossController, isReal, config.phase1.decoyMoveSpeed);&#10;            &#10;            bossController.AddDecoy(decoy);&#10;            return decoy;&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            &#10;            if (skillTimer &gt;= config.phase1.decoyDuration)&#10;            {&#10;                EndDecoyState();&#10;            }&#10;        }&#10;&#10;        private void EndDecoyState()&#10;        {&#10;            // Clean up decoys&#10;            bossController.ClearDecoys();&#10;            &#10;            // Show original boss&#10;            bossController.gameObject.SetActive(true);&#10;            &#10;            // Return to idle&#10;            bossController.ChangeState(new IdleState());&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Ensure cleanup&#10;            if (skillActivated)&#10;            {&#10;                bossController.ClearDecoys();&#10;                bossController.gameObject.SetActive(true);&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                // Skill interrupted&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                bossController.ChangeState(new IdleState());&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting; // Can only be interrupted during casting&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Phase2States.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Phase2States.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Angry State: Boss di chuyển xoay quanh trung tâm NavMesh&#10;    /// &lt;/summary&gt;&#10;    public class AngryState : BossState&#10;    {&#10;        private float stateTimer;&#10;        private float currentAngle = 0f;&#10;        private Vector3 centerPosition;&#10;        private bool canTransition = true;&#10;&#10;        public override void Enter()&#10;        {&#10;            stateTimer = 0f;&#10;            centerPosition = bossController.NavMeshCenter != null ? &#10;                           bossController.NavMeshCenter.position : &#10;                           bossController.transform.position;&#10;            &#10;            bossController.PlayAnimation(&quot;Angry&quot;);&#10;            &#10;            // Set movement speed for angry state&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = config.phase2.angryMoveSpeed;&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            stateTimer += Time.deltaTime;&#10;            &#10;            // Move in circle around center&#10;            MoveInCircle();&#10;            &#10;            if (stateTimer &gt;= config.phase2.angryMoveDuration &amp;&amp; canTransition)&#10;            {&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        private void MoveInCircle()&#10;        {&#10;            float radius = config.phase2.circleRadius;&#10;            currentAngle += (config.phase2.angryMoveSpeed / radius) * Time.deltaTime;&#10;            &#10;            Vector3 targetPosition = centerPosition + new Vector3(&#10;                Mathf.Cos(currentAngle) * radius,&#10;                0,&#10;                Mathf.Sin(currentAngle) * radius&#10;            );&#10;            &#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(targetPosition);&#10;            }&#10;        }&#10;&#10;        private void TransitionToNextState()&#10;        {&#10;            // Random between FearZone and Scream states&#10;            if (Random.Range(0f, 1f) &lt; 0.5f)&#10;            {&#10;                bossController.ChangeState(new FearZoneState());&#10;            }&#10;            else&#10;            {&#10;                bossController.ChangeState(new ScreamState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Reset movement speed&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = config.moveSpeed;&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Angry state&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Fear Zone State: Tạo vùng tối dưới chân người chơi&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated = false;&#10;        private GameObject fearZone;&#10;        private Vector3 fearZonePosition;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            playerInZone = false;&#10;            playerInZoneTime = 0f;&#10;            &#10;            bossController.PlayAnimation(&quot;FearZoneCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.FearZoneCreated);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;            &#10;            // Record player position for fear zone&#10;            fearZonePosition = bossController.Player.position;&#10;            &#10;            // Play fear zone sound&#10;            if (config.audioConfig.fearZoneSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.fearZoneSound, config.audioConfig.ambientVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                HandleSkillActive();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase2.fearZoneCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase2.fearZoneCastTime)&#10;            {&#10;                ActivateSkill();&#10;            }&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            &#10;            CreateFearZone();&#10;            bossController.PlayAnimation(&quot;FearZoneActive&quot;);&#10;        }&#10;&#10;        private void CreateFearZone()&#10;        {&#10;            // Create fear zone GameObject&#10;            fearZone = new GameObject(&quot;FearZone&quot;);&#10;            fearZone.transform.position = fearZonePosition;&#10;            &#10;            // Add fear zone behavior&#10;            var fearZoneBehavior = fearZone.AddComponent&lt;FearZoneBehavior&gt;();&#10;            fearZoneBehavior.Initialize(config.phase2.fearZoneRadius, config.phase2.visionBlurIntensity);&#10;            &#10;            // Add trigger collider&#10;            var collider = fearZone.AddComponent&lt;SphereCollider&gt;();&#10;            collider.isTrigger = true;&#10;            collider.radius = config.phase2.fearZoneRadius;&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            &#10;            // Check if player is in fear zone&#10;            CheckPlayerInZone();&#10;            &#10;            if (skillTimer &gt;= config.phase2.fearZoneDuration)&#10;            {&#10;                EndFearZoneState();&#10;            }&#10;        }&#10;&#10;        private void CheckPlayerInZone()&#10;        {&#10;            if (fearZone == null) return;&#10;            &#10;            float distanceToPlayer = Vector3.Distance(fearZonePosition, bossController.Player.position);&#10;            bool currentlyInZone = distanceToPlayer &lt;= config.phase2.fearZoneRadius;&#10;            &#10;            if (currentlyInZone)&#10;            {&#10;                if (!playerInZone)&#10;                {&#10;                    playerInZone = true;&#10;                    playerInZoneTime = 0f;&#10;                    StartHeartbeatSound();&#10;                }&#10;                &#10;                playerInZoneTime += Time.deltaTime;&#10;                &#10;                if (playerInZoneTime &gt;= config.phase2.fearZoneActivationTime)&#10;                {&#10;                    ApplyFearEffects();&#10;                }&#10;            }&#10;            else&#10;            {&#10;                if (playerInZone)&#10;                {&#10;                    playerInZone = false;&#10;                    playerInZoneTime = 0f;&#10;                    StopHeartbeatSound();&#10;                }&#10;            }&#10;        }&#10;&#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (config.audioConfig.heartbeatSound != null)&#10;            {&#10;                bossController.AudioSource.clip = config.audioConfig.heartbeatSound;&#10;                bossController.AudioSource.loop = true;&#10;                bossController.AudioSource.Play();&#10;            }&#10;        }&#10;&#10;        private void StopHeartbeatSound()&#10;        {&#10;            bossController.AudioSource.Stop();&#10;            bossController.AudioSource.loop = false;&#10;        }&#10;&#10;        private void ApplyFearEffects()&#10;        {&#10;            // Apply vision blur and other fear effects&#10;            // This would integrate with a camera effects system&#10;            BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(0)); // Psychological damage&#10;        }&#10;&#10;        private void EndFearZoneState()&#10;        {&#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;            }&#10;            &#10;            StopHeartbeatSound();&#10;            bossController.ChangeState(new AngryState());&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;            }&#10;            StopHeartbeatSound();&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Scream State: Phát âm thanh chê trách và hiệu ứng&#10;    /// &lt;/summary&gt;&#10;    public class ScreamState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated = false;&#10;        private bool playerAttacked = false;&#10;        private bool playerHitBoss = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            playerAttacked = false;&#10;            playerHitBoss = false;&#10;            &#10;            bossController.PlayAnimation(&quot;ScreamCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.ScreamStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                HandleSkillActive();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase2.screamCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase2.screamCastTime)&#10;            {&#10;                ActivateSkill();&#10;            }&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            &#10;            bossController.PlayAnimation(&quot;ScreamActive&quot;);&#10;            &#10;            // Apply scream effects&#10;            ApplyScreamEffects();&#10;            &#10;            // Play scream sound&#10;            if (config.audioConfig.screamSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.screamSound, config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        private void ApplyScreamEffects()&#10;        {&#10;            // Apply screen shake&#10;            ApplyScreenShake();&#10;            &#10;            // Apply vision shrink&#10;            ApplyVisionShrink();&#10;        }&#10;&#10;        private void ApplyScreenShake()&#10;        {&#10;            // This would integrate with a camera shake system&#10;            // For now, trigger event for external system to handle&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;ScreenShake&quot;, floatValue = config.phase2.screenShakeIntensity });&#10;        }&#10;&#10;        private void ApplyVisionShrink()&#10;        {&#10;            // This would integrate with a camera/UI system&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;VisionShrink&quot;, floatValue = config.phase2.visionShrinkAmount });&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            &#10;            if (skillTimer &gt;= config.phase2.screamDuration)&#10;            {&#10;                EndScreamState();&#10;            }&#10;        }&#10;&#10;        private void EndScreamState()&#10;        {&#10;            if (playerHitBoss)&#10;            {&#10;                // Player hit boss successfully - boss takes damage&#10;                bossController.TakeDamage(1);&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;            else&#10;            {&#10;                // Player missed or didn't attack - player takes damage and spawn soul&#10;                BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                bossController.ChangeState(new SoulState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Remove scream effects&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;RemoveEffects&quot; });&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;            else if (skillActivated)&#10;            {&#10;                // Player hit boss during scream&#10;                playerHitBoss = true;&#10;                playerAttacked = true;&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting;&#10;        }&#10;&#10;        // Method to be called when player attacks (hit or miss)&#10;        public void OnPlayerAttack(bool hitBoss)&#10;        {&#10;            if (skillActivated)&#10;            {&#10;                playerAttacked = true;&#10;                playerHitBoss = hitBoss;&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Cook State: Boss bị đánh bại và rớt mảnh ghép&#10;    /// &lt;/summary&gt;&#10;    public class CookState : BossState&#10;    {&#10;        private float cookTimer;&#10;        private bool memoryFragmentDropped = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            cookTimer = 0f;&#10;            memoryFragmentDropped = false;&#10;            &#10;            bossController.PlayAnimation(&quot;Cook&quot;);&#10;            &#10;            // Stop all movement&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(bossController.transform.position);&#10;                bossController.NavAgent.enabled = false;&#10;            }&#10;            &#10;            // Clear all souls&#10;            bossController.SoulManager.DestroyAllSouls();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            cookTimer += Time.deltaTime;&#10;            &#10;            // Gradually fade boss&#10;            FadeBoss();&#10;            &#10;            if (cookTimer &gt;= config.phase2.cookStateDuration &amp;&amp; !memoryFragmentDropped)&#10;            {&#10;                DropMemoryFragment();&#10;                memoryFragmentDropped = true;&#10;            }&#10;            &#10;            if (cookTimer &gt;= config.phase2.cookStateDuration + 1f)&#10;            {&#10;                CompleteBossDefeat();&#10;            }&#10;        }&#10;&#10;        private void FadeBoss()&#10;        {&#10;            float fadeProgress = cookTimer / config.phase2.cookStateDuration;&#10;            &#10;            // This would integrate with a material/shader system to fade the boss&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;FadeBoss&quot;, floatValue = 1f - fadeProgress });&#10;        }&#10;&#10;        private void DropMemoryFragment()&#10;        {&#10;            // Create memory fragment at boss position&#10;            GameObject memoryFragment = new GameObject(&quot;MemoryFragment&quot;);&#10;            memoryFragment.transform.position = bossController.transform.position;&#10;            &#10;            // Add memory fragment behavior (to be implemented)&#10;            var fragmentBehavior = memoryFragment.AddComponent&lt;MemoryFragmentBehavior&gt;();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossDefeated, new BossEventData(memoryFragment));&#10;        }&#10;&#10;        private void CompleteBossDefeat()&#10;        {&#10;            // Boss completely defeated&#10;            bossController.gameObject.SetActive(false);&#10;            // Or destroy the boss GameObject&#10;            // Object.Destroy(bossController.gameObject);&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed - boss is defeated&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage when cooking/defeated&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/SoulAndTransitionStates.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/SoulAndTransitionStates.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Soul State: Teleport và spawn soul (dùng cho cả Phase 1 và Phase 2)&#10;    /// &lt;/summary&gt;&#10;    public class SoulState : BossState&#10;    {&#10;        private float castTimer;&#10;        private bool isCasting = true;&#10;        private Vector3 teleportPosition;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            isCasting = true;&#10;            &#10;            bossController.PlayAnimation(&quot;SoulCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.SoulStateStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;            &#10;            // Calculate teleport position&#10;            CalculateTeleportPosition();&#10;            &#10;            // Play soul spawn sound&#10;            if (config.audioConfig.soulSpawnSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.soulSpawnSound, config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                // Immediately transition after teleport and soul spawn&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase1.soulStateCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase1.soulStateCastTime)&#10;            {&#10;                ExecuteTeleportAndSpawnSoul();&#10;            }&#10;        }&#10;&#10;        private void CalculateTeleportPosition()&#10;        {&#10;            // Teleport to a random position away from player&#10;            Vector3 playerPos = bossController.Player.position;&#10;            Vector2 randomDirection = Random.insideUnitCircle.normalized;&#10;            float teleportDistance = config.soulConfig.soulSpawnRadius * 0.8f;&#10;            &#10;            teleportPosition = playerPos + new Vector3(randomDirection.x, 0, randomDirection.y) * teleportDistance;&#10;        }&#10;&#10;        private void ExecuteTeleportAndSpawnSoul()&#10;        {&#10;            isCasting = false;&#10;            &#10;            // Teleport boss&#10;            bossController.transform.position = teleportPosition;&#10;            bossController.PlayAnimation(&quot;SoulActive&quot;);&#10;            &#10;            // Spawn soul if under limit&#10;            if (bossController.SoulManager.ActiveSoulCount &lt; bossController.SoulManager.MaxSouls)&#10;            {&#10;                bossController.SoulManager.SpawnSoul();&#10;            }&#10;        }&#10;&#10;        private void TransitionToNextState()&#10;        {&#10;            // Transition based on current phase&#10;            if (bossController.CurrentPhase == 1)&#10;            {&#10;                bossController.ChangeState(new IdleState());&#10;            }&#10;            else // Phase 2&#10;            {&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Phase Change State: Chuyển đổi sang Phase 2&#10;    /// &lt;/summary&gt;&#10;    public class PhaseChangeState : BossState&#10;    {&#10;        private float transitionTimer;&#10;        private bool transitionCompleted = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            transitionTimer = 0f;&#10;            transitionCompleted = false;&#10;            &#10;            bossController.PlayAnimation(&quot;PhaseChange&quot;);&#10;            &#10;            // Play phase change sound&#10;            if (config.audioConfig.phaseChangeSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.phaseChangeSound, config.audioConfig.sfxVolume);&#10;            }&#10;            &#10;            // Clear any remaining decoys and souls&#10;            bossController.ClearDecoys();&#10;            bossController.SoulManager.DestroyAllSouls();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            transitionTimer += Time.deltaTime;&#10;            &#10;            if (transitionTimer &gt;= 2f &amp;&amp; !transitionCompleted) // 2 second transition&#10;            {&#10;                transitionCompleted = true;&#10;                bossController.ChangeToPhase(2);&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Cleanup handled in Enter()&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Cannot take damage during phase transition&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/States/Phase1/DecoyState.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/States/Phase1/DecoyState.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss.States.Phase1&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Decoy State: Spawn 2 bóng ảo (1 thật 1 giả) truy đuổi người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated;&#10;        &#10;        private GameObject realDecoy;&#10;        private GameObject fakeDecoy;&#10;        private GameObject decoyEffect1;&#10;        private GameObject decoyEffect2;&#10;        private bool decoyEffectSpawned;&#10;&#10;        public override void Enter()&#10;        {&#10;            Debug.Log(&quot;[Boss State] Entered DecoyState - Spawn 2 bóng ảo (1 thật 1 giả) truy đuổi người chơi&quot;);&#10;&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            BossEventSystem.Trigger(BossEventType.DecoyStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, new BossEventData { stringValue = &quot;Decoy&quot; });&#10;&#10;            // Play decoy spawn sound&#10;            if (Config.audioConfig.decoySpawnSound != null)&#10;            {&#10;                BossController.PlaySound(Config.audioConfig.decoySpawnSound, Config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting) HandleCasting();&#10;            else HandleSkillActive();&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            // Spawn decoy effect at the beginning of casting&#10;            if (!decoyEffectSpawned)&#10;            {&#10;                SpawnDecoyCastEffects();&#10;                decoyEffectSpawned = true;&#10;            }&#10;            // Update skill cast progress for UI&#10;            var progress = castTimer / Config.phase1.decoyCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            if (castTimer &gt;= Config.phase1.decoyCastTime) ActivateSkill();&#10;        }&#10;&#10;        private void SpawnDecoyCastEffects()&#10;        {&#10;            var spawnPoint1 = GameObject.Find(&quot;DecoySpawnPoint1&quot;);&#10;            var spawnPoint2 = GameObject.Find(&quot;DecoySpawnPoint2&quot;);&#10;            var point1 = spawnPoint1 != null ? spawnPoint1.transform.position : BossController.transform.position + Vector3.left * 2f;&#10;            var point2 = spawnPoint2 != null ? spawnPoint2.transform.position : BossController.transform.position + Vector3.right * 2f;&#10;            &#10;            if (Config.phase1.decoySpawnEffectPrefab == null) return;&#10;            &#10;            var effectRotation = Quaternion.Euler(0, 90, 0);&#10;            decoyEffect1 = Object.Instantiate(Config.phase1.decoySpawnEffectPrefab, point1, effectRotation);&#10;            decoyEffect2 = Object.Instantiate(Config.phase1.decoySpawnEffectPrefab, point2, effectRotation);&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;            SpawnDecoys();&#10;            DisableDecoyEffects();&#10;        }&#10;&#10;        private void SpawnDecoys()&#10;        {&#10;            // Tìm 2 spawn point trong scene&#10;            var spawnPoint1 = GameObject.Find(&quot;DecoySpawnPoint1&quot;);&#10;            var spawnPoint2 = GameObject.Find(&quot;DecoySpawnPoint2&quot;);&#10;            var point1 = spawnPoint1 != null ? spawnPoint1.transform.position : &#10;                BossController.transform.position + Vector3.left * 2f;&#10;            var point2 = spawnPoint2 != null ? spawnPoint2.transform.position : &#10;                BossController.transform.position + Vector3.right * 2f;&#10;&#10;            // Random vị trí real/fake decoy&#10;            var realAtPoint1 = Random.value &gt; 0.5f;&#10;            if (realAtPoint1)&#10;            {&#10;                realDecoy = CreateDecoy(point1, true);&#10;                fakeDecoy = CreateDecoy(point2, false);&#10;            }&#10;            else&#10;            {&#10;                realDecoy = CreateDecoy(point2, true);&#10;                fakeDecoy = CreateDecoy(point1, false);&#10;            }&#10;            BossController.gameObject.SetActive(false);&#10;        }&#10;        &#10;        private GameObject CreateDecoy(Vector3 position, bool isReal)&#10;        {&#10;            // Check if decoy prefab is assigned&#10;            if (Config.phase1.decoyPrefab == null)&#10;            {&#10;                Debug.LogError(&quot;[DecoyState] Decoy prefab is not assigned in BossConfig! Please assign a decoy prefab in Phase1Config.&quot;);&#10;                return null;&#10;            }&#10;            &#10;            // Instantiate decoy from prefab&#10;            var decoy = Object.Instantiate(Config.phase1.decoyPrefab, position, Quaternion.identity);&#10;            decoy.name = isReal ? &quot;RealDecoy&quot; : &quot;FakeDecoy&quot;;&#10;            &#10;            // Add decoy behavior&#10;            var decoyBehavior = decoy.GetComponent&lt;DecoyBehavior&gt;();&#10;            if (decoyBehavior == null)&#10;                decoyBehavior = decoy.AddComponent&lt;DecoyBehavior&gt;();&#10;                &#10;            decoyBehavior.Initialize(BossController, isReal, Config.phase1.decoyMoveSpeed);&#10;            &#10;            BossController.AddDecoy(decoy);&#10;            return decoy;&#10;        }&#10;        &#10;        private void DisableDecoyEffects()&#10;        {&#10;            if (!decoyEffectSpawned) return;&#10;            // Chờ 2s&#10;            if (decoyEffect1 != null) &#10;                Object.Destroy(decoyEffect1, 2f);&#10;            if (decoyEffect2 != null) &#10;                Object.Destroy(decoyEffect2, 2f);&#10;            // Clear the decoy effects&#10;            decoyEffectSpawned = false;&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            if (skillTimer &gt;= Config.phase1.decoyDuration) EndDecoyState();&#10;        }&#10;&#10;        private void EndDecoyState()&#10;        {&#10;            BossController.ClearDecoys();&#10;            BossController.gameObject.SetActive(true);&#10;            BossController.ChangeState(new IdleState());&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            if (!skillActivated) return;&#10;            BossController.ClearDecoys();&#10;            BossController.gameObject.SetActive(true);&#10;        }&#10;&#10;        public override void OnTakeDamage() {}&#10;        public override bool CanTakeDamage() =&gt; false;&#10;        public override bool CanBeInterrupted() =&gt; isCasting;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss.States.Phase1&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Decoy State: Spawn 2 bóng ảo (1 thật 1 giả) truy đuổi người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated;&#10;        &#10;        private GameObject realDecoy;&#10;        private GameObject fakeDecoy;&#10;        private GameObject decoyEffect1;&#10;        private GameObject decoyEffect2;&#10;        private bool decoyEffectSpawned;&#10;        private GameObject realDecoyRevealEffectInstance;&#10;&#10;        public override void Enter()&#10;        {&#10;            Debug.Log(&quot;[Boss State] Entered DecoyState - Spawn 2 bóng ảo (1 thật 1 giả) truy đuổi người chơi&quot;);&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            BossEventSystem.Trigger(BossEventType.DecoyStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, new BossEventData { stringValue = &quot;Decoy&quot; });&#10;            // Play decoy spawn sound&#10;            if (Config.audioConfig.decoySpawnSound != null)&#10;            {&#10;                BossController.PlaySound(Config.audioConfig.decoySpawnSound, Config.audioConfig.sfxVolume);&#10;            }&#10;            // Đăng ký lắng nghe sự kiện GuideSignal&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting) HandleCasting();&#10;            else HandleSkillActive();&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            // Spawn decoy effect at the beginning of casting&#10;            if (!decoyEffectSpawned)&#10;            {&#10;                SpawnDecoyCastEffects();&#10;                decoyEffectSpawned = true;&#10;            }&#10;            // Update skill cast progress for UI&#10;            var progress = castTimer / Config.phase1.decoyCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            if (castTimer &gt;= Config.phase1.decoyCastTime) ActivateSkill();&#10;        }&#10;&#10;        private void SpawnDecoyCastEffects()&#10;        {&#10;            var spawnPoint1 = GameObject.Find(&quot;DecoySpawnPoint1&quot;);&#10;            var spawnPoint2 = GameObject.Find(&quot;DecoySpawnPoint2&quot;);&#10;            var point1 = spawnPoint1 != null ? spawnPoint1.transform.position : BossController.transform.position + Vector3.left * 2f;&#10;            var point2 = spawnPoint2 != null ? spawnPoint2.transform.position : BossController.transform.position + Vector3.right * 2f;&#10;            &#10;            if (Config.phase1.decoySpawnEffectPrefab == null) return;&#10;            &#10;            var effectRotation = Quaternion.Euler(0, 90, 0);&#10;            decoyEffect1 = Object.Instantiate(Config.phase1.decoySpawnEffectPrefab, point1, effectRotation);&#10;            decoyEffect2 = Object.Instantiate(Config.phase1.decoySpawnEffectPrefab, point2, effectRotation);&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;            SpawnDecoys();&#10;            DisableDecoyEffects();&#10;        }&#10;&#10;        private void SpawnDecoys()&#10;        {&#10;            // Tìm 2 spawn point trong scene&#10;            var spawnPoint1 = GameObject.Find(&quot;DecoySpawnPoint1&quot;);&#10;            var spawnPoint2 = GameObject.Find(&quot;DecoySpawnPoint2&quot;);&#10;            var point1 = spawnPoint1 != null ? spawnPoint1.transform.position : &#10;                BossController.transform.position + Vector3.left * 2f;&#10;            var point2 = spawnPoint2 != null ? spawnPoint2.transform.position : &#10;                BossController.transform.position + Vector3.right * 2f;&#10;&#10;            // Random vị trí real/fake decoy&#10;            var realAtPoint1 = Random.value &gt; 0.5f;&#10;            if (realAtPoint1)&#10;            {&#10;                realDecoy = CreateDecoy(point1, true);&#10;                fakeDecoy = CreateDecoy(point2, false);&#10;            }&#10;            else&#10;            {&#10;                realDecoy = CreateDecoy(point2, true);&#10;                fakeDecoy = CreateDecoy(point1, false);&#10;            }&#10;            BossController.gameObject.SetActive(false);&#10;        }&#10;        &#10;        private GameObject CreateDecoy(Vector3 position, bool isReal)&#10;        {&#10;            // Check if decoy prefab is assigned&#10;            if (Config.phase1.decoyPrefab == null)&#10;            {&#10;                Debug.LogError(&quot;[DecoyState] Decoy prefab is not assigned in BossConfig! Please assign a decoy prefab in Phase1Config.&quot;);&#10;                return null;&#10;            }&#10;            &#10;            // Instantiate decoy from prefab&#10;            var decoy = Object.Instantiate(Config.phase1.decoyPrefab, position, Quaternion.identity);&#10;            decoy.name = isReal ? &quot;RealDecoy&quot; : &quot;FakeDecoy&quot;;&#10;            &#10;            // Add decoy behavior&#10;            var decoyBehavior = decoy.GetComponent&lt;DecoyBehavior&gt;();&#10;            if (decoyBehavior == null)&#10;                decoyBehavior = decoy.AddComponent&lt;DecoyBehavior&gt;();&#10;                &#10;            decoyBehavior.Initialize(BossController, isReal, Config.phase1.decoyMoveSpeed);&#10;            &#10;            BossController.AddDecoy(decoy);&#10;            return decoy;&#10;        }&#10;        &#10;        private void DisableDecoyEffects()&#10;        {&#10;            if (!decoyEffectSpawned) return;&#10;            // Chờ 2s&#10;            if (decoyEffect1 != null) &#10;                Object.Destroy(decoyEffect1, 2f);&#10;            if (decoyEffect2 != null) &#10;                Object.Destroy(decoyEffect2, 2f);&#10;            // Clear the decoy effects&#10;            decoyEffectSpawned = false;&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            if (skillTimer &gt;= Config.phase1.decoyDuration) EndDecoyState();&#10;        }&#10;&#10;        private void EndDecoyState()&#10;        {&#10;            BossController.ClearDecoys();&#10;            BossController.gameObject.SetActive(true);&#10;            BossController.ChangeState(new IdleState());&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            if (!skillActivated) return;&#10;            BossController.ClearDecoys();&#10;            BossController.gameObject.SetActive(true);&#10;            // Hủy đăng ký sự kiện khi thoát state&#10;            BossEventSystem.Unsubscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;            // Xóa hiệu ứng nếu có&#10;            if (realDecoyRevealEffectInstance != null)&#10;            {&#10;                Object.Destroy(realDecoyRevealEffectInstance);&#10;                realDecoyRevealEffectInstance = null;&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage() {}&#10;        public override bool CanTakeDamage() =&gt; false;&#10;        public override bool CanBeInterrupted() =&gt; isCasting;&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            if (data != null &amp;&amp; data.stringValue == &quot;GuideSignal&quot;)&#10;            {&#10;                RevealRealDecoy();&#10;            }&#10;        }&#10;&#10;        private void RevealRealDecoy()&#10;        {&#10;            if (realDecoy != null)&#10;            {&#10;                // Bật outline hoặc đổi màu vật liệu&#10;                var outline = realDecoy.GetComponent&lt;Outline&gt;();&#10;                if (outline != null)&#10;                {&#10;                    outline.enabled = true;&#10;                }&#10;                else&#10;                {&#10;                    var renderer = realDecoy.GetComponent&lt;Renderer&gt;();&#10;                    if (renderer != null)&#10;                    {&#10;                        renderer.material.color = Color.yellow;&#10;                    }&#10;                }&#10;                // Spawn hiệu ứng prefab nếu có cấu hình&#10;                if (Config.phase1.realDecoyRevealEffectPrefab != null &amp;&amp; realDecoyRevealEffectInstance == null)&#10;                {&#10;                    realDecoyRevealEffectInstance = Object.Instantiate(&#10;                        Config.phase1.realDecoyRevealEffectPrefab,&#10;                        realDecoy.transform.position,&#10;                        Quaternion.identity,&#10;                        realDecoy.transform&#10;                    );&#10;                }&#10;                Debug.Log(&quot;[DecoyState] Real decoy revealed by GuideSignal!&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manager chính để setup và quản lý toàn bộ test environment&#10;    /// &lt;/summary&gt;&#10;    public class BossTestManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Test Setup&quot;)]&#10;        [SerializeField] private GameObject playerPrefab;&#10;        [SerializeField] private GameObject bossPrefab;&#10;        [SerializeField] private BossConfig testBossConfig;&#10;        &#10;        [Header(&quot;Test Environment&quot;)]&#10;        [SerializeField] private Vector3 playerSpawnPoint = new Vector3(0, 1, -10);&#10;        [SerializeField] private Vector3 bossSpawnPoint = new Vector3(0, 1, 10);&#10;        [SerializeField] private Vector3 navMeshCenter = Vector3.zero;&#10;        &#10;        [Header(&quot;Test Settings&quot;)]&#10;        [SerializeField] private bool autoStartTest = true;&#10;        [SerializeField] private bool showTestUI = true;&#10;        [SerializeField] private KeyCode resetTestKey = KeyCode.F1;&#10;        [SerializeField] private KeyCode nextPhaseKey = KeyCode.F2;&#10;        [SerializeField] private KeyCode spawnSoulKey = KeyCode.F3;&#10;        &#10;        // Test objects&#10;        private GameObject testPlayer;&#10;        private GameObject testBoss;&#10;        private BossController bossController;&#10;        private PlayerTestController playerController;&#10;        private FaSkillSimulator faSimulator;&#10;        &#10;        // Test data&#10;        private float testStartTime;&#10;        private int playerDeaths = 0;&#10;        private int bossDeaths = 0;&#10;        private int skillsUsed = 0;&#10;&#10;        private void Start()&#10;        {&#10;            if (autoStartTest)&#10;            {&#10;                StartTest();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            HandleTestInput();&#10;        }&#10;&#10;        private void HandleTestInput()&#10;        {&#10;            // Reset test&#10;            if (Input.GetKeyDown(resetTestKey))&#10;            {&#10;                ResetTest();&#10;            }&#10;            &#10;            // Force next phase&#10;            if (Input.GetKeyDown(nextPhaseKey))&#10;            {&#10;                ForceNextPhase();&#10;            }&#10;            &#10;            // Spawn test soul&#10;            if (Input.GetKeyDown(spawnSoulKey))&#10;            {&#10;                SpawnTestSoul();&#10;            }&#10;            &#10;            // Quick damage boss (for testing)&#10;            if (Input.GetKeyDown(KeyCode.F4))&#10;            {&#10;                if (bossController != null)&#10;                {&#10;                    bossController.TakeDamage(1);&#10;                    Debug.Log(&quot;[Test] Boss took 1 damage&quot;);&#10;                }&#10;            }&#10;            &#10;            // Quick heal player (for testing)&#10;            if (Input.GetKeyDown(KeyCode.F5))&#10;            {&#10;                var bossManager = BossManager.Instance;&#10;                if (bossManager != null)&#10;                {&#10;                    bossManager.HealPlayer(1);&#10;                    Debug.Log(&quot;[Test] Player healed 1 HP&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void StartTest()&#10;        {&#10;            Debug.Log(&quot;[Test Manager] Starting Boss FSM Test...&quot;);&#10;            testStartTime = Time.time;&#10;            &#10;            // Clean up existing test objects&#10;            CleanupTest();&#10;            &#10;            // Create test environment&#10;            CreateTestEnvironment();&#10;            &#10;            // Setup test objects&#10;            SetupTestPlayer();&#10;            SetupTestBoss();&#10;            SetupFaSimulator();&#10;            &#10;            Debug.Log(&quot;[Test Manager] Test environment ready!&quot;);&#10;        }&#10;&#10;        private void CreateTestEnvironment()&#10;        {&#10;            // Create a simple test ground&#10;            GameObject ground = GameObject.CreatePrimitive(PrimitiveType.Plane);&#10;            ground.name = &quot;TestGround&quot;;&#10;            ground.transform.localScale = new Vector3(5, 1, 5); // 50x50 units&#10;            ground.transform.position = Vector3.zero;&#10;            &#10;            // Add a simple material&#10;            var groundRenderer = ground.GetComponent&lt;Renderer&gt;();&#10;            if (groundRenderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = new Color(0.3f, 0.7f, 0.3f); // Green ground&#10;                groundRenderer.material = material;&#10;            }&#10;            &#10;            // Create NavMesh center marker&#10;            GameObject navCenter = GameObject.CreatePrimitive(PrimitiveType.Cylinder);&#10;            navCenter.name = &quot;NavMeshCenter&quot;;&#10;            navCenter.transform.position = navMeshCenter;&#10;            navCenter.transform.localScale = new Vector3(1, 0.1f, 1);&#10;            &#10;            var centerRenderer = navCenter.GetComponent&lt;Renderer&gt;();&#10;            if (centerRenderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = Color.blue;&#10;                centerRenderer.material = material;&#10;            }&#10;        }&#10;&#10;        private void SetupTestPlayer()&#10;        {&#10;            // Create test player&#10;            if (playerPrefab != null)&#10;            {&#10;                testPlayer = Instantiate(playerPrefab, playerSpawnPoint, Quaternion.identity);&#10;            }&#10;            else&#10;            {&#10;                testPlayer = GameObject.CreatePrimitive(PrimitiveType.Capsule);&#10;                testPlayer.name = &quot;TestPlayer&quot;;&#10;                testPlayer.transform.position = playerSpawnPoint;&#10;                testPlayer.tag = &quot;Player&quot;;&#10;                &#10;                // Make player blue&#10;                var renderer = testPlayer.GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                    material.color = Color.blue;&#10;                    renderer.material = material;&#10;                }&#10;            }&#10;            &#10;            // Add player test controller&#10;            playerController = testPlayer.GetComponent&lt;PlayerTestController&gt;();&#10;            if (playerController == null)&#10;            {&#10;                playerController = testPlayer.AddComponent&lt;PlayerTestController&gt;();&#10;            }&#10;            &#10;            Debug.Log(&quot;[Test Manager] Test player created&quot;);&#10;        }&#10;&#10;        private void SetupTestBoss()&#10;        {&#10;            // Create test boss&#10;            if (bossPrefab != null)&#10;            {&#10;                testBoss = Instantiate(bossPrefab, bossSpawnPoint, Quaternion.identity);&#10;            }&#10;            else&#10;            {&#10;                testBoss = GameObject.CreatePrimitive(PrimitiveType.Cube);&#10;                testBoss.name = &quot;TestBoss&quot;;&#10;                testBoss.transform.position = bossSpawnPoint;&#10;                testBoss.transform.localScale = Vector3.one * 2;&#10;                &#10;                // Make boss red&#10;                var renderer = testBoss.GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                    material.color = Color.red;&#10;                    renderer.material = material;&#10;                }&#10;            }&#10;            &#10;            // Add boss components&#10;            bossController = testBoss.GetComponent&lt;BossController&gt;();&#10;            if (bossController == null)&#10;            {&#10;                bossController = testBoss.AddComponent&lt;BossController&gt;();&#10;            }&#10;            &#10;            // Add NavMeshAgent&#10;            var navAgent = testBoss.GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();&#10;            if (navAgent == null)&#10;            {&#10;                navAgent = testBoss.AddComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();&#10;            }&#10;            &#10;            // Setup boss configuration&#10;            if (testBossConfig != null)&#10;            {&#10;                // Use reflection to set the private config field&#10;                var configField = typeof(BossController).GetField(&quot;bossConfig&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                configField?.SetValue(bossController, testBossConfig);&#10;            }&#10;            &#10;            // Set references&#10;            SetBossReferences();&#10;            &#10;            Debug.Log(&quot;[Test Manager] Test boss created&quot;);&#10;        }&#10;&#10;        private void SetBossReferences()&#10;        {&#10;            // Set player reference&#10;            var playerField = typeof(BossController).GetField(&quot;player&quot;, &#10;                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;            playerField?.SetValue(bossController, testPlayer.transform);&#10;            &#10;            // Set NavMesh center&#10;            GameObject navCenterObj = GameObject.Find(&quot;NavMeshCenter&quot;);&#10;            if (navCenterObj != null)&#10;            {&#10;                var navCenterField = typeof(BossController).GetField(&quot;navMeshCenter&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                navCenterField?.SetValue(bossController, navCenterObj.transform);&#10;            }&#10;        }&#10;&#10;        private void SetupFaSimulator()&#10;        {&#10;            // Create Fa simulator&#10;            GameObject faSimulatorObj = new GameObject(&quot;FaSimulator&quot;);&#10;            faSimulator = faSimulatorObj.AddComponent&lt;FaSkillSimulator&gt;();&#10;            &#10;            // Add boss integration&#10;            var faIntegration = faSimulatorObj.AddComponent&lt;FaBossIntegration&gt;();&#10;            &#10;            Debug.Log(&quot;[Test Manager] Fa simulator created&quot;);&#10;        }&#10;&#10;        public void ResetTest()&#10;        {&#10;            Debug.Log(&quot;[Test Manager] Resetting test...&quot;);&#10;            &#10;            CleanupTest();&#10;            StartTest();&#10;        }&#10;&#10;        private void CleanupTest()&#10;        {&#10;            // Destroy test objects&#10;            if (testPlayer != null)&#10;                DestroyImmediate(testPlayer);&#10;            if (testBoss != null)&#10;                DestroyImmediate(testBoss);&#10;            if (faSimulator != null)&#10;                DestroyImmediate(faSimulator.gameObject);&#10;            &#10;            // Clean up environment objects&#10;            var ground = GameObject.Find(&quot;TestGround&quot;);&#10;            if (ground != null)&#10;                DestroyImmediate(ground);&#10;            &#10;            var navCenter = GameObject.Find(&quot;NavMeshCenter&quot;);&#10;            if (navCenter != null)&#10;                DestroyImmediate(navCenter);&#10;            &#10;            // Clear boss event system&#10;            BossEventSystem.ClearAllListeners();&#10;        }&#10;&#10;        private void ForceNextPhase()&#10;        {&#10;            if (bossController != null)&#10;            {&#10;                int currentPhase = bossController.CurrentPhase;&#10;                int nextPhase = currentPhase == 1 ? 2 : 1;&#10;                bossController.ChangeToPhase(nextPhase);&#10;                Debug.Log($&quot;[Test] Forced phase change from {currentPhase} to {nextPhase}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SpawnTestSoul()&#10;        {&#10;            if (bossController != null &amp;&amp; bossController.SoulManager != null)&#10;            {&#10;                bossController.SoulManager.SpawnSoul();&#10;                Debug.Log(&quot;[Test] Test soul spawned&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (!showTestUI) return;&#10;            &#10;            GUILayout.BeginArea(new Rect(640, 10, 350, 250));&#10;            GUILayout.Label(&quot;=== BOSS TEST MANAGER ===&quot;);&#10;            &#10;            GUILayout.Space(5);&#10;            GUILayout.Label(&quot;QUICK ACTIONS:&quot;);&#10;            if (GUILayout.Button(&quot;Reset Test (F1)&quot;))&#10;            {&#10;                ResetTest();&#10;            }&#10;            if (GUILayout.Button(&quot;Force Next Phase (F2)&quot;))&#10;            {&#10;                ForceNextPhase();&#10;            }&#10;            if (GUILayout.Button(&quot;Spawn Soul (F3)&quot;))&#10;            {&#10;                SpawnTestSoul();&#10;            }&#10;            if (GUILayout.Button(&quot;Damage Boss (F4)&quot;))&#10;            {&#10;                bossController?.TakeDamage(1);&#10;            }&#10;            if (GUILayout.Button(&quot;Heal Player (F5)&quot;))&#10;            {&#10;                BossManager.Instance?.HealPlayer(1);&#10;            }&#10;            &#10;            GUILayout.Space(10);&#10;            GUILayout.Label(&quot;TEST INFO:&quot;);&#10;            GUILayout.Label($&quot;Test Time: {Time.time - testStartTime:F1}s&quot;);&#10;            if (bossController != null)&#10;            {&#10;                GUILayout.Label($&quot;Boss Phase: {bossController.CurrentPhase}&quot;);&#10;                GUILayout.Label($&quot;Boss State: {BossManager.Instance?.GetCurrentBossState() ?? &quot;None&quot;}&quot;);&#10;                GUILayout.Label($&quot;Boss HP: {bossController.HealthSystem?.CurrentHealth ?? 0}&quot;);&#10;            }&#10;            GUILayout.Label($&quot;Active Souls: {FaBossIntegration.GetCurrentSoulCount()}&quot;);&#10;            &#10;            GUILayout.EndArea();&#10;        }&#10;&#10;        private void OnApplicationQuit()&#10;        {&#10;            CleanupTest();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestSceneSetup.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestSceneSetup.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEditor;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Scene setup helper để tạo test scene tự động&#10;    /// &lt;/summary&gt;&#10;    public class BossTestSceneSetup : MonoBehaviour&#10;    {&#10;        [Header(&quot;Auto Setup&quot;)]&#10;        [SerializeField] private bool setupOnStart = false;&#10;        &#10;        [Header(&quot;Scene Objects&quot;)]&#10;        [SerializeField] private Camera mainCamera;&#10;        [SerializeField] private Light directionalLight;&#10;        &#10;        private void Start()&#10;        {&#10;            if (setupOnStart)&#10;            {&#10;                SetupTestScene();&#10;            }&#10;        }&#10;&#10;        [ContextMenu(&quot;Setup Test Scene&quot;)]&#10;        public void SetupTestScene()&#10;        {&#10;            Debug.Log(&quot;[Scene Setup] Setting up Boss test scene...&quot;);&#10;            &#10;            // Setup camera&#10;            SetupCamera();&#10;            &#10;            // Setup lighting&#10;            SetupLighting();&#10;            &#10;            // Setup test manager&#10;            SetupTestManager();&#10;            &#10;            // Setup UI canvas&#10;            SetupUICanvas();&#10;            &#10;            Debug.Log(&quot;[Scene Setup] Test scene setup complete!&quot;);&#10;        }&#10;&#10;        private void SetupCamera()&#10;        {&#10;            if (mainCamera == null)&#10;            {&#10;                var cameraObj = GameObject.FindObjectOfType&lt;Camera&gt;();&#10;                if (cameraObj == null)&#10;                {&#10;                    cameraObj = new GameObject(&quot;Main Camera&quot;).AddComponent&lt;Camera&gt;();&#10;                }&#10;                mainCamera = cameraObj;&#10;            }&#10;            &#10;            // Position camera for good view of test area&#10;            mainCamera.transform.position = new Vector3(0, 12, -15);&#10;            mainCamera.transform.rotation = Quaternion.Euler(25, 0, 0);&#10;            mainCamera.clearFlags = CameraClearFlags.Skybox;&#10;            &#10;            // Add audio listener if not present&#10;            if (mainCamera.GetComponent&lt;AudioListener&gt;() == null)&#10;            {&#10;                mainCamera.gameObject.AddComponent&lt;AudioListener&gt;();&#10;            }&#10;            &#10;            Debug.Log(&quot;[Scene Setup] Camera configured&quot;);&#10;        }&#10;&#10;        private void SetupLighting()&#10;        {&#10;            if (directionalLight == null)&#10;            {&#10;                var lightObj = GameObject.FindObjectOfType&lt;Light&gt;();&#10;                if (lightObj == null)&#10;                {&#10;                    lightObj = new GameObject(&quot;Directional Light&quot;).AddComponent&lt;Light&gt;();&#10;                }&#10;                directionalLight = lightObj;&#10;            }&#10;            &#10;            directionalLight.type = LightType.Directional;&#10;            directionalLight.transform.rotation = Quaternion.Euler(45, 45, 0);&#10;            directionalLight.intensity = 1.2f;&#10;            directionalLight.shadows = LightShadows.Soft;&#10;            &#10;            // Set ambient lighting&#10;            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Trilight;&#10;            RenderSettings.ambientSkyColor = Color.white;&#10;            RenderSettings.ambientEquatorColor = Color.gray;&#10;            RenderSettings.ambientGroundColor = new Color(0.2f, 0.2f, 0.2f);&#10;            &#10;            Debug.Log(&quot;[Scene Setup] Lighting configured&quot;);&#10;        }&#10;&#10;        private void SetupTestManager()&#10;        {&#10;            var testManager = FindObjectOfType&lt;BossTestManager&gt;();&#10;            if (testManager == null)&#10;            {&#10;                var testManagerObj = new GameObject(&quot;BossTestManager&quot;);&#10;                testManager = testManagerObj.AddComponent&lt;BossTestManager&gt;();&#10;                &#10;                // Create and assign test boss config&#10;                var testConfigCreator = testManagerObj.AddComponent&lt;TestBossConfig&gt;();&#10;                var testConfig = testConfigCreator.CreateTestConfig();&#10;                &#10;                // Use reflection to set the test config&#10;                var configField = typeof(BossTestManager).GetField(&quot;testBossConfig&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                configField?.SetValue(testManager, testConfig);&#10;                &#10;                Debug.Log(&quot;[Scene Setup] Test Manager created with config&quot;);&#10;            }&#10;        }&#10;&#10;        private void SetupUICanvas()&#10;        {&#10;            var canvas = FindObjectOfType&lt;Canvas&gt;();&#10;            if (canvas == null)&#10;            {&#10;                var canvasObj = new GameObject(&quot;TestUI Canvas&quot;);&#10;                canvas = canvasObj.AddComponent&lt;Canvas&gt;();&#10;                canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;                canvas.sortingOrder = 100;&#10;                &#10;                canvasObj.AddComponent&lt;UnityEngine.UI.CanvasScaler&gt;();&#10;                canvasObj.AddComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;                &#10;                Debug.Log(&quot;[Scene Setup] UI Canvas created&quot;);&#10;            }&#10;        }&#10;&#10;        #if UNITY_EDITOR&#10;        [MenuItem(&quot;Boss Test/Setup Test Scene&quot;)]&#10;        public static void SetupTestSceneFromMenu()&#10;        {&#10;            var setup = FindObjectOfType&lt;BossTestSceneSetup&gt;();&#10;            if (setup == null)&#10;            {&#10;                var setupObj = new GameObject(&quot;BossTestSceneSetup&quot;);&#10;                setup = setupObj.AddComponent&lt;BossTestSceneSetup&gt;();&#10;            }&#10;            &#10;            setup.SetupTestScene();&#10;        }&#10;&#10;        [MenuItem(&quot;Boss Test/Create Test Config Asset&quot;)]&#10;        public static void CreateTestConfigAsset()&#10;        {&#10;            var testConfig = ScriptableObject.CreateInstance&lt;TestBossConfig&gt;();&#10;            var config = testConfig.CreateTestConfig();&#10;            &#10;            AssetDatabase.CreateAsset(config, &quot;Assets/Code/Boss/Testing/TestBossConfig.asset&quot;);&#10;            AssetDatabase.SaveAssets();&#10;            &#10;            EditorUtility.FocusProjectWindow();&#10;            Selection.activeObject = config;&#10;            &#10;            Debug.Log(&quot;Test Boss Config asset created!&quot;);&#10;        }&#10;        #endif&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (GUILayout.Button(&quot;Setup Test Scene&quot;, GUILayout.Width(150)))&#10;            {&#10;                SetupTestScene();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/PlayerTestController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/PlayerTestController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Test controller để giả lập player movement và tương tác với Boss&#10;    /// &lt;/summary&gt;&#10;    public class PlayerTestController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float rotationSpeed = 10f;&#10;        &#10;        [Header(&quot;Attack Settings&quot;)]&#10;        [SerializeField] private float attackRange = 3f;&#10;        [SerializeField] private float attackCooldown = 1f;&#10;        &#10;        [Header(&quot;UI Testing&quot;)]&#10;        [SerializeField] private bool showDebugUI = true;&#10;        &#10;        private CharacterController characterController;&#10;        private float lastAttackTime;&#10;        private BossManager bossManager;&#10;        private Vector3 moveDirection;&#10;        private Vector3 velocity; // Thêm velocity riêng cho gravity&#10;        &#10;        // Input tracking&#10;        private bool isMoving;&#10;        private Vector3 inputDirection;&#10;&#10;        private void Start()&#10;        {&#10;            InitializeComponents();&#10;            bossManager = BossManager.Instance;&#10;        }&#10;&#10;        private void InitializeComponents()&#10;        {&#10;            characterController = GetComponent&lt;CharacterController&gt;();&#10;            if (characterController == null)&#10;            {&#10;                characterController = gameObject.AddComponent&lt;CharacterController&gt;();&#10;                characterController.radius = 0.5f;&#10;                characterController.height = 2f;&#10;                characterController.center = new Vector3(0, 1, 0);&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            HandleMovementInput();&#10;            HandleAttackInput();&#10;            HandleFaSkillInput();&#10;            &#10;            MovePlayer();&#10;        }&#10;&#10;        private void HandleMovementInput()&#10;        {&#10;            // WASD movement&#10;            float horizontal = Input.GetAxis(&quot;Horizontal&quot;);&#10;            float vertical = Input.GetAxis(&quot;Vertical&quot;);&#10;            &#10;            inputDirection = new Vector3(horizontal, 0, vertical).normalized;&#10;            isMoving = inputDirection.magnitude &gt; 0.1f;&#10;            &#10;            // Bỏ phần rotation tự động - chỉ di chuyển bình thường&#10;        }&#10;&#10;        private void HandleAttackInput()&#10;        {&#10;            // Space or Left Mouse Button to attack&#10;            if ((Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0)) &amp;&amp; CanAttack())&#10;            {&#10;                PerformAttack();&#10;            }&#10;        }&#10;&#10;        private void HandleFaSkillInput()&#10;        {&#10;            // Q - Radar Skill&#10;            if (Input.GetKeyDown(KeyCode.Q))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Requesting Fa Radar Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;Radar&quot;, true);&#10;            }&#10;            &#10;            // E - Second Skill (example)&#10;            if (Input.GetKeyDown(KeyCode.E))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Second Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;SecondSkill&quot;, true);&#10;            }&#10;            &#10;            // R - Reveal Skill &#10;            if (Input.GetKeyDown(KeyCode.R))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Reveal Skill&quot;);&#10;                // Gọi trực tiếp FaSkillSimulator thay vì thông qua integration&#10;                var faSimulator = FindObjectOfType&lt;FaSkillSimulator&gt;();&#10;                if (faSimulator != null)&#10;                {&#10;                    faSimulator.UseThirdSkill();&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;[Player Test] FaSkillSimulator not found in scene!&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void MovePlayer()&#10;        {&#10;            // Handle horizontal movement&#10;            Vector3 horizontalMove = Vector3.zero;&#10;            if (isMoving)&#10;            {&#10;                horizontalMove = inputDirection * moveSpeed;&#10;            }&#10;            &#10;            // Handle gravity properly for CharacterController&#10;            if (characterController != null)&#10;            {&#10;                if (characterController.isGrounded)&#10;                {&#10;                    velocity.y = -2f; // Small downward force to keep grounded&#10;                }&#10;                else&#10;                {&#10;                    velocity.y -= 9.81f * Time.deltaTime; // Apply gravity when not grounded&#10;                }&#10;                &#10;                // Combine horizontal movement with vertical velocity&#10;                Vector3 finalMovement = horizontalMove + velocity;&#10;                characterController.Move(finalMovement * Time.deltaTime);&#10;            }&#10;            else&#10;            {&#10;                // Fallback for transform-based movement (without CharacterController)&#10;                transform.Translate(horizontalMove * Time.deltaTime, Space.World);&#10;            }&#10;        }&#10;&#10;        private bool CanAttack()&#10;        {&#10;            return Time.time &gt;= lastAttackTime + attackCooldown;&#10;        }&#10;&#10;        private void PerformAttack()&#10;        {&#10;            lastAttackTime = Time.time;&#10;            Debug.Log(&quot;[Player Test] Player attacking!&quot;);&#10;            &#10;            // Check if there's a boss or decoy in range&#10;            Collider[] hits = Physics.OverlapSphere(transform.position, attackRange);&#10;            &#10;            foreach (var hit in hits)&#10;            {&#10;                // Check for Boss&#10;                var boss = hit.GetComponent&lt;BossController&gt;();&#10;                if (boss != null)&#10;                {&#10;                    Debug.Log(&quot;[Player Test] Hit Boss directly!&quot;);&#10;                    if (bossManager != null)&#10;                    {&#10;                        bossManager.PlayerAttackBoss();&#10;                    }&#10;                    return;&#10;                }&#10;                &#10;                // Check for Decoy&#10;                var decoy = hit.GetComponent&lt;DecoyBehavior&gt;();&#10;                if (decoy != null)&#10;                {&#10;                    Debug.Log($&quot;[Player Test] Hit {(decoy.IsReal ? &quot;Real&quot; : &quot;Fake&quot;)} Decoy!&quot;);&#10;                    &#10;                    // Gọi trực tiếp OnAttacked() thay vì thông qua BossManager&#10;                    decoy.OnAttacked();&#10;                    return;&#10;                }&#10;            }&#10;            &#10;            Debug.Log(&quot;[Player Test] Attack missed - no target in range&quot;);&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (!showDebugUI) return;&#10;            &#10;            GUILayout.BeginArea(new Rect(10, 10, 300, 200));&#10;            GUILayout.Label(&quot;=== PLAYER TEST CONTROLS ===&quot;);&#10;            GUILayout.Label(&quot;WASD: Move&quot;);&#10;            GUILayout.Label(&quot;Space/LMB: Attack&quot;);&#10;            GUILayout.Label(&quot;Q: Fa Radar Skill&quot;);&#10;            GUILayout.Label(&quot;E: Fa Second Skill&quot;);&#10;            GUILayout.Label(&quot;R: Fa Third Skill&quot;);&#10;            GUILayout.Space(10);&#10;            GUILayout.Label($&quot;Position: {transform.position}&quot;);&#10;            GUILayout.Label($&quot;Moving: {isMoving}&quot;);&#10;            GUILayout.Label($&quot;Can Attack: {CanAttack()}&quot;);&#10;            GUILayout.EndArea();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            // Draw attack range&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, attackRange);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Test controller để giả lập player movement và tương tác với Boss&#10;    /// &lt;/summary&gt;&#10;    public class PlayerTestController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Attack Settings&quot;)]&#10;        [SerializeField] private float attackRange = 3f;&#10;        [SerializeField] private float attackCooldown = 1f;&#10;        &#10;        [Header(&quot;UI Testing&quot;)]&#10;        [SerializeField] private bool showDebugUI = true;&#10;        &#10;        private float lastAttackTime;&#10;        private BossManager bossManager;&#10;&#10;        private void Start()&#10;        {&#10;            bossManager = BossManager.Instance;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            HandleAttackInput();&#10;            HandleFaSkillInput();&#10;        }&#10;&#10;        private void HandleAttackInput()&#10;        {&#10;            // Space or Left Mouse Button to attack&#10;            if ((Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0)) &amp;&amp; CanAttack())&#10;            {&#10;                PerformAttack();&#10;            }&#10;        }&#10;&#10;        private void HandleFaSkillInput()&#10;        {&#10;            // Q - Radar Skill&#10;            if (Input.GetKeyDown(KeyCode.Q))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Requesting Fa Radar Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;Radar&quot;, true);&#10;            }&#10;            &#10;            // E - Second Skill (example)&#10;            if (Input.GetKeyDown(KeyCode.E))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Second Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;SecondSkill&quot;, true);&#10;            }&#10;            &#10;            // R - Reveal Skill &#10;            if (Input.GetKeyDown(KeyCode.R))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Reveal Skill&quot;);&#10;                // Gọi trực tiếp FaSkillSimulator thay vì thông qua integration&#10;                var faSimulator = FindObjectOfType&lt;FaSkillSimulator&gt;();&#10;                if (faSimulator != null)&#10;                {&#10;                    faSimulator.UseThirdSkill();&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;[Player Test] FaSkillSimulator not found in scene!&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        private bool CanAttack()&#10;        {&#10;            return Time.time &gt;= lastAttackTime + attackCooldown;&#10;        }&#10;&#10;        private void PerformAttack()&#10;        {&#10;            lastAttackTime = Time.time;&#10;            Debug.Log(&quot;[Player Test] Player attacking!&quot;);&#10;            &#10;            // Check if there's a boss or decoy in range&#10;            Collider[] hits = Physics.OverlapSphere(transform.position, attackRange);&#10;            &#10;            foreach (var hit in hits)&#10;            {&#10;                // Check for Boss&#10;                var boss = hit.GetComponent&lt;BossController&gt;();&#10;                if (boss != null)&#10;                {&#10;                    Debug.Log(&quot;[Player Test] Hit Boss directly!&quot;);&#10;                    if (bossManager != null)&#10;                    {&#10;                        bossManager.PlayerAttackBoss();&#10;                    }&#10;                    return;&#10;                }&#10;                &#10;                // Check for Decoy&#10;                var decoy = hit.GetComponent&lt;DecoyBehavior&gt;();&#10;                if (decoy != null)&#10;                {&#10;                    Debug.Log($&quot;[Player Test] Hit {(decoy.IsReal ? &quot;Real&quot; : &quot;Fake&quot;)} Decoy!&quot;);&#10;                    &#10;                    // Gọi trực tiếp OnAttacked() thay vì thông qua BossManager&#10;                    decoy.OnAttacked();&#10;                    return;&#10;                }&#10;            }&#10;            &#10;            Debug.Log(&quot;[Player Test] Attack missed - no target in range&quot;);&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (!showDebugUI) return;&#10;            &#10;            GUILayout.BeginArea(new Rect(10, 10, 300, 200));&#10;            GUILayout.Label(&quot;=== PLAYER TEST CONTROLS ===&quot;);&#10;            GUILayout.Label(&quot;WASD: Move&quot;);&#10;            GUILayout.Label(&quot;Space/LMB: Attack&quot;);&#10;            GUILayout.Label(&quot;Q: Fa Radar Skill&quot;);&#10;            GUILayout.Label(&quot;E: Fa Second Skill&quot;);&#10;            GUILayout.Label(&quot;R: Fa Third Skill&quot;);&#10;            GUILayout.Space(10);&#10;            GUILayout.Label($&quot;Position: {transform.position}&quot;);&#10;            GUILayout.Label($&quot;Can Attack: {CanAttack()}&quot;);&#10;            GUILayout.EndArea();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            // Draw attack range&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, attackRange);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/README.md" />
              <option name="updatedContent" value="# Boss FSM Testing System&#10;&#10;##  Tổng quan&#10;Hệ thống test hoàn chỉnh để kiểm tra Boss FSM, bao gồm:&#10;- Player movement và attack simulation&#10;- 3 kỹ năng Fa (Radar, Protection, Reveal)&#10;- Boss state transitions và behaviors&#10;- UI testing và debug tools&#10;&#10;##  Cấu trúc Files&#10;&#10;### Core Testing Files:&#10;- **PlayerTestController.cs** - Điều khiển player test với WASD, attack, và Fa skills&#10;- **FaSkillSimulator.cs** - Giả lập 3 kỹ năng của Fa với cooldowns và effects&#10;- **BossTestManager.cs** - Manager chính setup toàn bộ test environment&#10;- **TestBossConfig.cs** - Tạo config tối ưu cho testing (thời gian ngắn)&#10;- **BossTestSceneSetup.cs** - Auto setup test scene với camera, lighting, UI&#10;&#10;##  Controls&#10;&#10;### Player Controls:&#10;- **WASD** - Di chuyển player&#10;- **Space/Left Mouse** - Tấn công&#10;- **Q** - Fa Radar Skill (phá hủy souls)&#10;- **E** - Fa Protection Skill (shield 5 giây)&#10;- **R** - Fa Reveal Skill (hiện bóng thật)&#10;&#10;### Debug Controls:&#10;- **F1** - Reset toàn bộ test&#10;- **F2** - Force chuyển phase&#10;- **F3** - Spawn test soul&#10;- **F4** - Damage boss trực tiếp&#10;- **F5** - Heal player&#10;&#10;##  Cách Setup Test&#10;&#10;### Phương pháp 1: Tự động (Khuyến nghị)&#10;1. Tạo empty scene mới&#10;2. Add component `BossTestSceneSetup` vào bất kỳ GameObject nào&#10;3. Click button &quot;Setup Test Scene&quot; trong inspector hoặc OnGUI&#10;4. Hoặc sử dụng menu: `Boss Test &gt; Setup Test Scene`&#10;&#10;### Phương pháp 2: Manual&#10;1. Tạo empty GameObject → Add `BossTestManager`&#10;2. Tạo test config: `Boss Test &gt; Create Test Config Asset`&#10;3. Assign config vào BossTestManager&#10;4. Run scene&#10;&#10;##  Test Features&#10;&#10;### Fa Skills Integration:&#10;```csharp&#10;// Kỹ năng 1: Radar - Phá hủy tất cả souls&#10;FaBossIntegration.NotifyFaSkillUsed(&quot;Radar&quot;, true);&#10;&#10;// Kỹ năng 2: Protection - Shield 5 giây&#10;FaBossIntegration.NotifyFaSkillUsed(&quot;Protection&quot;, true);&#10;&#10;// Kỹ năng 3: Reveal - Hiện bóng thật&#10;FaBossIntegration.NotifyFaSkillUsed(&quot;Reveal&quot;, true);&#10;```&#10;&#10;### Boss Event Integration:&#10;- Tự động suggest Radar khi có ≥2 souls&#10;- Thông báo khi boss vulnerable (DecoyState, ScreamState)&#10;- Real-time soul count tracking&#10;- Phase change notifications&#10;&#10;### Debug UI:&#10;- **Player Panel** - Position, movement, attack status&#10;- **Fa Skills Panel** - Cooldowns, skill status, boss info&#10;- **Test Manager Panel** - Quick actions, test statistics&#10;&#10;##  Test Scenarios&#10;&#10;### Phase 1 Testing:&#10;1. Boss starts in IdleState&#10;2. Transitions: Idle → Lure → Mock → Decoy&#10;3. **DecoyState**: Attack real decoy = boss damage, attack fake = player damage + SoulState&#10;4. **SoulState**: Boss teleports + spawns soul, suggests Fa Radar skill&#10;&#10;### Phase 2 Testing:&#10;1. Boss enters AngryState (circles around center)&#10;2. Random transitions: Angry → FearZone/Scream&#10;3. **FearZoneState**: Stay in dark zone 3s = vision blur + heartbeat&#10;4. **ScreamState**: Attack during scream = boss damage, miss = player damage + SoulState&#10;5. **CookState**: Boss defeated → memory fragment drop&#10;&#10;### Fa Skills Testing:&#10;- **Radar Skill**: Press Q to destroy all souls&#10;- **Protection Skill**: Press E for 5-second shield&#10;- **Reveal Skill**: Press R to highlight real decoy&#10;- Cooldown system prevents spam&#10;- Visual effects for each skill&#10;&#10;##  Test Statistics&#10;- Test duration tracking&#10;- Boss state monitoring&#10;- Health tracking (boss + player)&#10;- Soul count monitoring&#10;- Skill usage statistics&#10;&#10;##  Debug Features&#10;&#10;### Console Logs:&#10;```&#10;[Boss State] Entered IdleState - Boss đứng yên tại chỗ&#10;[Boss Animation] Playing animation: Idle&#10;[Player Test] Player attacking!&#10;[Fa Simulator] === RADAR SKILL ACTIVATED ===&#10;[Test] Boss took 1 damage&#10;```&#10;&#10;### Visual Debug:&#10;- Attack range visualization (red sphere)&#10;- Boss spawn radiuses (yellow/purple/red circles)&#10;- Skill effects (radar waves, shields, highlights)&#10;- Real-time UI status displays&#10;&#10;## ⚡ Performance Settings&#10;&#10;### Fast Testing Config:&#10;- Phase durations: 1-2 seconds (vs normal 3-5s)&#10;- Cast times: 0.8-1.5s (vs normal 2-3s)&#10;- Movement speeds: 1.5x faster&#10;- Favors DecoyState for quick testing&#10;&#10;### Production Ready:&#10;- Simply swap TestBossConfig với BossConfig thật&#10;- Uncomment animation code trong BossController&#10;- Add real audio clips và visual effects&#10;&#10;##  Troubleshooting&#10;&#10;### Common Issues:&#10;1. **No Boss spawned**: Check BossTestManager has testBossConfig assigned&#10;2. **Player can't move**: Ensure CharacterController is added&#10;3. **Skills not working**: Check FaSkillSimulator is in scene&#10;4. **No UI**: Verify Canvas is created in scene&#10;&#10;### Debug Commands:&#10;```csharp&#10;// Force specific state&#10;bossController.ChangeState(new DecoyState());&#10;&#10;// Manual skill trigger&#10;faSimulator.UseRadarSkill();&#10;&#10;// Check integration&#10;Debug.Log($&quot;Souls: {FaBossIntegration.GetCurrentSoulCount()}&quot;);&#10;Debug.Log($&quot;Phase: {FaBossIntegration.GetCurrentBossPhase()}&quot;);&#10;```&#10;&#10;##  Test Complete!&#10;Hệ thống test này cho phép bạn:&#10;- ✅ Test toàn bộ Boss FSM logic&#10;- ✅ Verify Fa skills integration&#10;- ✅ Debug state transitions&#10;- ✅ Performance testing&#10;- ✅ UI/UX validation&#10;- ✅ Dễ dàng chuyển sang production&#10;&#10;Happy Testing! " />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/TestBossConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/TestBossConfig.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Test configuration cho Boss system - tạo config tối ưu cho testing&#10;    /// &lt;/summary&gt;&#10;    [CreateAssetMenu(fileName = &quot;TestBossConfig&quot;, menuName = &quot;Boss/Test Boss Configuration&quot;)]&#10;    public class TestBossConfig : ScriptableObject&#10;    {&#10;        [Header(&quot;Create Test Config&quot;)]&#10;        [SerializeField] private bool autoCreateConfig = true;&#10;        &#10;        public BossConfig CreateTestConfig()&#10;        {&#10;            var config = ScriptableObject.CreateInstance&lt;BossConfig&gt;();&#10;            &#10;            // General settings - faster for testing&#10;            config.maxHealthPerPhase = 3;&#10;            config.moveSpeed = 8f;&#10;            config.rotationSpeed = 180f;&#10;            &#10;            // Phase 1 - shorter durations for quick testing&#10;            config.phase1 = new Phase1Config&#10;            {&#10;                idleDuration = 1f,&#10;                lureDuration = 2f,&#10;                mockDuration = 1.5f,&#10;                decoyCastTime = 1f,&#10;                decoyDuration = 5f,&#10;                soulStateCastTime = 0.8f,&#10;                &#10;                lureDistance = 3f,&#10;                lureApproachSpeed = 6f,&#10;                lureRetreatSpeed = 8f,&#10;                &#10;                decoyMoveSpeed = 3f,&#10;                decoyCount = 2,&#10;                decoySpawnRadius = 5f,&#10;                &#10;                enableRandomStates = true,&#10;                stateWeights = new float[] { 1f, 1f, 1f, 2f } // Favor Decoy for testing&#10;            };&#10;            &#10;            // Phase 2 - shorter durations for quick testing&#10;            config.phase2 = new Phase2Config&#10;            {&#10;                angryMoveDuration = 2f,&#10;                fearZoneCastTime = 1f,&#10;                fearZoneDuration = 4f,&#10;                fearZoneActivationTime = 1.5f,&#10;                screamCastTime = 1.5f,&#10;                screamDuration = 3f,&#10;                cookStateDuration = 2f,&#10;                &#10;                angryMoveSpeed = 4f,&#10;                circleRadius = 6f,&#10;                &#10;                fearZoneRadius = 2.5f,&#10;                visionBlurIntensity = 0.5f,&#10;                &#10;                screenShakeIntensity = 0.8f,&#10;                visionShrinkAmount = 0.4f&#10;            };&#10;            &#10;            // Soul settings&#10;            config.soulConfig = new SoulConfig&#10;            {&#10;                maxSouls = 2,&#10;                soulMoveSpeed = 5f,&#10;                soulSpawnRadius = 8f,&#10;                soulFollowDistance = 1.5f,&#10;                soulPrefab = null // Will be created dynamically in test&#10;            };&#10;            &#10;            // UI settings&#10;            config.uiConfig = new UIConfig&#10;            {&#10;                bossHealthPosition = new Vector2(0f, 0.85f),&#10;                playerHealthPosition = new Vector2(0f, -0.85f),&#10;                healthBarSize = new Vector2(200f, 20f),&#10;                skillCastBarOffset = new Vector2(0f, -30f),&#10;                skillCastBarSize = new Vector2(150f, 15f),&#10;                bossHealthColor = Color.red,&#10;                playerHealthColor = Color.green,&#10;                skillCastColor = Color.yellow&#10;            };&#10;            &#10;            // Audio settings (all null for testing)&#10;            config.audioConfig = new AudioConfig&#10;            {&#10;                mockLaughSound = null,&#10;                decoySpawnSound = null,&#10;                soulSpawnSound = null,&#10;                screamSound = null,&#10;                fearZoneSound = null,&#10;                heartbeatSound = null,&#10;                phaseChangeSound = null,&#10;                damageSound = null,&#10;                defeatSound = null,&#10;                masterVolume = 0.5f,&#10;                sfxVolume = 0.7f,&#10;                ambientVolume = 0.3f&#10;            };&#10;            &#10;            return config;&#10;        }&#10;        &#10;        private void OnValidate()&#10;        {&#10;            if (autoCreateConfig)&#10;            {&#10;                // Auto-create config when this ScriptableObject is created&#10;                // This will be called when the asset is created in Unity&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/UI/BossUIManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/UI/BossUIManager.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Tu_Develop/Import/Scripts/FaAgent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Tu_Develop/Import/Scripts/FaAgent.cs" />
              <option name="originalContent" value="#nullable enable&#10;using System.Collections.Generic;&#10;using FMODUnity;&#10;using TMPro;&#10;using Tu_Develop.Import.Scripts.EventConfig;&#10;using Unity.Behavior;&#10;using UnityEngine;&#10;&#10;namespace Tu_Develop.Import.Scripts&#10;{&#10;    public class FaAgent : MonoBehaviour, FaInterface&#10;    {&#10;        [Header(&quot;Event Channels&quot;)] [SerializeField]&#10;        private OnFaAgentUseSkill? useSkillEventChannel;&#10;        [SerializeField] private FaAgentEventChannel? onReadyEventChannel;&#10;        &#10;        [Header(&quot;FMOD Sound Events&quot;)]&#10;        [SerializeField] private EventReference guideSignalSfx;&#10;        [SerializeField] private EventReference knowledgeLightSfx;&#10;        [SerializeField] private EventReference protectiveAuraSfx;&#10;        &#10;        // Ambient sound&#10;        [SerializeField] private EventReference ambientSound;&#10;        &#10;&#10;        [Header(&quot;Canvas&quot;)] [SerializeField] private TextMeshProUGUI? skill1Cooldown;&#10;        [SerializeField] private TextMeshProUGUI? skill2Cooldown;&#10;        [SerializeField] private TextMeshProUGUI? skill3Cooldown;&#10;        &#10;        // Giả lập máu&#10;        [SerializeField] private int playerHealth = 3;&#10;        &#10;&#10;        private readonly Dictionary&lt;string, float&gt; _cooldownTimers = new Dictionary&lt;string, float&gt;();&#10;&#10;        // Bổ sung TaskQueue quản lý task cho Fa&#10;        private readonly TaskQueue _taskQueue = new TaskQueue();&#10;        // Hàm thêm task vào queue&#10;&#10;        private void OnEnable()&#10;        {&#10;            if (useSkillEventChannel != null)&#10;            {&#10;                useSkillEventChannel.Event += OnSkillUsed;&#10;            }&#10;        }&#10;        private void OnDisable()&#10;        {&#10;            if (useSkillEventChannel != null)&#10;            {&#10;                useSkillEventChannel.Event -= OnSkillUsed;&#10;            }&#10;        }&#10;        private void AddTask(FaTask task)&#10;        {&#10;            _taskQueue.AddTask(task);&#10;        }&#10;        // Hàm lấy task tiếp theo&#10;        private FaTask? GetNextTask()&#10;        {&#10;            return _taskQueue.GetNextTask();&#10;        }&#10;        // Kiểm tra còn task không&#10;        private bool HasTask()&#10;        {&#10;            return _taskQueue.HasTask();&#10;        }&#10;        public bool IsSkillAvailable(string skillName)&#10;        {&#10;            return !_cooldownTimers.ContainsKey(skillName) || _cooldownTimers[skillName] &lt;= 0;&#10;        }&#10;    &#10;        // Hàm này sẽ được gọi từ Behavior Graph để bắt đầu đếm ngược&#10;        private void StartSkillCooldown(string skillName, float duration)&#10;        {&#10;            _cooldownTimers[skillName] = duration;&#10;            Debug.Log($&quot;[FaAgent] Skill '{skillName}' bắt đầu cooldown {duration} giây.&quot;);&#10;        }&#10;&#10;        public void OnPlayerCommand(string command)&#10;        {&#10;            Debug.Log($&quot;Fa nhận lệnh: {command}&quot;);&#10;            var parts = command.Trim().Split(' ');&#10;            if (parts.Length == 0) return;&#10;            // MOVE&#10;            if (parts[0].ToLower() == &quot;move&quot; &amp;&amp; parts.Length == 4)&#10;            {&#10;                // Lệnh: move x y z&#10;                if (float.TryParse(parts[1], out float x) &amp;&amp; float.TryParse(parts[2], out float y) &amp;&amp; float.TryParse(parts[3], out float z))&#10;                {&#10;                        var targetPos = new Vector3(x, y, z);&#10;                        var task = new FaTask(TaskType.MoveTo)&#10;                        {&#10;                            TaskPosition = targetPos&#10;                        };&#10;                        AddTask(task);&#10;                }&#10;            }&#10;            // SKILL&#10;            else if (parts[0].ToLower() == &quot;useskill&quot; &amp;&amp; parts.Length &gt;= 2)&#10;            {&#10;                var skillName = parts[1]; // Skill name/number&#10;            &#10;                // Check cooldown&#10;                if (!IsSkillAvailable(skillName))&#10;                {&#10;                    Debug.Log($&quot;[FaAgent] Skill '{skillName}' đang hồi được {_cooldownTimers[skillName]}.&quot;);&#10;                    return;&#10;                }&#10;&#10;                var task = new FaTask(TaskType.UseSkill)&#10;                {&#10;                    SkillName = skillName&#10;                };&#10;&#10;                if (parts.Length &gt; 2)&#10;                {&#10;                    // Trường hợp có mục tiêu rõ ràng (vd: &quot;player&quot;)&#10;                    var targetKeyword = parts[2].ToLower();&#10;                    task.TargetObject = (targetKeyword != &quot;player&quot;); // false nếu là player, true nếu khác&#10;                    Debug.Log($&quot;Đã thêm task UseSkill: {task.SkillName} trên mục tiêu self: {task.TargetObject}&quot;);&#10;                }&#10;                else&#10;                {&#10;                    // Trường hợp không có mục tiêu -&gt; Mặc định là &quot;self&quot;&#10;                    task.TargetObject = true;&#10;                    Debug.Log($&quot;Đã thêm task UseSkill: {task.SkillName} trên mục tiêu self: {task.TargetObject}&quot;);&#10;                }&#10;            &#10;                            &#10;                AddTask(task);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;Lệnh không hợp lệ.&quot;);&#10;            }&#10;        }&#10;&#10;        #region Audio Tasks&#10;&#10;        /// &lt;summary&gt;&#10;        /// Hàm này được gọi bởi EventChannel khi Cây Hành vi dùng node &quot;Send Event Message&quot;.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;param name=&quot;skillName&quot;&gt;Đây là chuỗi string (tên skill) được gửi từ Cây Hành vi.&lt;/param&gt;&#10;        private void OnSkillUsed(string skillName)&#10;        {&#10;            Debug.Log($&quot;[SỰ KIỆN LẮNG NGHE] Fa vừa sử dụng kỹ năng: {skillName}.&quot;);&#10;            &#10;            switch (skillName)&#10;            {&#10;                case &quot;GuideSignal&quot;:&#10;                    AudioManager.Instance?.PlayOneShot(guideSignalSfx, transform.position);&#10;                    break;&#10;                case &quot;KnowledgeLight&quot;:&#10;                    AudioManager.Instance?.PlayOneShot(knowledgeLightSfx, transform.position);&#10;                    break;&#10;                // ...&#10;            }&#10;        }&#10;&#10;        #endregion&#10;        &#10;        &#10;        public BehaviorGraphAgent? faBha;&#10;&#10;        private void Start()&#10;        {&#10;            faBha = GetComponent&lt;BehaviorGraphAgent&gt;();&#10;&#10;            if (faBha)&#10;            {&#10;                // Kiểm tra BlackboardReference đã được gán chưa&#10;                if (faBha.BlackboardReference == null)&#10;                {&#10;                    Debug.LogError(&quot;BehaviorGraphAgent không có BlackboardReference!&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Gán giá trị mặc định cho các biến trên Blackboard&#10;                var player = GameObject.Find(&quot;Player&quot;);&#10;                if (player != null)&#10;                {&#10;                    faBha.BlackboardReference.SetVariableValue(&quot;Player&quot;, player);&#10;                }&#10;                &#10;&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;Không tìm thấy BehaviorGraphAgent trên đối tượng này!&quot;);&#10;            }&#10;            &#10;            if (onReadyEventChannel != null)&#10;            {&#10;                onReadyEventChannel.RaiseEvent(this);&#10;                Debug.Log(&quot;[FaAgent] Đã sẵn sàng và phát tín hiệu.&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;Chưa gán Event Channel cho FaAgent!&quot;);&#10;            }&#10;        }&#10;&#10;        void Update()&#10;        {&#10;            // Giảm cooldown mỗi frame&#10;            var keys = new List&lt;string&gt;(_cooldownTimers.Keys);&#10;            foreach (string key in keys)&#10;            {&#10;                _cooldownTimers[key] = Mathf.Max(0, _cooldownTimers[key] - Time.deltaTime);&#10;            }&#10;&#10;            UpdateCooldownToCanvas();&#10;        &#10;            if (faBha == null) return;&#10;            &#10;            &#10;            // 2. Đồng bộ hóa trạng thái cooldown LÊN Blackboard&#10;            // Tên skill trong C# phải khớp với tên trong hàm IsSkillAvailable&#10;            // Tên biến trên Blackboard phải khớp với những gì bạn đã tạo&#10;            faBha.BlackboardReference.SetVariableValue(&quot;IsProtectiveAuraAvailable&quot;, IsSkillAvailable(&quot;ProtectiveAura&quot;));&#10;            faBha.BlackboardReference.SetVariableValue(&quot;IsGuideSignalAvailable&quot;, IsSkillAvailable(&quot;GuideSignal&quot;));&#10;            faBha.BlackboardReference.SetVariableValue(&quot;IsKnowledgeLightAvailable&quot;, IsSkillAvailable(&quot;KnowledgeLight&quot;));&#10;        &#10;            // Chỉ xử lý task mới khi Graph rảnh và hàng đợi có task&#10;            if (HasTask())&#10;            {&#10;                var task = GetNextTask();&#10;                if (task != null)&#10;                {&#10;                    var playerTaskType = PlayerTaskType.None;&#10;&#10;                    if (task.Type == TaskType.MoveTo)&#10;                    {&#10;                        playerTaskType = PlayerTaskType.Move;&#10;                    }&#10;                    else if (task.Type == TaskType.UseSkill)&#10;                    {&#10;                        // Dựa vào SkillName (hiện là &quot;1&quot;, &quot;2&quot;, &quot;3&quot; từ input) để chọn đúng enum&#10;                        switch (task.SkillName)&#10;                        {&#10;                            case &quot;GuideSignal&quot;:&#10;                                playerTaskType = PlayerTaskType.GuideSignal;&#10;                                UseGuideSignal();&#10;                                break;&#10;                            case &quot;KnowledgeLight&quot;:&#10;                                playerTaskType = PlayerTaskType.KnowledgeLight;&#10;                                UseKnowledgeLight();&#10;                                break;&#10;                            case &quot;ProtectiveAura&quot;:&#10;                                playerTaskType = PlayerTaskType.ProtectiveAura;&#10;                                UseProtectiveAura();&#10;                                break;&#10;                            default:&#10;                                Debug.LogWarning($&quot;Skill name '{task.SkillName}' không hợp lệ!&quot;);&#10;                                playerTaskType = PlayerTaskType.None;&#10;                                break;&#10;                        }&#10;                    }&#10;&#10;                    // Nếu không có task nào hợp lệ thì không làm gì cả&#10;                    if (playerTaskType == PlayerTaskType.None) return;&#10;&#10;                    // Đẩy dữ liệu vào Blackboard&#10;                    if (task.TaskPosition != null)&#10;                        faBha.BlackboardReference.SetVariableValue(&quot;TaskPosition&quot;, task.TaskPosition);&#10;                    faBha.BlackboardReference.SetVariableValue(&quot;TaskFromPlayer&quot;, playerTaskType);&#10;                    if (task.TargetObject != null)&#10;                        faBha.BlackboardReference.SetVariableValue(&quot;Self_ActiveProtectiveAura&quot;, task.TargetObject);&#10;                    // Bật chế độ PlayerControl để Graph nhận task&#10;                    //ActivePlayerControl(true);&#10;                }&#10;            }&#10;        }&#10;&#10;    &#10;        private void UpdateCooldownToCanvas()&#10;        {&#10;            float cooldownValue; // Biến tạm để lưu giá trị cooldown&#10;&#10;            if (skill1Cooldown != null)&#10;            {&#10;                // Thử lấy giá trị, nếu không có thì cooldownValue sẽ là 0&#10;                _cooldownTimers.TryGetValue(&quot;GuideSignal&quot;, out cooldownValue);&#10;                skill1Cooldown.text = cooldownValue &gt; 0 ? Mathf.CeilToInt(cooldownValue).ToString() : &quot;Ready&quot;;&#10;            }&#10;&#10;            if (skill2Cooldown != null)&#10;            {&#10;                _cooldownTimers.TryGetValue(&quot;KnowledgeLight&quot;, out cooldownValue);&#10;                skill2Cooldown.text = cooldownValue &gt; 0 ? Mathf.CeilToInt(cooldownValue).ToString() : &quot;Ready&quot;;&#10;            }&#10;    &#10;            if (skill3Cooldown != null)&#10;            {&#10;                _cooldownTimers.TryGetValue(&quot;ProtectiveAura&quot;, out cooldownValue);&#10;                skill3Cooldown.text = cooldownValue &gt; 0 ? Mathf.CeilToInt(cooldownValue).ToString() : &quot;Ready&quot;;&#10;            }&#10;        }&#10;&#10;        public bool ActivePlayerControl(bool v)&#10;        {&#10;            try&#10;            {&#10;                faBha?.BlackboardReference.SetVariableValue(&quot;PlayerControl&quot;, v);&#10;                return true;&#10;            }&#10;            catch (System.Exception ex)&#10;            {&#10;                Debug.LogError($&quot;Lỗi khi thay đổi chế độ chỉ huy NPC: {ex.Message}&quot;);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        public bool ReturnPlayerControlFromBlackBoard()&#10;        {&#10;            // Kiểm tra an toàn, phòng trường hợp BHA chưa được gán&#10;            if (faBha == null)&#10;            {&#10;                return false;&#10;            }&#10;&#10;            // Dùng GetVariableValue để đọc giá trị từ Blackboard&#10;            if (faBha.BlackboardReference.GetVariableValue(&quot;PlayerControl&quot;, out bool isControlled))&#10;            {&#10;                // Nếu tìm thấy biến, trả về giá trị của nó&#10;                return isControlled;&#10;            }&#10;&#10;            // Nếu không tìm thấy biến trên Blackboard, trả về false và báo lỗi&#10;            Debug.LogWarning(&quot;Không tìm thấy biến 'PlayerControl' trên Blackboard!&quot;);&#10;            return false;&#10;        }&#10;&#10;        #region  FaInterface&#10;        // Hàm này cần được sửa lại cho đúng tên và tham số như trong Interface&#10;        public void UseProtectiveAura() &#10;        {&#10;            if (!IsSkillAvailable(&quot;ProtectiveAura&quot;)) return;&#10;            StartSkillCooldown(&quot;ProtectiveAura&quot;, 20f);&#10;        }&#10;&#10;        public void UseGuideSignal()&#10;        {&#10;            if (!IsSkillAvailable(&quot;GuideSignal&quot;)) return;&#10;            Debug.Log(&quot;Thực thi kỹ năng TinHieuDanLoi (GuideSignal)!&quot;);&#10;            StartSkillCooldown(&quot;GuideSignal&quot;, 10f);&#10;        }&#10;&#10;        public void UseKnowledgeLight()&#10;        {&#10;            if (!IsSkillAvailable(&quot;KnowledgeLight&quot;)) return;&#10;            Debug.Log(&quot;Thực thi kỹ năng AnhSangTriThuc (KnowledgeLight)!&quot;);&#10;            StartSkillCooldown(&quot;KnowledgeLight&quot;, 15f);&#10;        }&#10;&#10;        #endregion&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#nullable enable&#13;&#10;using System.Collections.Generic;&#13;&#10;using FMODUnity;&#13;&#10;using TMPro;&#13;&#10;using Tu_Develop.Import.Scripts.EventConfig;&#13;&#10;using Unity.Behavior;&#13;&#10;using UnityEngine;&#13;&#10;&#13;&#10;namespace Tu_Develop.Import.Scripts&#13;&#10;{&#13;&#10;    public class FaAgent : MonoBehaviour, FaInterface&#13;&#10;    {&#13;&#10;        [Header(&quot;Event Channels&quot;)] [SerializeField]&#13;&#10;        private OnFaAgentUseSkill? useSkillEventChannel;&#13;&#10;        [SerializeField] private FaAgentEventChannel? onReadyEventChannel;&#13;&#10;        &#13;&#10;        [Header(&quot;FMOD Sound Events&quot;)]&#13;&#10;        [SerializeField] private EventReference guideSignalSfx;&#13;&#10;        [SerializeField] private EventReference knowledgeLightSfx;&#13;&#10;        [SerializeField] private EventReference protectiveAuraSfx;&#13;&#10;        &#13;&#10;        // Ambient sound&#13;&#10;        [SerializeField] private EventReference ambientSound;&#13;&#10;        &#13;&#10;&#13;&#10;        [Header(&quot;Canvas&quot;)] [SerializeField] private TextMeshProUGUI? skill1Cooldown;&#13;&#10;        [SerializeField] private TextMeshProUGUI? skill2Cooldown;&#13;&#10;        [SerializeField] private TextMeshProUGUI? skill3Cooldown;&#13;&#10;        &#13;&#10;        // Giả lập máu&#13;&#10;        [SerializeField] private int playerHealth = 3;&#13;&#10;        &#13;&#10;&#13;&#10;        private readonly Dictionary&lt;string, float&gt; _cooldownTimers = new Dictionary&lt;string, float&gt;();&#13;&#10;&#13;&#10;        // Bổ sung TaskQueue quản lý task cho Fa&#13;&#10;        private readonly TaskQueue _taskQueue = new TaskQueue();&#13;&#10;        // Hàm thêm task vào queue&#13;&#10;&#13;&#10;        private void OnEnable()&#13;&#10;        {&#13;&#10;            if (useSkillEventChannel != null)&#13;&#10;            {&#13;&#10;                useSkillEventChannel.Event += OnSkillUsed;&#13;&#10;            }&#13;&#10;        }&#13;&#10;        private void OnDisable()&#13;&#10;        {&#13;&#10;            if (useSkillEventChannel != null)&#13;&#10;            {&#13;&#10;                useSkillEventChannel.Event -= OnSkillUsed;&#13;&#10;            }&#13;&#10;        }&#13;&#10;        private void AddTask(FaTask task)&#13;&#10;        {&#13;&#10;            _taskQueue.AddTask(task);&#13;&#10;        }&#13;&#10;        // Hàm lấy task tiếp theo&#13;&#10;        private FaTask? GetNextTask()&#13;&#10;        {&#13;&#10;            return _taskQueue.GetNextTask();&#13;&#10;        }&#13;&#10;        // Kiểm tra còn task không&#13;&#10;        private bool HasTask()&#13;&#10;        {&#13;&#10;            return _taskQueue.HasTask();&#13;&#10;        }&#13;&#10;        public bool IsSkillAvailable(string skillName)&#13;&#10;        {&#13;&#10;            return !_cooldownTimers.ContainsKey(skillName) || _cooldownTimers[skillName] &lt;= 0;&#13;&#10;        }&#13;&#10;    &#13;&#10;        // Hàm này sẽ được gọi từ Behavior Graph để bắt đầu đếm ngược&#13;&#10;        private void StartSkillCooldown(string skillName, float duration)&#13;&#10;        {&#13;&#10;            _cooldownTimers[skillName] = duration;&#13;&#10;            Debug.Log($&quot;[FaAgent] Skill '{skillName}' bắt đầu cooldown {duration} giây.&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        public void OnPlayerCommand(string command)&#13;&#10;        {&#13;&#10;            Debug.Log($&quot;Fa nhận lệnh: {command}&quot;);&#13;&#10;            var parts = command.Trim().Split(' ');&#13;&#10;            if (parts.Length == 0) return;&#13;&#10;            // MOVE&#13;&#10;            if (parts[0].ToLower() == &quot;move&quot; &amp;&amp; parts.Length == 4)&#13;&#10;            {&#13;&#10;                // Lệnh: move x y z&#13;&#10;                if (float.TryParse(parts[1], out float x) &amp;&amp; float.TryParse(parts[2], out float y) &amp;&amp; float.TryParse(parts[3], out float z))&#13;&#10;                {&#13;&#10;                        var targetPos = new Vector3(x, y, z);&#13;&#10;                        var task = new FaTask(TaskType.MoveTo)&#13;&#10;                        {&#13;&#10;                            TaskPosition = targetPos&#13;&#10;                        };&#13;&#10;                        AddTask(task);&#13;&#10;                }&#13;&#10;            }&#13;&#10;            // SKILL&#13;&#10;            else if (parts[0].ToLower() == &quot;useskill&quot; &amp;&amp; parts.Length &gt;= 2)&#13;&#10;            {&#13;&#10;                var skillName = parts[1]; // Skill name/number&#13;&#10;            &#13;&#10;                // Check cooldown&#13;&#10;                if (!IsSkillAvailable(skillName))&#13;&#10;                {&#13;&#10;                    Debug.Log($&quot;[FaAgent] Skill '{skillName}' đang hồi được {_cooldownTimers[skillName]}.&quot;);&#13;&#10;                    return;&#13;&#10;                }&#13;&#10;&#13;&#10;                var task = new FaTask(TaskType.UseSkill)&#13;&#10;                {&#13;&#10;                    SkillName = skillName&#13;&#10;                };&#13;&#10;&#13;&#10;                if (parts.Length &gt; 2)&#13;&#10;                {&#13;&#10;                    // Trường hợp có mục tiêu rõ ràng (vd: &quot;player&quot;)&#13;&#10;                    var targetKeyword = parts[2].ToLower();&#13;&#10;                    task.TargetObject = (targetKeyword != &quot;player&quot;); // false nếu là player, true nếu khác&#13;&#10;                    Debug.Log($&quot;Đã thêm task UseSkill: {task.SkillName} trên mục tiêu self: {task.TargetObject}&quot;);&#13;&#10;                }&#13;&#10;                else&#13;&#10;                {&#13;&#10;                    // Trường hợp không có mục tiêu -&gt; Mặc định là &quot;self&quot;&#13;&#10;                    task.TargetObject = true;&#13;&#10;                    Debug.Log($&quot;Đã thêm task UseSkill: {task.SkillName} trên mục tiêu self: {task.TargetObject}&quot;);&#13;&#10;                }&#13;&#10;            &#13;&#10;                            &#13;&#10;                AddTask(task);&#13;&#10;            }&#13;&#10;            else&#13;&#10;            {&#13;&#10;                Debug.LogWarning(&quot;Lệnh không hợp lệ.&quot;);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        #region Audio Tasks&#13;&#10;&#13;&#10;        /// &lt;summary&gt;&#13;&#10;        /// Hàm này được gọi bởi EventChannel khi Cây Hành vi dùng node &quot;Send Event Message&quot;.&#13;&#10;        /// &lt;/summary&gt;&#13;&#10;        /// &lt;param name=&quot;skillName&quot;&gt;Đây là chuỗi string (tên skill) được gửi từ Cây Hành vi.&lt;/param&gt;&#13;&#10;        private void OnSkillUsed(string skillName)&#13;&#10;        {&#13;&#10;            Debug.Log($&quot;[SỰ KIỆN LẮNG NGHE] Fa vừa sử dụng kỹ năng: {skillName}.&quot;);&#13;&#10;            &#13;&#10;            switch (skillName)&#13;&#10;            {&#13;&#10;                case &quot;GuideSignal&quot;:&#13;&#10;                    AudioManager.Instance?.PlayOneShot(guideSignalSfx, transform.position);&#13;&#10;                    break;&#13;&#10;                case &quot;KnowledgeLight&quot;:&#13;&#10;                    AudioManager.Instance?.PlayOneShot(knowledgeLightSfx, transform.position);&#13;&#10;                    break;&#13;&#10;                // ...&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        #endregion&#13;&#10;        &#13;&#10;        &#13;&#10;        public BehaviorGraphAgent? faBha;&#13;&#10;&#13;&#10;        private void Start()&#13;&#10;        {&#13;&#10;            faBha = GetComponent&lt;BehaviorGraphAgent&gt;();&#13;&#10;&#13;&#10;            if (faBha)&#13;&#10;            {&#13;&#10;                // Kiểm tra BlackboardReference đã được gán chưa&#13;&#10;                if (faBha.BlackboardReference == null)&#13;&#10;                {&#13;&#10;                    Debug.LogError(&quot;BehaviorGraphAgent không có BlackboardReference!&quot;);&#13;&#10;                    return;&#13;&#10;                }&#13;&#10;&#13;&#10;                // Gán giá trị mặc định cho các biến trên Blackboard&#13;&#10;                var player = GameObject.Find(&quot;Player&quot;);&#13;&#10;                if (player != null)&#13;&#10;                {&#13;&#10;                    faBha.BlackboardReference.SetVariableValue(&quot;Player&quot;, player);&#13;&#10;                }&#13;&#10;                &#13;&#10;&#13;&#10;            }&#13;&#10;            else&#13;&#10;            {&#13;&#10;                Debug.LogError(&quot;Không tìm thấy BehaviorGraphAgent trên đối tượng này!&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            if (onReadyEventChannel != null)&#13;&#10;            {&#13;&#10;                onReadyEventChannel.RaiseEvent(this);&#13;&#10;                Debug.Log(&quot;[FaAgent] Đã sẵn sàng và phát tín hiệu.&quot;);&#13;&#10;            }&#13;&#10;            else&#13;&#10;            {&#13;&#10;                Debug.LogWarning(&quot;Chưa gán Event Channel cho FaAgent!&quot;);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        void Update()&#13;&#10;        {&#13;&#10;            // Giảm cooldown mỗi frame&#13;&#10;            var keys = new List&lt;string&gt;(_cooldownTimers.Keys);&#13;&#10;            foreach (string key in keys)&#13;&#10;            {&#13;&#10;                _cooldownTimers[key] = Mathf.Max(0, _cooldownTimers[key] - Time.deltaTime);&#13;&#10;            }&#13;&#10;&#13;&#10;            UpdateCooldownToCanvas();&#13;&#10;        &#13;&#10;            if (faBha == null) return;&#13;&#10;            &#13;&#10;            &#13;&#10;            // 2. Đồng bộ hóa trạng thái cooldown LÊN Blackboard&#13;&#10;            // Tên skill trong C# phải khớp với tên trong hàm IsSkillAvailable&#13;&#10;            // Tên biến trên Blackboard phải khớp với những gì bạn đã tạo&#13;&#10;            faBha.BlackboardReference.SetVariableValue(&quot;IsProtectiveAuraAvailable&quot;, IsSkillAvailable(&quot;ProtectiveAura&quot;));&#13;&#10;            faBha.BlackboardReference.SetVariableValue(&quot;IsGuideSignalAvailable&quot;, IsSkillAvailable(&quot;GuideSignal&quot;));&#13;&#10;            faBha.BlackboardReference.SetVariableValue(&quot;IsKnowledgeLightAvailable&quot;, IsSkillAvailable(&quot;KnowledgeLight&quot;));&#13;&#10;        &#13;&#10;            // Chỉ xử lý task mới khi Graph rảnh và hàng đợi có task&#13;&#10;            if (HasTask())&#13;&#10;            {&#13;&#10;                var task = GetNextTask();&#13;&#10;                if (task != null)&#13;&#10;                {&#13;&#10;                    var playerTaskType = PlayerTaskType.None;&#13;&#10;&#13;&#10;                    if (task.Type == TaskType.MoveTo)&#13;&#10;                    {&#13;&#10;                        playerTaskType = PlayerTaskType.Move;&#13;&#10;                    }&#13;&#10;                    else if (task.Type == TaskType.UseSkill)&#13;&#10;                    {&#13;&#10;                        // Dựa vào SkillName (hiện là &quot;1&quot;, &quot;2&quot;, &quot;3&quot; từ input) để chọn đúng enum&#13;&#10;                        switch (task.SkillName)&#13;&#10;                        {&#13;&#10;                            case &quot;GuideSignal&quot;:&#13;&#10;                                playerTaskType = PlayerTaskType.GuideSignal;&#13;&#10;                                UseGuideSignal();&#13;&#10;                                break;&#13;&#10;                            case &quot;KnowledgeLight&quot;:&#13;&#10;                                playerTaskType = PlayerTaskType.KnowledgeLight;&#13;&#10;                                UseKnowledgeLight();&#13;&#10;                                break;&#13;&#10;                            case &quot;ProtectiveAura&quot;:&#13;&#10;                                playerTaskType = PlayerTaskType.ProtectiveAura;&#13;&#10;                                UseProtectiveAura();&#13;&#10;                                break;&#13;&#10;                            default:&#13;&#10;                                Debug.LogWarning($&quot;Skill name '{task.SkillName}' không hợp lệ!&quot;);&#13;&#10;                                playerTaskType = PlayerTaskType.None;&#13;&#10;                                break;&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Nếu không có task nào hợp lệ thì không làm gì cả&#13;&#10;                    if (playerTaskType == PlayerTaskType.None) return;&#13;&#10;&#13;&#10;                    // Đẩy dữ liệu vào Blackboard&#13;&#10;                    if (task.TaskPosition != null)&#13;&#10;                        faBha.BlackboardReference.SetVariableValue(&quot;TaskPosition&quot;, task.TaskPosition);&#13;&#10;                    faBha.BlackboardReference.SetVariableValue(&quot;TaskFromPlayer&quot;, playerTaskType);&#13;&#10;                    if (task.TargetObject != null)&#13;&#10;                        faBha.BlackboardReference.SetVariableValue(&quot;Self_ActiveProtectiveAura&quot;, task.TargetObject);&#13;&#10;                    // Bật chế độ PlayerControl để Graph nhận task&#13;&#10;                    //ActivePlayerControl(true);&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;    &#13;&#10;        private void UpdateCooldownToCanvas()&#13;&#10;        {&#13;&#10;            float cooldownValue; // Biến tạm để lưu giá trị cooldown&#13;&#10;&#13;&#10;            if (skill1Cooldown != null)&#13;&#10;            {&#13;&#10;                // Thử lấy giá trị, nếu không có thì cooldownValue sẽ là 0&#13;&#10;                _cooldownTimers.TryGetValue(&quot;GuideSignal&quot;, out cooldownValue);&#13;&#10;                skill1Cooldown.text = cooldownValue &gt; 0 ? Mathf.CeilToInt(cooldownValue).ToString() : &quot;Ready&quot;;&#13;&#10;            }&#13;&#10;&#13;&#10;            if (skill2Cooldown != null)&#13;&#10;            {&#13;&#10;                _cooldownTimers.TryGetValue(&quot;KnowledgeLight&quot;, out cooldownValue);&#13;&#10;                skill2Cooldown.text = cooldownValue &gt; 0 ? Mathf.CeilToInt(cooldownValue).ToString() : &quot;Ready&quot;;&#13;&#10;            }&#13;&#10;    &#13;&#10;            if (skill3Cooldown != null)&#13;&#10;            {&#13;&#10;                _cooldownTimers.TryGetValue(&quot;ProtectiveAura&quot;, out cooldownValue);&#13;&#10;                skill3Cooldown.text = cooldownValue &gt; 0 ? Mathf.CeilToInt(cooldownValue).ToString() : &quot;Ready&quot;;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        public bool ActivePlayerControl(bool v)&#13;&#10;        {&#13;&#10;            try&#13;&#10;            {&#13;&#10;                faBha?.BlackboardReference.SetVariableValue(&quot;PlayerControl&quot;, v);&#13;&#10;                return true;&#13;&#10;            }&#13;&#10;            catch (System.Exception ex)&#13;&#10;            {&#13;&#10;                Debug.LogError($&quot;Lỗi khi thay đổi chế độ chỉ huy NPC: {ex.Message}&quot;);&#13;&#10;                return false;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        public bool ReturnPlayerControlFromBlackBoard()&#13;&#10;        {&#13;&#10;            // Kiểm tra an toàn, phòng trường hợp BHA chưa được gán&#13;&#10;            if (faBha == null)&#13;&#10;            {&#13;&#10;                return false;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Dùng GetVariableValue để đọc giá trị từ Blackboard&#13;&#10;            if (faBha.BlackboardReference.GetVariableValue(&quot;PlayerControl&quot;, out bool isControlled))&#13;&#10;            {&#13;&#10;                // Nếu tìm thấy biến, trả về giá trị của nó&#13;&#10;                return isControlled;&#13;&#10;            }&#13;&#10;&#13;&#10;            // Nếu không tìm thấy biến trên Blackboard, trả về false và báo lỗi&#13;&#10;            Debug.LogWarning(&quot;Không tìm thấy biến 'PlayerControl' trên Blackboard!&quot;);&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;&#13;&#10;        #region  FaInterface&#13;&#10;        // Hàm này cần được sửa lại cho đúng tên và tham số như trong Interface&#13;&#10;        public void UseProtectiveAura() &#13;&#10;        {&#13;&#10;            if (!IsSkillAvailable(&quot;ProtectiveAura&quot;)) return;&#13;&#10;            StartSkillCooldown(&quot;ProtectiveAura&quot;, 20f);&#13;&#10;            Code.Boss.BossEventSystem.Trigger(Code.Boss.BossEventType.FaSkillUsed, new Code.Boss.BossEventData(&quot;ProtectiveAura&quot;));&#13;&#10;        }&#13;&#10;&#13;&#10;        public void UseGuideSignal()&#13;&#10;        {&#13;&#10;            if (!IsSkillAvailable(&quot;GuideSignal&quot;)) return;&#13;&#10;            Debug.Log(&quot;Thực thi kỹ năng TinHieuDanLoi (GuideSignal)!&quot;);&#13;&#10;            StartSkillCooldown(&quot;GuideSignal&quot;, 10f);&#13;&#10;            Code.Boss.BossEventSystem.Trigger(Code.Boss.BossEventType.FaSkillUsed, new Code.Boss.BossEventData(&quot;GuideSignal&quot;));&#13;&#10;        }&#13;&#10;&#13;&#10;        public void UseKnowledgeLight()&#13;&#10;        {&#13;&#10;            if (!IsSkillAvailable(&quot;KnowledgeLight&quot;)) return;&#13;&#10;            Debug.Log(&quot;Thực thi kỹ năng AnhSangTriThuc (KnowledgeLight)!&quot;);&#13;&#10;            StartSkillCooldown(&quot;KnowledgeLight&quot;, 15f);&#13;&#10;            Code.Boss.BossEventSystem.Trigger(Code.Boss.BossEventType.FaSkillUsed, new Code.Boss.BossEventData(&quot;KnowledgeLight&quot;));&#13;&#10;        }&#13;&#10;&#13;&#10;        #endregion&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>