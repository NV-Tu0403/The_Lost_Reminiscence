<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Behaviors/FearBehaviour.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Behaviors/FearBehaviour.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;        private Vector3 fearZonePosition;&#10;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;        private void CheckPlayerInZone()&#10;        {&#10;            var distanceToPlayer = Vector3.Distance(fearZonePosition, BossController.Player.position);&#10;            var currentlyInZone = distanceToPlayer &lt;= Config.phase2.fearZoneRadius;&#10;            &#10;            if (currentlyInZone)&#10;            {&#10;                if (!playerInZone)&#10;                {&#10;                    playerInZone = true;&#10;                    playerInZoneTime = 0f;&#10;                    StartHeartbeatSound();&#10;                }&#10;                playerInZoneTime += Time.deltaTime;&#10;            }&#10;            else&#10;            {&#10;                if (!playerInZone) return;&#10;                playerInZone = false;&#10;                playerInZoneTime = 0f;&#10;                StopHeartbeatSound();&#10;            }&#10;        }&#10;&#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (Config.audioConfig.heartbeatSound == null) return;&#10;            BossController.AudioSource.clip = Config.audioConfig.heartbeatSound;&#10;            BossController.AudioSource.loop = true;&#10;            BossController.AudioSource.Play();&#10;        }&#10;&#10;        private void StopHeartbeatSound()&#10;        {&#10;            BossController.AudioSource.Stop();&#10;            BossController.AudioSource.loop = false;&#10;        }&#10;&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;        private Vector3 fearZonePosition;&#10;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;                StartHeartbeatSound();&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;                StopHeartbeatSound();&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;&#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (Config.audioConfig.heartbeatSound == null) return;&#10;            BossController.AudioSource.clip = Config.audioConfig.heartbeatSound;&#10;            BossController.AudioSource.loop = true;&#10;            BossController.AudioSource.Play();&#10;        }&#10;&#10;        private void StopHeartbeatSound()&#10;        {&#10;            BossController.AudioSource.Stop();&#10;            BossController.AudioSource.loop = false;&#10;        }&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Behaviors/MemoryFragmentBehavior.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Behaviors/MemoryFragmentBehavior.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Memory Fragment - mảnh ghép kí ức&#10;    /// &lt;/summary&gt;&#10;    public class MemoryFragmentBehavior : MonoBehaviour&#10;    {&#10;        [Header(&quot;Float Animation&quot;)]&#10;        [SerializeField] private float floatHeight = 0.5f;&#10;        [SerializeField] private float floatSpeed = 2f;&#10;        &#10;        [Header(&quot;Rotation Animation&quot;)]&#10;        [SerializeField] private float rotationSpeed = 50f;&#10;        [SerializeField] private Vector3 rotationAxis = Vector3.up;&#10;        &#10;        private bool collected = false;&#10;        private Vector3 startPosition;&#10;        private float floatTimer;&#10;&#10;        private void Start()&#10;        {&#10;            startPosition = transform.position;&#10;            floatTimer = Random.Range(0f, 2f * Mathf.PI); // Random start offset&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!collected)&#10;            {&#10;                // Float animation&#10;                floatTimer += Time.deltaTime * floatSpeed;&#10;                float newY = startPosition.y + Mathf.Sin(floatTimer) * floatHeight;&#10;                transform.position = new Vector3(startPosition.x, newY, startPosition.z);&#10;                &#10;                // Rotation animation&#10;                transform.Rotate(rotationAxis, rotationSpeed * Time.deltaTime);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !collected)&#10;            {&#10;                CollectFragment();&#10;            }&#10;        }&#10;&#10;        private void CollectFragment()&#10;        {&#10;            collected = true;&#10;            &#10;            // Trigger collection event&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;MemoryFragmentCollected&quot;, gameObject = gameObject });&#10;            &#10;            // TODO:&#10;            // Play collection effect and sound&#10;            // Add particle effects here&#10;            // Run Timeline here&#10;            &#10;            // Destroy after collection&#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Memory Fragment - mảnh ghép kí ức&#10;    /// &lt;/summary&gt;&#10;    public class MemoryFragmentBehavior : MonoBehaviour&#10;    {&#10;        [Header(&quot;Float Animation&quot;)]&#10;        [SerializeField] private float floatHeight = 1.5f;&#10;        [SerializeField] private float floatSpeed = 2f;&#10;        &#10;        [Header(&quot;Rotation Animation&quot;)]&#10;        [SerializeField] private float rotationSpeed = 50f;&#10;        [SerializeField] private Vector3 rotationAxis = Vector3.up;&#10;        &#10;        private bool collected = false;&#10;        private Vector3 startPosition;&#10;        private Vector3 targetPosition;&#10;        private bool hasReachedTarget = false;&#10;        private float floatProgress = 0f;&#10;        private GameObject spawnedEffect;&#10;&#10;        private void Start()&#10;        {&#10;            startPosition = transform.position;&#10;            targetPosition = startPosition + Vector3.up * floatHeight;&#10;            &#10;            // Spawn effect nếu có trong BossConfig&#10;            SpawnEffect();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!collected)&#10;            {&#10;                if (!hasReachedTarget)&#10;                {&#10;                    // Bay lên đến vị trí target&#10;                    floatProgress += Time.deltaTime * floatSpeed;&#10;                    transform.position = Vector3.Lerp(startPosition, targetPosition, floatProgress);&#10;                    &#10;                    if (floatProgress &gt;= 1f)&#10;                    {&#10;                        hasReachedTarget = true;&#10;                        transform.position = targetPosition;&#10;                    }&#10;                }&#10;                &#10;                // Xoay vòng liên tục&#10;                transform.Rotate(rotationAxis, rotationSpeed * Time.deltaTime);&#10;            }&#10;        }&#10;&#10;        private void SpawnEffect()&#10;        {&#10;            // Tìm BossConfig để lấy effect prefab&#10;            var bossController = FindObjectOfType&lt;BossController&gt;();&#10;            if (bossController != null &amp;&amp; bossController.Config.memoryFragmentEffectPrefab != null)&#10;            {&#10;                spawnedEffect = Instantiate(bossController.Config.memoryFragmentEffectPrefab, &#10;                    transform.position, Quaternion.identity, transform);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !collected)&#10;            {&#10;                CollectFragment();&#10;            }&#10;        }&#10;&#10;        private void CollectFragment()&#10;        {&#10;            collected = true;&#10;            &#10;            // Trigger collection event&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;MemoryFragmentCollected&quot;, gameObject = gameObject });&#10;            &#10;            // TODO:&#10;            // Play collection effect and sound&#10;            // Add particle effects here&#10;            // Run Timeline here&#10;            &#10;            // Destroy after collection&#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossBehaviors.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossBehaviors.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Decoy (bóng ảo) - di chuyển chậm theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyBehavior : MonoBehaviour&#10;    {&#10;        private BossController bossController;&#10;        private bool isReal;&#10;        private float moveSpeed;&#10;        private Transform target;&#10;        &#10;        public bool IsReal =&gt; isReal;&#10;&#10;        public void Initialize(BossController controller, bool real, float speed)&#10;        {&#10;            bossController = controller;&#10;            isReal = real;&#10;            moveSpeed = speed;&#10;            target = controller.Player;&#10;            &#10;            // Visual differences between real and fake decoy could be added here&#10;            if (!isReal)&#10;            {&#10;                // Make fake decoy slightly different (transparency, color, etc.)&#10;                var renderer = GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = renderer.material;&#10;                    var color = material.color;&#10;                    color.a = 0.8f; // Slightly transparent&#10;                    material.color = color;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                MoveTowardsTarget();&#10;            }&#10;        }&#10;&#10;        private void MoveTowardsTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            transform.position += direction * moveSpeed * Time.deltaTime;&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;))&#10;            {&#10;                HandlePlayerContact();&#10;            }&#10;        }&#10;&#10;        private void HandlePlayerContact()&#10;        {&#10;            if (isReal)&#10;            {&#10;                // Player hit real decoy - boss takes damage&#10;                BossEventSystem.Trigger(BossEventType.RealDecoyHit);&#10;                bossController.TakeDamage(1);&#10;            }&#10;            else&#10;            {&#10;                // Player hit fake decoy - player takes damage&#10;                BossEventSystem.Trigger(BossEventType.FakeDecoyHit);&#10;                BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                &#10;                // Transition to Soul State&#10;                bossController.ChangeState(new SoulState());&#10;            }&#10;            &#10;            // Remove this decoy&#10;            bossController.RemoveDecoy(gameObject);&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Soul (dục hồn) - đuổi nhanh theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class SoulBehavior : MonoBehaviour&#10;    {&#10;        private Transform target;&#10;        private SoulConfig config;&#10;        private float currentSpeed;&#10;        &#10;        public void Initialize(Transform playerTarget, SoulConfig soulConfig)&#10;        {&#10;            target = playerTarget;&#10;            config = soulConfig;&#10;            currentSpeed = config.soulMoveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                FollowTarget();&#10;            }&#10;        }&#10;&#10;        private void FollowTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            &#10;            // Keep minimum distance from player&#10;            float distance = Vector3.Distance(transform.position, target.position);&#10;            if (distance &gt; config.soulFollowDistance)&#10;            {&#10;                transform.position += direction * currentSpeed * Time.deltaTime;&#10;            }&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;            &#10;            // Add floating/hovering effect&#10;            AddFloatingEffect();&#10;        }&#10;&#10;        private void AddFloatingEffect()&#10;        {&#10;            float hover = Mathf.Sin(Time.time * 2f) * 0.5f;&#10;            Vector3 pos = transform.position;&#10;            pos.y += hover * Time.deltaTime;&#10;            transform.position = pos;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Soul destroyed - could trigger particle effects here&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;            &#10;            CreateVisualEffect();&#10;        }&#10;&#10;        private void CreateVisualEffect()&#10;        {&#10;            // Create dark circle on ground&#10;            var cylinder = GameObject.CreatePrimitive(PrimitiveType.Cylinder);&#10;            cylinder.transform.parent = transform;&#10;            cylinder.transform.localPosition = Vector3.zero;&#10;            cylinder.transform.localScale = new Vector3(radius * 2, 0.1f, radius * 2);&#10;            &#10;            // Make it dark and transparent&#10;            var renderer = cylinder.GetComponent&lt;Renderer&gt;();&#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = new Color(0, 0, 0, 0.7f);&#10;                material.SetFloat(&quot;_Mode&quot;, 3); // Transparent mode&#10;                renderer.material = material;&#10;            }&#10;            &#10;            // Remove collider&#10;            var collider = cylinder.GetComponent&lt;Collider&gt;();&#10;            if (collider != null)&#10;                Destroy(collider);&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Memory Fragment - mảnh ghép kí ức&#10;    /// &lt;/summary&gt;&#10;    public class MemoryFragmentBehavior : MonoBehaviour&#10;    {&#10;        private bool collected = false;&#10;        &#10;        private void Start()&#10;        {&#10;            // Add visual effects for memory fragment&#10;            AddGlowEffect();&#10;        }&#10;&#10;        private void AddGlowEffect()&#10;        {&#10;            // Add rotating and glowing effect&#10;            var renderer = GetComponent&lt;Renderer&gt;();&#10;            if (renderer == null)&#10;            {&#10;                // Create a simple cube as memory fragment&#10;                var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);&#10;                cube.transform.parent = transform;&#10;                cube.transform.localPosition = Vector3.zero;&#10;                renderer = cube.GetComponent&lt;Renderer&gt;();&#10;            }&#10;            &#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = Color.cyan;&#10;                material.EnableKeyword(&quot;_EMISSION&quot;);&#10;                material.SetColor(&quot;_EmissionColor&quot;, Color.cyan * 0.5f);&#10;                renderer.material = material;&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!collected)&#10;            {&#10;                // Rotate the fragment&#10;                transform.Rotate(0, 90 * Time.deltaTime, 0);&#10;                &#10;                // Add floating effect&#10;                float hover = Mathf.Sin(Time.time * 2f) * 0.2f;&#10;                Vector3 pos = transform.position;&#10;                pos.y += hover * Time.deltaTime;&#10;                transform.position = pos;&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !collected)&#10;            {&#10;                CollectFragment();&#10;            }&#10;        }&#10;&#10;        private void CollectFragment()&#10;        {&#10;            collected = true;&#10;            &#10;            // Trigger collection event&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;MemoryFragmentCollected&quot;, gameObject = gameObject });&#10;            &#10;            // Play collection effect and sound&#10;            // Add particle effects here&#10;            &#10;            // Destroy after collection&#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Decoy (bóng ảo) - di chuyển chậm theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyBehavior : MonoBehaviour&#10;    {&#10;        private BossController bossController;&#10;        private bool isReal;&#10;        private float moveSpeed;&#10;        private Transform target;&#10;        &#10;        public bool IsReal =&gt; isReal;&#10;&#10;        public void Initialize(BossController controller, bool real, float speed)&#10;        {&#10;            bossController = controller;&#10;            isReal = real;&#10;            moveSpeed = speed;&#10;            target = controller.Player;&#10;            &#10;            // Visual differences between real and fake decoy could be added here&#10;            if (!isReal)&#10;            {&#10;                // Make fake decoy slightly different (transparency, color, etc.)&#10;                var renderer = GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = renderer.material;&#10;                    var color = material.color;&#10;                    color.a = 0.8f; // Slightly transparent&#10;                    material.color = color;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                MoveTowardsTarget();&#10;            }&#10;        }&#10;&#10;        private void MoveTowardsTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            transform.position += direction * moveSpeed * Time.deltaTime;&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;))&#10;            {&#10;                HandlePlayerContact();&#10;            }&#10;        }&#10;&#10;        private void HandlePlayerContact()&#10;        {&#10;            if (isReal)&#10;            {&#10;                // Player hit real decoy - boss takes damage&#10;                BossEventSystem.Trigger(BossEventType.RealDecoyHit);&#10;                bossController.TakeDamage(1);&#10;            }&#10;            else&#10;            {&#10;                // Player hit fake decoy - player takes damage&#10;                BossEventSystem.Trigger(BossEventType.FakeDecoyHit);&#10;                BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                &#10;                // Transition to Soul State&#10;                bossController.ChangeState(new SoulState());&#10;            }&#10;            &#10;            // Remove this decoy&#10;            bossController.RemoveDecoy(gameObject);&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Soul (dục hồn) - đuổi nhanh theo người chơi&#10;    /// &lt;/summary&gt;&#10;    public class SoulBehavior : MonoBehaviour&#10;    {&#10;        private Transform target;&#10;        private SoulConfig config;&#10;        private float currentSpeed;&#10;        &#10;        public void Initialize(Transform playerTarget, SoulConfig soulConfig)&#10;        {&#10;            target = playerTarget;&#10;            config = soulConfig;&#10;            currentSpeed = config.soulMoveSpeed;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (target != null)&#10;            {&#10;                FollowTarget();&#10;            }&#10;        }&#10;&#10;        private void FollowTarget()&#10;        {&#10;            Vector3 direction = (target.position - transform.position).normalized;&#10;            &#10;            // Keep minimum distance from player&#10;            float distance = Vector3.Distance(transform.position, target.position);&#10;            if (distance &gt; config.soulFollowDistance)&#10;            {&#10;                transform.position += direction * currentSpeed * Time.deltaTime;&#10;            }&#10;            &#10;            // Rotate to face target&#10;            if (direction != Vector3.zero)&#10;            {&#10;                transform.rotation = Quaternion.LookRotation(direction);&#10;            }&#10;            &#10;            // Add floating/hovering effect&#10;            AddFloatingEffect();&#10;        }&#10;&#10;        private void AddFloatingEffect()&#10;        {&#10;            float hover = Mathf.Sin(Time.time * 2f) * 0.5f;&#10;            Vector3 pos = transform.position;&#10;            pos.y += hover * Time.deltaTime;&#10;            transform.position = pos;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Soul destroyed - could trigger particle effects here&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Fear Zone - vùng tối gây hiệu ứng tâm lý&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneBehavior : MonoBehaviour&#10;    {&#10;        private float radius;&#10;        private float blurIntensity;&#10;        private bool isActive = false;&#10;        &#10;        public void Initialize(float zoneRadius, float visionBlur)&#10;        {&#10;            radius = zoneRadius;&#10;            blurIntensity = visionBlur;&#10;            isActive = true;&#10;            &#10;            CreateVisualEffect();&#10;        }&#10;&#10;        private void CreateVisualEffect()&#10;        {&#10;            // Create dark circle on ground&#10;            var cylinder = GameObject.CreatePrimitive(PrimitiveType.Cylinder);&#10;            cylinder.transform.parent = transform;&#10;            cylinder.transform.localPosition = Vector3.zero;&#10;            cylinder.transform.localScale = new Vector3(radius * 2, 0.1f, radius * 2);&#10;            &#10;            // Make it dark and transparent&#10;            var renderer = cylinder.GetComponent&lt;Renderer&gt;();&#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = new Color(0, 0, 0, 0.7f);&#10;                material.SetFloat(&quot;_Mode&quot;, 3); // Transparent mode&#10;                renderer.material = material;&#10;            }&#10;            &#10;            // Remove collider&#10;            var collider = cylinder.GetComponent&lt;Collider&gt;();&#10;            if (collider != null)&#10;                Destroy(collider);&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player entered fear zone&#10;                ApplyFearEffects(true);&#10;            }&#10;        }&#10;&#10;        private void OnTriggerExit(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; isActive)&#10;            {&#10;                // Player left fear zone&#10;                ApplyFearEffects(false);&#10;            }&#10;        }&#10;&#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            // This would integrate with camera/post-processing effects&#10;            string effectName = enable ? &quot;EnableFearEffect&quot; : &quot;DisableFearEffect&quot;;&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = effectName, floatValue = blurIntensity });&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Hành vi của Memory Fragment - mảnh ghép kí ức&#10;    /// &lt;/summary&gt;&#10;    public class MemoryFragmentBehavior : MonoBehaviour&#10;    {&#10;        private bool collected = false;&#10;        &#10;        private void Start()&#10;        {&#10;            // Add visual effects for memory fragment&#10;            AddGlowEffect();&#10;        }&#10;&#10;        private void AddGlowEffect()&#10;        {&#10;            // Add rotating and glowing effect&#10;            var renderer = GetComponent&lt;Renderer&gt;();&#10;            if (renderer == null)&#10;            {&#10;                // Create a simple cube as memory fragment&#10;                var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);&#10;                cube.transform.parent = transform;&#10;                cube.transform.localPosition = Vector3.zero;&#10;                renderer = cube.GetComponent&lt;Renderer&gt;();&#10;            }&#10;            &#10;            if (renderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = Color.cyan;&#10;                material.EnableKeyword(&quot;_EMISSION&quot;);&#10;                material.SetColor(&quot;_EmissionColor&quot;, Color.cyan * 0.5f);&#10;                renderer.material = material;&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            if (!collected)&#10;            {&#10;                // Rotate the fragment&#10;                transform.Rotate(0, 90 * Time.deltaTime, 0);&#10;                &#10;                // Add floating effect&#10;                float hover = Mathf.Sin(Time.time * 2f) * 0.2f;&#10;                Vector3 pos = transform.position;&#10;                pos.y += hover * Time.deltaTime;&#10;                transform.position = pos;&#10;            }&#10;        }&#10;&#10;        private void OnTriggerEnter(Collider other)&#10;        {&#10;            if (other.CompareTag(&quot;Player&quot;) &amp;&amp; !collected)&#10;            {&#10;                CollectFragment();&#10;            }&#10;        }&#10;&#10;        private void CollectFragment()&#10;        {&#10;            collected = true;&#10;            &#10;            // Trigger collection event&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;MemoryFragmentCollected&quot;, gameObject = gameObject });&#10;            &#10;            // Play collection effect and sound&#10;            // Add particle effects here&#10;            &#10;            // Destroy after collection&#10;            Destroy(gameObject, 0.5f);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossConfig.cs" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Cấu hình toàn bộ boss - File config duy nhất để điều chỉnh toàn bộ boss&#10;    /// &lt;/summary&gt;&#10;    [CreateAssetMenu(fileName = &quot;BossConfig&quot;, menuName = &quot;Boss/Boss Configuration&quot;)]&#10;    public class BossConfig : ScriptableObject&#10;    {&#10;        [Header(&quot;General Boss Settings&quot;)]&#10;        public int maxHealthPerPhase = 3;&#10;        public float moveSpeed = 5f;&#10;        public float rotationSpeed = 90f;&#10;        &#10;        [Header(&quot;Phase 1 Settings&quot;)]&#10;        [Space]&#10;        public Phase1Config phase1;&#10;        &#10;        [Header(&quot;Phase 2 Settings&quot;)]&#10;        [Space]&#10;        public Phase2Config phase2;&#10;        &#10;        [Header(&quot;Soul Settings&quot;)]&#10;        [Space]&#10;        public SoulConfig soulConfig;&#10;        &#10;        [Header(&quot;UI Settings&quot;)]&#10;        [Space]&#10;        public UIConfig uiConfig;&#10;        &#10;        [Header(&quot;Audio Settings&quot;)]&#10;        [Space]&#10;        public AudioConfig audioConfig;&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase1Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float idleDuration = 2f;&#10;        public float lureDuration = 3f;&#10;        public float mockDuration = 2f;&#10;        public float decoyCastTime = 2f;&#10;        public float decoyDuration = 10f;&#10;        public float soulStateCastTime = 1.5f;&#10;        &#10;        [Header(&quot;Lure State&quot;)]&#10;        public float lureDistance = 5f;&#10;        public float lureApproachSpeed = 3f;&#10;        public float lureRetreatSpeed = 4f;&#10;        &#10;        [Header(&quot;Decoy State&quot;)]&#10;        public float decoyMoveSpeed = 2f;&#10;        public int decoyCount = 2; // 1 thật, 1 giả&#10;        public float decoySpawnRadius = 8f;&#10;        &#10;        [Header(&quot;State Randomization&quot;)]&#10;        public bool enableRandomStates = true;&#10;        public float[] stateWeights = { 1f, 1f, 1f, 1f }; // Idle, Lure, Mock, Decoy&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase2Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float angryMoveDuration = 5f;&#10;        public float fearZoneCastTime = 2f;&#10;        public float fearZoneDuration = 8f;&#10;        public float fearZoneActivationTime = 3f;&#10;        public float screamCastTime = 3f;&#10;        public float screamDuration = 5f;&#10;        public float cookStateDuration = 3f;&#10;        &#10;        [Header(&quot;Angry State&quot;)]&#10;        public float angryMoveSpeed = 3f;&#10;        public float circleRadius = 10f;&#10;        &#10;        [Header(&quot;Fear Zone&quot;)]&#10;        public float fearZoneRadius = 3f;&#10;        public float visionBlurIntensity = 0.7f;&#10;        &#10;        [Header(&quot;Scream State&quot;)]&#10;        public float screenShakeIntensity = 1f;&#10;        public float visionShrinkAmount = 0.5f;&#10;    }&#10;&#10;    [Serializable]&#10;    public class SoulConfig&#10;    {&#10;        public int maxSouls = 2;&#10;        public float soulMoveSpeed = 4f;&#10;        public float soulSpawnRadius = 15f;&#10;        public float soulFollowDistance = 1f;&#10;        public GameObject soulPrefab;&#10;    }&#10;&#10;    [Serializable]&#10;    public class UIConfig&#10;    {&#10;        [Header(&quot;Health Bar&quot;)]&#10;        public Vector2 bossHealthPosition = new Vector2(0f, 0.8f); // Screen space&#10;        public Vector2 playerHealthPosition = new Vector2(0f, -0.8f);&#10;        public Vector2 healthBarSize = new Vector2(300f, 30f);&#10;        &#10;        [Header(&quot;Skill Cast Bar&quot;)]&#10;        public Vector2 skillCastBarOffset = new Vector2(0f, -50f); // Offset from boss health&#10;        public Vector2 skillCastBarSize = new Vector2(200f, 20f);&#10;        &#10;        [Header(&quot;Colors&quot;)]&#10;        public Color bossHealthColor = Color.red;&#10;        public Color playerHealthColor = Color.green;&#10;        public Color skillCastColor = Color.yellow;&#10;    }&#10;&#10;    [Serializable]&#10;    public class AudioConfig&#10;    {&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#10;        public AudioClip mockLaughSound;&#10;        public AudioClip decoySpawnSound;&#10;        public AudioClip soulSpawnSound;&#10;        &#10;        [Header(&quot;Phase 2 Audio&quot;)]&#10;        public AudioClip screamSound;&#10;        public AudioClip fearZoneSound;&#10;        public AudioClip heartbeatSound;&#10;        &#10;        [Header(&quot;General Audio&quot;)]&#10;        public AudioClip phaseChangeSound;&#10;        public AudioClip damageSound;&#10;        public AudioClip defeatSound;&#10;        &#10;        [Header(&quot;Volume Settings&quot;)]&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#10;        [Range(0f, 1f)] public float sfxVolume = 0.8f;&#10;        [Range(0f, 1f)] public float ambientVolume = 0.6f;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossController.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.AI;&#10;using Code.Boss.States.Phase1;&#10;using Code.Boss.States.Phase2;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Controller chính của Boss - quản lý FSM, health, phases&#10;    /// &lt;/summary&gt;&#10;    public class BossController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)]&#10;        [SerializeField] private BossConfig bossConfig;&#10;        &#10;        [Header(&quot;Components&quot;)]&#10;        [SerializeField] private NavMeshAgent navMeshAgent;&#10;        [SerializeField] private Animator animator;&#10;        [SerializeField] private AudioSource audioSource;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private Transform player;&#10;        [SerializeField] private Transform navMeshCenter;&#10;        &#10;        // Core Systems&#10;        private BossStateMachine stateMachine;&#10;        private BossHealthSystem healthSystem;&#10;        private BossSoulManager soulManager;&#10;        private BossUIManager uiManager;&#10;        &#10;        // Current Phase&#10;        private int currentPhase = 1;&#10;        private List&lt;GameObject&gt; currentDecoys = new List&lt;GameObject&gt;();&#10;        &#10;        // Public Properties&#10;        public BossConfig Config =&gt; bossConfig;&#10;        public NavMeshAgent NavAgent =&gt; navMeshAgent;&#10;        public Animator BossAnimator =&gt; animator;&#10;        public AudioSource AudioSource =&gt; audioSource;&#10;        public Transform Player =&gt; player;&#10;        public Transform NavMeshCenter =&gt; navMeshCenter;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public BossHealthSystem HealthSystem =&gt; healthSystem;&#10;        public BossSoulManager SoulManager =&gt; soulManager;&#10;        public List&lt;GameObject&gt; CurrentDecoys =&gt; currentDecoys;&#10;        &#10;        // Events&#10;        public System.Action&lt;int&gt; OnPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;&#10;        private void Awake()&#10;        {&#10;            InitializeComponents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeSystems();&#10;            StartBoss();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            stateMachine?.Update();&#10;        }&#10;&#10;        private void InitializeComponents()&#10;        {&#10;            // Auto-find components if not assigned&#10;            if (navMeshAgent == null)&#10;                navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();&#10;            &#10;            if (animator == null)&#10;                animator = GetComponent&lt;Animator&gt;();&#10;            &#10;            if (audioSource == null)&#10;                audioSource = GetComponent&lt;AudioSource&gt;();&#10;            &#10;            if (player == null)&#10;                player = GameObject.FindGameObjectWithTag(&quot;Player&quot;)?.transform;&#10;        }&#10;&#10;        private void InitializeSystems()&#10;        {&#10;            // Initialize FSM&#10;            stateMachine = new BossStateMachine();&#10;            stateMachine.Initialize(this);&#10;            &#10;            // Initialize Health System&#10;            healthSystem = new BossHealthSystem(bossConfig.maxHealthPerPhase);&#10;            healthSystem.OnHealthChanged += OnHealthChanged;&#10;            healthSystem.OnPhaseHealthDepleted += OnPhaseCompleted;&#10;            &#10;            // Initialize Soul Manager&#10;            soulManager = new BossSoulManager(this);&#10;            &#10;            // Initialize UI Manager&#10;            uiManager = new BossUIManager(this);&#10;            &#10;            // Setup NavMesh&#10;            if (navMeshAgent != null)&#10;            {&#10;                navMeshAgent.speed = bossConfig.moveSpeed;&#10;                navMeshAgent.angularSpeed = bossConfig.rotationSpeed;&#10;            }&#10;        }&#10;&#10;        private void StartBoss()&#10;        {&#10;            // Trigger boss spawned event&#10;            BossEventSystem.Trigger(BossEventType.BossSpawned);&#10;            &#10;            // Start with Phase 1&#10;            ChangeToPhase(1);&#10;        }&#10;&#10;        private void OnHealthChanged(int newHealth, int maxHealth)&#10;        {&#10;            BossEventSystem.Trigger(BossEventType.HealthChanged, &#10;                new BossEventData { intValue = newHealth, floatValue = maxHealth });&#10;        }&#10;&#10;        private void OnPhaseCompleted()&#10;        {&#10;            if (currentPhase == 1)&#10;            {&#10;                ChangeToPhase(2);&#10;            }&#10;            else if (currentPhase == 2)&#10;            {&#10;                DefeatBoss();&#10;            }&#10;        }&#10;&#10;        public void ChangeToPhase(int newPhase)&#10;        {&#10;            currentPhase = newPhase;&#10;            healthSystem.ResetPhaseHealth();&#10;            &#10;            // Clear any existing decoys&#10;            ClearDecoys();&#10;            &#10;            // Trigger phase change event&#10;            BossEventSystem.Trigger(BossEventType.PhaseChanged, new BossEventData(newPhase));&#10;            OnPhaseChanged?.Invoke(newPhase);&#10;            &#10;            // Change to appropriate starting state&#10;            if (newPhase == 1)&#10;            {&#10;                stateMachine.ChangeState(new IdleState());&#10;            }&#10;            else if (newPhase == 2)&#10;            {&#10;                stateMachine.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public void TakeDamage(int damage = 1)&#10;        {&#10;            healthSystem.TakeDamage(damage);&#10;            stateMachine.OnTakeDamage();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossTakeDamage, new BossEventData(damage));&#10;            &#10;            // Play damage sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.damageSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.damageSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            newState.Initialize(this, bossConfig);&#10;            stateMachine.ChangeState(newState);&#10;        }&#10;&#10;        public void AddDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Add(decoy);&#10;        }&#10;&#10;        public void RemoveDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Remove(decoy);&#10;        }&#10;&#10;        public void ClearDecoys()&#10;        {&#10;            foreach (var decoy in currentDecoys)&#10;            {&#10;                if (decoy != null)&#10;                    Destroy(decoy);&#10;            }&#10;            currentDecoys.Clear();&#10;        }&#10;&#10;        public void InterruptCurrentSkill()&#10;        {&#10;            if (stateMachine.CanInterruptCurrentState())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                &#10;                // Return to appropriate state based on phase&#10;                if (currentPhase == 1)&#10;                {&#10;                    ChangeState(new IdleState());&#10;                }&#10;                else&#10;                {&#10;                    ChangeState(new AngryState());&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DefeatBoss()&#10;        {&#10;            // Trigger defeat events&#10;            BossEventSystem.Trigger(BossEventType.BossDefeated);&#10;            OnBossDefeated?.Invoke();&#10;            &#10;            // Change to cook state for phase 2&#10;            ChangeState(new CookState());&#10;            &#10;            // Play defeat sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.defeatSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.defeatSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void PlayAnimation(string animationName)&#10;        {&#10;            if (animator != null)&#10;            {&#10;                animator.SetTrigger(animationName);&#10;            }&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f)&#10;        {&#10;            if (audioSource &amp;&amp; clip)&#10;            {&#10;                audioSource.PlayOneShot(clip, volume * bossConfig.audioConfig.masterVolume);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup&#10;            if (healthSystem != null)&#10;            {&#10;                healthSystem.OnHealthChanged -= OnHealthChanged;&#10;                healthSystem.OnPhaseHealthDepleted -= OnPhaseCompleted;&#10;            }&#10;            &#10;            ClearDecoys();&#10;            BossEventSystem.ClearAllListeners();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            if (bossConfig != null)&#10;            {&#10;                // Draw decoy spawn radius&#10;                Gizmos.color = Color.yellow;&#10;                DrawWireCircle(transform.position, bossConfig.phase1.decoySpawnRadius);&#10;                &#10;                // Draw soul spawn radius&#10;                Gizmos.color = Color.magenta;&#10;                DrawWireCircle(transform.position, bossConfig.soulConfig.soulSpawnRadius);&#10;                &#10;                // Draw phase 2 circle radius&#10;                if (navMeshCenter != null)&#10;                {&#10;                    Gizmos.color = Color.red;&#10;                    DrawWireCircle(navMeshCenter.position, bossConfig.phase2.circleRadius);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Helper method to draw wire circle in XZ plane&#10;        /// &lt;/summary&gt;&#10;        private void DrawWireCircle(Vector3 center, float radius)&#10;        {&#10;            int segments = 32;&#10;            float angleStep = 360f / segments;&#10;            Vector3 prevPoint = center + new Vector3(radius, 0, 0);&#10;            &#10;            for (int i = 1; i &lt;= segments; i++)&#10;            {&#10;                float angle = angleStep * i * Mathf.Deg2Rad;&#10;                Vector3 newPoint = center + new Vector3(&#10;                    Mathf.Cos(angle) * radius, &#10;                    0, &#10;                    Mathf.Sin(angle) * radius&#10;                );&#10;                &#10;                Gizmos.DrawLine(prevPoint, newPoint);&#10;                prevPoint = newPoint;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;using UnityEngine.AI;&#10;using Code.Boss.States.Phase1;&#10;using Code.Boss.States.Phase2;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Controller chính của Boss - quản lý FSM, health, phases&#10;    /// &lt;/summary&gt;&#10;    public class BossController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Configuration&quot;)]&#10;        [SerializeField] private BossConfig bossConfig;&#10;        &#10;        [Header(&quot;Components&quot;)]&#10;        [SerializeField] private NavMeshAgent navMeshAgent;&#10;        [SerializeField] private Animator animator;&#10;        [SerializeField] private AudioSource audioSource;&#10;        &#10;        [Header(&quot;References&quot;)]&#10;        [SerializeField] private Transform player;&#10;        [SerializeField] private Transform navMeshCenter;&#10;        &#10;        // Core Systems&#10;        private BossStateMachine stateMachine;&#10;        private BossHealthSystem healthSystem;&#10;        private BossSoulManager soulManager;&#10;        private BossUIManager uiManager;&#10;        &#10;        // Current Phase&#10;        private int currentPhase = 1;&#10;        private List&lt;GameObject&gt; currentDecoys = new List&lt;GameObject&gt;();&#10;        &#10;        // Public Properties&#10;        public BossConfig Config =&gt; bossConfig;&#10;        public NavMeshAgent NavAgent =&gt; navMeshAgent;&#10;        public Animator BossAnimator =&gt; animator;&#10;        public AudioSource AudioSource =&gt; audioSource;&#10;        public Transform Player =&gt; player;&#10;        public Transform NavMeshCenter =&gt; navMeshCenter;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public BossHealthSystem HealthSystem =&gt; healthSystem;&#10;        public BossSoulManager SoulManager =&gt; soulManager;&#10;        public List&lt;GameObject&gt; CurrentDecoys =&gt; currentDecoys;&#10;        &#10;        // Events&#10;        public System.Action&lt;int&gt; OnPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;&#10;        private void Awake()&#10;        {&#10;            InitializeComponents();&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeSystems();&#10;            StartBoss();&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            stateMachine?.Update();&#10;        }&#10;&#10;        private void InitializeComponents()&#10;        {&#10;            // Auto-find components if not assigned&#10;            if (navMeshAgent == null)&#10;                navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();&#10;            &#10;            if (animator == null)&#10;                animator = GetComponent&lt;Animator&gt;();&#10;            &#10;            if (audioSource == null)&#10;                audioSource = GetComponent&lt;AudioSource&gt;();&#10;            &#10;            if (player == null)&#10;                player = GameObject.FindGameObjectWithTag(&quot;Player&quot;)?.transform;&#10;        }&#10;&#10;        private void InitializeSystems()&#10;        {&#10;            // Initialize FSM&#10;            stateMachine = new BossStateMachine();&#10;            stateMachine.Initialize(this);&#10;            &#10;            // Initialize Health System&#10;            healthSystem = new BossHealthSystem(bossConfig.maxHealthPerPhase);&#10;            healthSystem.OnHealthChanged += OnHealthChanged;&#10;            healthSystem.OnPhaseHealthDepleted += OnPhaseCompleted;&#10;            &#10;            // Initialize Soul Manager&#10;            soulManager = new BossSoulManager(this);&#10;            &#10;            // Initialize UI Manager&#10;            uiManager = new BossUIManager(this);&#10;            &#10;            // Setup NavMesh&#10;            if (navMeshAgent != null)&#10;            {&#10;                navMeshAgent.speed = bossConfig.moveSpeed;&#10;                navMeshAgent.angularSpeed = bossConfig.rotationSpeed;&#10;            }&#10;        }&#10;&#10;        private void StartBoss()&#10;        {&#10;            // Trigger boss spawned event&#10;            BossEventSystem.Trigger(BossEventType.BossSpawned);&#10;            &#10;            // Start with Phase 1&#10;            ChangeToPhase(1);&#10;        }&#10;&#10;        private void OnHealthChanged(int newHealth, int maxHealth)&#10;        {&#10;            BossEventSystem.Trigger(BossEventType.HealthChanged, &#10;                new BossEventData { intValue = newHealth, floatValue = maxHealth });&#10;        }&#10;&#10;        private void OnPhaseCompleted()&#10;        {&#10;            if (currentPhase == 1)&#10;            {&#10;                ChangeToPhase(2);&#10;            }&#10;            else if (currentPhase == 2)&#10;            {&#10;                DefeatBoss();&#10;            }&#10;        }&#10;&#10;        public void ChangeToPhase(int newPhase)&#10;        {&#10;            currentPhase = newPhase;&#10;            healthSystem.ResetPhaseHealth();&#10;            &#10;            // Clear any existing decoys&#10;            ClearDecoys();&#10;            &#10;            // Trigger phase change event&#10;            BossEventSystem.Trigger(BossEventType.PhaseChanged, new BossEventData(newPhase));&#10;            OnPhaseChanged?.Invoke(newPhase);&#10;            &#10;            // Change to appropriate starting state&#10;            if (newPhase == 1)&#10;            {&#10;                stateMachine.ChangeState(new IdleState());&#10;            }&#10;            else if (newPhase == 2)&#10;            {&#10;                stateMachine.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public void TakeDamage(int damage = 1)&#10;        {&#10;            healthSystem.TakeDamage(damage);&#10;            stateMachine.OnTakeDamage();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossTakeDamage, new BossEventData(damage));&#10;            &#10;            // Play damage sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.damageSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.damageSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            newState.Initialize(this, bossConfig);&#10;            stateMachine.ChangeState(newState);&#10;        }&#10;&#10;        public void AddDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Add(decoy);&#10;        }&#10;&#10;        public void RemoveDecoy(GameObject decoy)&#10;        {&#10;            currentDecoys.Remove(decoy);&#10;        }&#10;&#10;        public void ClearDecoys()&#10;        {&#10;            foreach (var decoy in currentDecoys)&#10;            {&#10;                if (decoy != null)&#10;                    Destroy(decoy);&#10;            }&#10;            currentDecoys.Clear();&#10;        }&#10;&#10;        public void InterruptCurrentSkill()&#10;        {&#10;            if (stateMachine.CanInterruptCurrentState())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                &#10;                // Return to appropriate state based on phase&#10;                if (currentPhase == 1)&#10;                {&#10;                    ChangeState(new IdleState());&#10;                }&#10;                else&#10;                {&#10;                    ChangeState(new AngryState());&#10;                }&#10;            }&#10;        }&#10;&#10;        private void DefeatBoss()&#10;        {&#10;            // Trigger defeat events&#10;            BossEventSystem.Trigger(BossEventType.BossDefeated);&#10;            OnBossDefeated?.Invoke();&#10;            &#10;            // Change to cook state for phase 2&#10;            ChangeState(new CookState());&#10;            &#10;            // Play defeat sound&#10;            if (audioSource &amp;&amp; bossConfig.audioConfig.defeatSound)&#10;            {&#10;                audioSource.PlayOneShot(bossConfig.audioConfig.defeatSound, &#10;                    bossConfig.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public void PlayAnimation(string animationName)&#10;        {&#10;            // Replace animation calls with debug logs since no assets are available&#10;            Debug.Log($&quot;[Boss Animation] Playing animation: {animationName}&quot;);&#10;            &#10;            // Uncomment when animation assets are available:&#10;            // if (animator != null)&#10;            // {&#10;            //     animator.SetTrigger(animationName);&#10;            // }&#10;        }&#10;&#10;        public void PlaySound(AudioClip clip, float volume = 1f)&#10;        {&#10;            if (audioSource &amp;&amp; clip)&#10;            {&#10;                audioSource.PlayOneShot(clip, volume * bossConfig.audioConfig.masterVolume);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup&#10;            if (healthSystem != null)&#10;            {&#10;                healthSystem.OnHealthChanged -= OnHealthChanged;&#10;                healthSystem.OnPhaseHealthDepleted -= OnPhaseCompleted;&#10;            }&#10;            &#10;            ClearDecoys();&#10;            BossEventSystem.ClearAllListeners();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            if (bossConfig != null)&#10;            {&#10;                // Draw decoy spawn radius&#10;                Gizmos.color = Color.yellow;&#10;                DrawWireCircle(transform.position, bossConfig.phase1.decoySpawnRadius);&#10;                &#10;                // Draw soul spawn radius&#10;                Gizmos.color = Color.magenta;&#10;                DrawWireCircle(transform.position, bossConfig.soulConfig.soulSpawnRadius);&#10;                &#10;                // Draw phase 2 circle radius&#10;                if (navMeshCenter != null)&#10;                {&#10;                    Gizmos.color = Color.red;&#10;                    DrawWireCircle(navMeshCenter.position, bossConfig.phase2.circleRadius);&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Helper method to draw wire circle in XZ plane&#10;        /// &lt;/summary&gt;&#10;        private void DrawWireCircle(Vector3 center, float radius)&#10;        {&#10;            int segments = 32;&#10;            float angleStep = 360f / segments;&#10;            Vector3 prevPoint = center + new Vector3(radius, 0, 0);&#10;            &#10;            for (int i = 1; i &lt;= segments; i++)&#10;            {&#10;                float angle = angleStep * i * Mathf.Deg2Rad;&#10;                Vector3 newPoint = center + new Vector3(&#10;                    Mathf.Cos(angle) * radius, &#10;                    0, &#10;                    Mathf.Sin(angle) * radius&#10;                );&#10;                &#10;                Gizmos.DrawLine(prevPoint, newPoint);&#10;                prevPoint = newPoint;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossEventSystem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossEventSystem.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Hệ thống sự kiện riêng cho Boss, tách biệt với GameEventSystem&#10;    /// &lt;/summary&gt;&#10;    public static class BossEventSystem&#10;    {&#10;        private static Dictionary&lt;BossEventType, List&lt;Action&lt;BossEventData&gt;&gt;&gt; eventListeners = &#10;            new Dictionary&lt;BossEventType, List&lt;Action&lt;BossEventData&gt;&gt;&gt;();&#10;&#10;        /// &lt;summary&gt;&#10;        /// Đăng ký lắng nghe một sự kiện boss&#10;        /// &lt;/summary&gt;&#10;        public static void Subscribe(BossEventType eventType, Action&lt;BossEventData&gt; listener)&#10;        {&#10;            if (!eventListeners.ContainsKey(eventType))&#10;            {&#10;                eventListeners[eventType] = new List&lt;Action&lt;BossEventData&gt;&gt;();&#10;            }&#10;            &#10;            eventListeners[eventType].Add(listener);&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Hủy đăng ký lắng nghe sự kiện&#10;        /// &lt;/summary&gt;&#10;        public static void Unsubscribe(BossEventType eventType, Action&lt;BossEventData&gt; listener)&#10;        {&#10;            if (eventListeners.ContainsKey(eventType))&#10;            {&#10;                eventListeners[eventType].Remove(listener);&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Phát sự kiện boss&#10;        /// &lt;/summary&gt;&#10;        public static void Trigger(BossEventType eventType, BossEventData data = null)&#10;        {&#10;            if (eventListeners.ContainsKey(eventType))&#10;            {&#10;                foreach (var listener in eventListeners[eventType])&#10;                {&#10;                    try&#10;                    {&#10;                        listener?.Invoke(data);&#10;                    }&#10;                    catch (Exception e)&#10;                    {&#10;                        Debug.LogError($&quot;Error in BossEvent listener for {eventType}: {e.Message}&quot;);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        /// &lt;summary&gt;&#10;        /// Xóa tất cả listeners&#10;        /// &lt;/summary&gt;&#10;        public static void ClearAllListeners()&#10;        {&#10;            eventListeners.Clear();&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Các loại sự kiện boss&#10;    /// &lt;/summary&gt;&#10;    public enum BossEventType&#10;    {&#10;        // Phase Events&#10;        PhaseChanged,&#10;        BossSpawned,&#10;        BossDefeated,&#10;        &#10;        // State Events&#10;        StateChanged,&#10;        SkillCasted,&#10;        SkillInterrupted,&#10;        &#10;        // Combat Events&#10;        BossTakeDamage,&#10;        PlayerTakeDamage,&#10;        DecoyHit,&#10;        RealDecoyHit,&#10;        FakeDecoyHit,&#10;        &#10;        // Soul Events&#10;        SoulSpawned,&#10;        SoulDestroyed,&#10;        &#10;        // Skill-specific Events&#10;        LureStarted,&#10;        MockStarted,&#10;        DecoyStarted,&#10;        SoulStateStarted,&#10;        FearZoneCreated,&#10;        ScreamStarted,&#10;        &#10;        // UI Events&#10;        HealthChanged,&#10;        SkillCastProgress,&#10;        &#10;        // Fa Integration Events&#10;        RequestRadarSkill, // Yêu cầu Fa sử dụng Radar skill&#10;        RequestOtherSkill, // Yêu cầu Fa sử dụng skill khác&#10;        FaSkillUsed        // Fa đã sử dụng skill&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Dữ liệu kèm theo sự kiện boss&#10;    /// &lt;/summary&gt;&#10;    [Serializable]&#10;    public class BossEventData&#10;    {&#10;        public int intValue;&#10;        public float floatValue;&#10;        public string stringValue;&#10;        public Vector3 position;&#10;        public GameObject gameObject;&#10;        public object customData;&#10;&#10;        public BossEventData() { }&#10;&#10;        public BossEventData(int value)&#10;        {&#10;            intValue = value;&#10;        }&#10;&#10;        public BossEventData(float value)&#10;        {&#10;            floatValue = value;&#10;        }&#10;&#10;        public BossEventData(string value)&#10;        {&#10;            stringValue = value;&#10;        }&#10;&#10;        public BossEventData(Vector3 pos)&#10;        {&#10;            position = pos;&#10;        }&#10;&#10;        public BossEventData(GameObject obj)&#10;        {&#10;            gameObject = obj;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manager tổng thể cho Boss system - điểm tích hợp chính&#10;    /// &lt;/summary&gt;&#10;    public class BossManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Boss Setup&quot;)]&#10;        [SerializeField] private BossController bossController;&#10;        [SerializeField] private BossConfig bossConfig;&#10;        &#10;        [Header(&quot;UI Setup&quot;)]&#10;        [SerializeField] private GameObject bossHealthBarPrefab;&#10;        [SerializeField] private GameObject skillCastBarPrefab;&#10;        [SerializeField] private GameObject playerHealthBarPrefab;&#10;        &#10;        [Header(&quot;Player Settings&quot;)]&#10;        [SerializeField] private int playerMaxHealth = 3;&#10;        &#10;        private BossHealthBar bossHealthBar;&#10;        private BossSkillCastBar skillCastBar;&#10;        private PlayerHealthBar playerHealthBar;&#10;        &#10;        public static BossManager Instance { get; private set; }&#10;        &#10;        // Events for external systems&#10;        public System.Action&lt;int&gt; OnBossPhaseChanged;&#10;        public System.Action OnBossDefeated;&#10;        public System.Action&lt;int&gt; OnPlayerHealthChanged;&#10;&#10;        private void Awake()&#10;        {&#10;            // Singleton pattern&#10;            if (Instance != null &amp;&amp; Instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;                return;&#10;            }&#10;            Instance = this;&#10;        }&#10;&#10;        private void Start()&#10;        {&#10;            InitializeBossSystem();&#10;        }&#10;&#10;        private void InitializeBossSystem()&#10;        {&#10;            // Setup boss controller if not assigned&#10;            if (bossController == null)&#10;            {&#10;                bossController = FindObjectOfType&lt;BossController&gt;();&#10;            }&#10;            &#10;            if (bossController == null)&#10;            {&#10;                Debug.LogError(&quot;BossController not found! Please assign it in the inspector.&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Initialize UI components&#10;            InitializeUI();&#10;            &#10;            // Register for boss events&#10;            RegisterBossEvents();&#10;            &#10;            // Register for Fa integration events&#10;            RegisterFaIntegrationEvents();&#10;            &#10;            Debug.Log(&quot;Boss System initialized successfully!&quot;);&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Create Boss Health Bar&#10;            if (bossHealthBarPrefab != null)&#10;            {&#10;                GameObject healthBarGO = Instantiate(bossHealthBarPrefab);&#10;                bossHealthBar = healthBarGO.GetComponent&lt;BossHealthBar&gt;();&#10;                if (bossHealthBar == null)&#10;                    bossHealthBar = healthBarGO.AddComponent&lt;BossHealthBar&gt;();&#10;                &#10;                bossHealthBar.Initialize(bossController);&#10;            }&#10;            &#10;            // Create Skill Cast Bar&#10;            if (skillCastBarPrefab != null)&#10;            {&#10;                GameObject castBarGO = Instantiate(skillCastBarPrefab);&#10;                skillCastBar = castBarGO.GetComponent&lt;BossSkillCastBar&gt;();&#10;                if (skillCastBar == null)&#10;                    skillCastBar = castBarGO.AddComponent&lt;BossSkillCastBar&gt;();&#10;                &#10;                skillCastBar.Initialize(bossController);&#10;            }&#10;            &#10;            // Create Player Health Bar&#10;            if (playerHealthBarPrefab != null)&#10;            {&#10;                GameObject playerBarGO = Instantiate(playerHealthBarPrefab);&#10;                playerHealthBar = playerBarGO.GetComponent&lt;PlayerHealthBar&gt;();&#10;                if (playerHealthBar == null)&#10;                    playerHealthBar = playerBarGO.AddComponent&lt;PlayerHealthBar&gt;();&#10;                &#10;                playerHealthBar.Initialize(playerMaxHealth);&#10;            }&#10;        }&#10;&#10;        private void RegisterBossEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Subscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Subscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Subscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;        }&#10;&#10;        private void RegisterFaIntegrationEvents()&#10;        {&#10;            // Listen for Fa skill requests&#10;            BossEventSystem.Subscribe(BossEventType.RequestRadarSkill, OnRequestRadarSkill);&#10;            BossEventSystem.Subscribe(BossEventType.RequestOtherSkill, OnRequestOtherSkill);&#10;        }&#10;&#10;        private void OnPhaseChanged(BossEventData data)&#10;        {&#10;            int newPhase = data.intValue;&#10;            OnBossPhaseChanged?.Invoke(newPhase);&#10;            &#10;            Debug.Log($&quot;Boss entered Phase {newPhase}&quot;);&#10;        }&#10;&#10;        private void OnBossDefeatedEvent(BossEventData data)&#10;        {&#10;            OnBossDefeated?.Invoke();&#10;            Debug.Log(&quot;Boss has been defeated!&quot;);&#10;        }&#10;&#10;        private void OnPlayerTakeDamageEvent(BossEventData data)&#10;        {&#10;            int damage = data.intValue;&#10;            OnPlayerHealthChanged?.Invoke(damage);&#10;        }&#10;&#10;        private void OnBossSpawned(BossEventData data)&#10;        {&#10;            Debug.Log(&quot;Boss has spawned and is ready for battle!&quot;);&#10;        }&#10;&#10;        private void OnRequestRadarSkill(BossEventData data)&#10;        {&#10;            // Request Fa to use Radar skill to destroy souls&#10;            Debug.Log(&quot;Requesting Fa to use Radar skill to destroy souls&quot;);&#10;            &#10;            // This will be handled by Fa's system&#10;            // For now, we can simulate the request&#10;            RequestFaSkill(&quot;Radar&quot;);&#10;        }&#10;&#10;        private void OnRequestOtherSkill(BossEventData data)&#10;        {&#10;            string skillName = data.stringValue ?? &quot;Unknown&quot;;&#10;            Debug.Log($&quot;Requesting Fa to use skill: {skillName}&quot;);&#10;            &#10;            RequestFaSkill(skillName);&#10;        }&#10;&#10;        private void RequestFaSkill(string skillName)&#10;        {&#10;            // This method will be called by Fa's system when skill is used&#10;            // For now, we can simulate skill usage for testing&#10;            &#10;            // In actual implementation, this would communicate with Fa's skill system&#10;            // Example: FaSkillManager.Instance.RequestSkill(skillName, OnFaSkillComplete);&#10;        }&#10;&#10;        // This method should be called by Fa's system when a skill is completed&#10;        public void OnFaSkillCompleted(string skillName, bool success)&#10;        {&#10;            if (success)&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.FaSkillUsed, &#10;                    new BossEventData { stringValue = skillName });&#10;                &#10;                Debug.Log($&quot;Fa successfully used skill: {skillName}&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.Log($&quot;Fa failed to use skill: {skillName}&quot;);&#10;            }&#10;        }&#10;&#10;        // Public methods for external interaction&#10;        public void PlayerAttackBoss()&#10;        {&#10;            if (bossController != null)&#10;            {&#10;                bossController.TakeDamage(1);&#10;            }&#10;        }&#10;&#10;        public void PlayerAttackDecoy(GameObject decoy, bool hitReal)&#10;        {&#10;            var decoyBehavior = decoy.GetComponent&lt;DecoyBehavior&gt;();&#10;            if (decoyBehavior != null)&#10;            {&#10;                if (hitReal)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.RealDecoyHit);&#10;                    bossController.TakeDamage(1);&#10;                }&#10;                else&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.FakeDecoyHit);&#10;                    BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                }&#10;            }&#10;        }&#10;&#10;        public void InterruptBossSkill()&#10;        {&#10;            if (bossController != null)&#10;            {&#10;                bossController.InterruptCurrentSkill();&#10;            }&#10;        }&#10;&#10;        // Heal player (for testing or power-ups)&#10;        public void HealPlayer(int amount)&#10;        {&#10;            if (playerHealthBar != null)&#10;            {&#10;                playerHealthBar.HealPlayer(amount);&#10;            }&#10;        }&#10;&#10;        // Get current boss state for external systems&#10;        public string GetCurrentBossState()&#10;        {&#10;            if (bossController != null &amp;&amp; bossController.GetComponent&lt;BossStateMachine&gt;() != null)&#10;            {&#10;                return bossController.GetComponent&lt;BossStateMachine&gt;().CurrentState?.GetType().Name ?? &quot;Unknown&quot;;&#10;            }&#10;            return &quot;No Boss&quot;;&#10;        }&#10;&#10;        // Get current boss phase&#10;        public int GetCurrentBossPhase()&#10;        {&#10;            return bossController != null ? bossController.CurrentPhase : 0;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            // Cleanup events&#10;            BossEventSystem.Unsubscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossDefeated, OnBossDefeatedEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamageEvent);&#10;            BossEventSystem.Unsubscribe(BossEventType.BossSpawned, OnBossSpawned);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestRadarSkill, OnRequestRadarSkill);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestOtherSkill, OnRequestOtherSkill);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossStateMachine.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossStateMachine.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Base class cho tất cả các state của boss&#10;    /// &lt;/summary&gt;&#10;    public abstract class BossState&#10;    {&#10;        protected BossController bossController;&#10;        protected BossConfig config;&#10;        &#10;        public abstract void Enter();&#10;        public abstract void Update();&#10;        public abstract void Exit();&#10;        public abstract void OnTakeDamage();&#10;        public abstract bool CanBeInterrupted();&#10;&#10;        public virtual void Initialize(BossController controller, BossConfig bossConfig)&#10;        {&#10;            bossController = controller;&#10;            config = bossConfig;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Finite State Machine cho Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossStateMachine&#10;    {&#10;        private BossState currentState;&#10;        private BossController bossController;&#10;        &#10;        public BossState CurrentState =&gt; currentState;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            bossController = controller;&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            currentState?.Exit();&#10;            &#10;            BossState previousState = currentState;&#10;            currentState = newState;&#10;            currentState?.Enter();&#10;            &#10;            // Trigger state change event&#10;            BossEventSystem.Trigger(BossEventType.StateChanged, &#10;                new BossEventData { stringValue = newState?.GetType().Name });&#10;        }&#10;&#10;        public void Update()&#10;        {&#10;            currentState?.Update();&#10;        }&#10;&#10;        public void OnTakeDamage()&#10;        {&#10;            currentState?.OnTakeDamage();&#10;        }&#10;&#10;        public bool CanInterruptCurrentState()&#10;        {&#10;            return currentState?.CanBeInterrupted() ?? false;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss.States.Phase1;&#10;using Code.Boss.States.Phase2;&#10;using Code.Boss.States.Shared;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Base class cho tất cả các state của boss&#10;    /// &lt;/summary&gt;&#10;    public abstract class BossState&#10;    {&#10;        protected BossController bossController;&#10;        protected BossConfig config;&#10;        &#10;        public abstract void Enter();&#10;        public abstract void Update();&#10;        public abstract void Exit();&#10;        public abstract void OnTakeDamage();&#10;        public abstract bool CanBeInterrupted();&#10;&#10;        public virtual void Initialize(BossController controller, BossConfig bossConfig)&#10;        {&#10;            bossController = controller;&#10;            config = bossConfig;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Finite State Machine cho Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossStateMachine&#10;    {&#10;        private BossState currentState;&#10;        private BossController bossController;&#10;        &#10;        public BossState CurrentState =&gt; currentState;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            bossController = controller;&#10;        }&#10;&#10;        public void ChangeState(BossState newState)&#10;        {&#10;            currentState?.Exit();&#10;            &#10;            BossState previousState = currentState;&#10;            currentState = newState;&#10;            currentState?.Enter();&#10;            &#10;            // Trigger state change event&#10;            BossEventSystem.Trigger(BossEventType.StateChanged, &#10;                new BossEventData { stringValue = newState?.GetType().Name });&#10;        }&#10;&#10;        public void Update()&#10;        {&#10;            currentState?.Update();&#10;        }&#10;&#10;        public void OnTakeDamage()&#10;        {&#10;            currentState?.OnTakeDamage();&#10;        }&#10;&#10;        public bool CanInterruptCurrentState()&#10;        {&#10;            return currentState?.CanBeInterrupted() ?? false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossSubSystems.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossSubSystems.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý hệ thống máu của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthSystem&#10;    {&#10;        private int maxHealthPerPhase;&#10;        private int currentHealth;&#10;        private int currentPhase = 1;&#10;        &#10;        public int CurrentHealth =&gt; currentHealth;&#10;        public int MaxHealthPerPhase =&gt; maxHealthPerPhase;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public float HealthPercentage =&gt; (float)currentHealth / maxHealthPerPhase;&#10;        &#10;        public event Action&lt;int, int&gt; OnHealthChanged; // current, max&#10;        public event Action OnPhaseHealthDepleted;&#10;&#10;        public BossHealthSystem(int maxHealthPerPhase)&#10;        {&#10;            this.maxHealthPerPhase = maxHealthPerPhase;&#10;            currentHealth = maxHealthPerPhase;&#10;        }&#10;&#10;        public void TakeDamage(int damage)&#10;        {&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPhaseHealthDepleted?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void ResetPhaseHealth()&#10;        {&#10;            currentHealth = maxHealthPerPhase;&#10;            currentPhase++;&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealthPerPhase, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý Soul entities&#10;    /// &lt;/summary&gt;&#10;    public class BossSoulManager&#10;    {&#10;        private BossController bossController;&#10;        private List&lt;GameObject&gt; activeSouls = new List&lt;GameObject&gt;();&#10;        &#10;        public int ActiveSoulCount =&gt; activeSouls.Count;&#10;        public int MaxSouls =&gt; bossController.Config.soulConfig.maxSouls;&#10;&#10;        public BossSoulManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            &#10;            // Listen for Fa skill usage to destroy souls&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public void SpawnSoul()&#10;        {&#10;            if (activeSouls.Count &gt;= MaxSouls) return;&#10;            &#10;            var soulConfig = bossController.Config.soulConfig;&#10;            if (soulConfig.soulPrefab == null) return;&#10;            &#10;            // Find spawn position around boss&#10;            Vector3 spawnPos = GetRandomSpawnPosition();&#10;            GameObject soul = GameObject.Instantiate(soulConfig.soulPrefab, spawnPos, Quaternion.identity);&#10;            &#10;            // Setup soul behavior&#10;            var soulBehavior = soul.GetComponent&lt;SoulBehavior&gt;();&#10;            if (soulBehavior == null)&#10;                soulBehavior = soul.AddComponent&lt;SoulBehavior&gt;();&#10;            &#10;            soulBehavior.Initialize(bossController.Player, soulConfig);&#10;            &#10;            activeSouls.Add(soul);&#10;            BossEventSystem.Trigger(BossEventType.SoulSpawned, new BossEventData(soul));&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition()&#10;        {&#10;            var config = bossController.Config.soulConfig;&#10;            Vector3 randomDirection = UnityEngine.Random.insideUnitCircle.normalized;&#10;            Vector3 spawnPos = bossController.transform.position + &#10;                              new Vector3(randomDirection.x, 0, randomDirection.y) * config.soulSpawnRadius;&#10;            return spawnPos;&#10;        }&#10;&#10;        public void DestroyAllSouls()&#10;        {&#10;            foreach (var soul in activeSouls)&#10;            {&#10;                if (soul != null)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.SoulDestroyed, new BossEventData(soul));&#10;                    GameObject.Destroy(soul);&#10;                }&#10;            }&#10;            activeSouls.Clear();&#10;        }&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            // Assuming Fa's radar skill destroys all souls&#10;            if (data.stringValue == &quot;Radar&quot;)&#10;            {&#10;                DestroyAllSouls();&#10;            }&#10;        }&#10;&#10;        public void CleanupDestroyed()&#10;        {&#10;            activeSouls.RemoveAll(soul =&gt; soul == null);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý UI của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossUIManager&#10;    {&#10;        private BossController bossController;&#10;        private BossHealthBar bossHealthBar;&#10;        private SkillCastBar skillCastBar;&#10;        &#10;        public BossUIManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            InitializeUI();&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Tạo UI elements sẽ được implement trong các class riêng&#10;            CreateBossHealthBar();&#10;            CreateSkillCastBar();&#10;        }&#10;&#10;        private void CreateBossHealthBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;&#10;        private void CreateSkillCastBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý hệ thống máu của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthSystem&#10;    {&#10;        private int maxHealthPerPhase;&#10;        private int currentHealth;&#10;        private int currentPhase = 1;&#10;        &#10;        public int CurrentHealth =&gt; currentHealth;&#10;        public int MaxHealthPerPhase =&gt; maxHealthPerPhase;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public float HealthPercentage =&gt; (float)currentHealth / maxHealthPerPhase;&#10;        &#10;        public event Action&lt;int, int&gt; OnHealthChanged; // current, max&#10;        public event Action OnPhaseHealthDepleted;&#10;&#10;        public BossHealthSystem(int maxHealthPerPhase)&#10;        {&#10;            this.maxHealthPerPhase = maxHealthPerPhase;&#10;            currentHealth = maxHealthPerPhase;&#10;        }&#10;&#10;        public void TakeDamage(int damage)&#10;        {&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPhaseHealthDepleted?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void ResetPhaseHealth()&#10;        {&#10;            currentHealth = maxHealthPerPhase;&#10;            currentPhase++;&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealthPerPhase, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý Soul entities&#10;    /// &lt;/summary&gt;&#10;    public class BossSoulManager&#10;    {&#10;        private BossController bossController;&#10;        private List&lt;GameObject&gt; activeSouls = new List&lt;GameObject&gt;();&#10;        &#10;        public int ActiveSoulCount =&gt; activeSouls.Count;&#10;        public int MaxSouls =&gt; bossController.Config.soulConfig.maxSouls;&#10;&#10;        public BossSoulManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            &#10;            // Listen for Fa skill usage to destroy souls&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public void SpawnSoul()&#10;        {&#10;            if (activeSouls.Count &gt;= MaxSouls) return;&#10;            &#10;            var soulConfig = bossController.Config.soulConfig;&#10;            if (soulConfig.soulPrefab == null) return;&#10;            &#10;            // Find spawn position around boss&#10;            Vector3 spawnPos = GetRandomSpawnPosition();&#10;            GameObject soul = GameObject.Instantiate(soulConfig.soulPrefab, spawnPos, Quaternion.identity);&#10;            &#10;            // Setup soul behavior&#10;            var soulBehavior = soul.GetComponent&lt;SoulBehavior&gt;();&#10;            if (soulBehavior == null)&#10;                soulBehavior = soul.AddComponent&lt;SoulBehavior&gt;();&#10;            &#10;            soulBehavior.Initialize(bossController.Player, soulConfig);&#10;            &#10;            activeSouls.Add(soul);&#10;            BossEventSystem.Trigger(BossEventType.SoulSpawned, new BossEventData(soul));&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition()&#10;        {&#10;            var config = bossController.Config.soulConfig;&#10;            Vector3 randomDirection = UnityEngine.Random.insideUnitCircle.normalized;&#10;            Vector3 spawnPos = bossController.transform.position + &#10;                              new Vector3(randomDirection.x, 0, randomDirection.y) * config.soulSpawnRadius;&#10;            return spawnPos;&#10;        }&#10;&#10;        public void DestroyAllSouls()&#10;        {&#10;            foreach (var soul in activeSouls)&#10;            {&#10;                if (soul != null)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.SoulDestroyed, new BossEventData(soul));&#10;                    GameObject.Destroy(soul);&#10;                }&#10;            }&#10;            activeSouls.Clear();&#10;        }&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            // Assuming Fa's radar skill destroys all souls&#10;            if (data.stringValue == &quot;Radar&quot;)&#10;            {&#10;                DestroyAllSouls();&#10;            }&#10;        }&#10;&#10;        public void CleanupDestroyed()&#10;        {&#10;            activeSouls.RemoveAll(soul =&gt; soul == null);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý UI của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossUIManager&#10;    {&#10;        private BossController bossController;&#10;        private BossHealthBar bossHealthBar;&#10;        private BossSkillCastBar skillCastBar;&#10;        &#10;        public BossUIManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            InitializeUI();&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Tạo UI elements sẽ được implement trong các class riêng&#10;            CreateBossHealthBar();&#10;            CreateSkillCastBar();&#10;        }&#10;&#10;        private void CreateBossHealthBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;&#10;        private void CreateSkillCastBar()&#10;        {&#10;            // This will be implemented with actual UI components&#10;            var uiConfig = bossController.Config.uiConfig;&#10;            // TODO: Create actual UI GameObject and setup&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/BossUIComponents.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/BossUIComponents.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Thanh máu của Boss ở giữa trên màn hình&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthBar : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Components&quot;)]&#10;        [SerializeField] private Canvas canvas;&#10;        [SerializeField] private Slider healthSlider;&#10;        [SerializeField] private TextMeshProUGUI healthText;&#10;        [SerializeField] private TextMeshProUGUI phaseText;&#10;        &#10;        private BossController bossController;&#10;        private UIConfig uiConfig;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            uiConfig = controller.Config.uiConfig;&#10;            &#10;            SetupUI();&#10;            RegisterEvents();&#10;        }&#10;&#10;        private void SetupUI()&#10;        {&#10;            // Create canvas if not assigned&#10;            if (canvas == null)&#10;            {&#10;                CreateCanvas();&#10;            }&#10;            &#10;            // Position at top center of screen&#10;            RectTransform rectTransform = GetComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(0.5f, 1f);&#10;            rectTransform.anchorMax = new Vector2(0.5f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(0, -50); // 50 pixels from top&#10;            rectTransform.sizeDelta = uiConfig.healthBarSize;&#10;            &#10;            // Setup health slider&#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.maxValue = bossController.Config.maxHealthPerPhase;&#10;                healthSlider.value = bossController.Config.maxHealthPerPhase;&#10;                &#10;                // Set colors&#10;                var fillImage = healthSlider.fillRect.GetComponent&lt;Image&gt;();&#10;                if (fillImage != null)&#10;                {&#10;                    fillImage.color = uiConfig.bossHealthColor;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void CreateCanvas()&#10;        {&#10;            GameObject canvasGO = new GameObject(&quot;BossHealthCanvas&quot;);&#10;            canvas = canvasGO.AddComponent&lt;Canvas&gt;();&#10;            canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;            canvas.sortingOrder = 100;&#10;            &#10;            canvasGO.AddComponent&lt;CanvasScaler&gt;();&#10;            canvasGO.AddComponent&lt;GraphicRaycaster&gt;();&#10;        }&#10;&#10;        private void RegisterEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.HealthChanged, OnHealthChanged);&#10;            BossEventSystem.Subscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;        }&#10;&#10;        private void OnHealthChanged(BossEventData data)&#10;        {&#10;            int currentHealth = data.intValue;&#10;            int maxHealth = (int)data.floatValue;&#10;            &#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.maxValue = maxHealth;&#10;                healthSlider.value = currentHealth;&#10;            }&#10;            &#10;            if (healthText != null)&#10;            {&#10;                healthText.text = $&quot;{currentHealth}/{maxHealth}&quot;;&#10;            }&#10;        }&#10;&#10;        private void OnPhaseChanged(BossEventData data)&#10;        {&#10;            int newPhase = data.intValue;&#10;            &#10;            if (phaseText != null)&#10;            {&#10;                phaseText.text = $&quot;Phase {newPhase}&quot;;&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.HealthChanged, OnHealthChanged);&#10;            BossEventSystem.Unsubscribe(BossEventType.PhaseChanged, OnPhaseChanged);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Thanh cast skill ở dưới thanh máu boss&#10;    /// &lt;/summary&gt;&#10;    public class BossSkillCastBar : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Components&quot;)]&#10;        [SerializeField] private Slider castSlider;&#10;        [SerializeField] private TextMeshProUGUI skillNameText;&#10;        [SerializeField] private GameObject castBarContainer;&#10;        &#10;        private UIConfig uiConfig;&#10;        private bool isVisible = false;&#10;&#10;        public void Initialize(BossController controller)&#10;        {&#10;            uiConfig = controller.Config.uiConfig;&#10;            &#10;            SetupUI();&#10;            RegisterEvents();&#10;            &#10;            // Hide initially&#10;            SetVisible(false);&#10;        }&#10;&#10;        private void SetupUI()&#10;        {&#10;            // Position below boss health bar&#10;            RectTransform rectTransform = GetComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(0.5f, 1f);&#10;            rectTransform.anchorMax = new Vector2(0.5f, 1f);&#10;            rectTransform.anchoredPosition = new Vector2(0, -100); // Below health bar&#10;            rectTransform.sizeDelta = uiConfig.skillCastBarSize;&#10;            &#10;            // Setup cast slider&#10;            if (castSlider != null)&#10;            {&#10;                castSlider.maxValue = 1f;&#10;                castSlider.value = 0f;&#10;                &#10;                // Set colors&#10;                var fillImage = castSlider.fillRect.GetComponent&lt;Image&gt;();&#10;                if (fillImage != null)&#10;                {&#10;                    fillImage.color = uiConfig.skillCastColor;&#10;                }&#10;            }&#10;        }&#10;&#10;        private void RegisterEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.SkillCasted, OnSkillCasted);&#10;            BossEventSystem.Subscribe(BossEventType.SkillCastProgress, OnSkillCastProgress);&#10;            BossEventSystem.Subscribe(BossEventType.SkillInterrupted, OnSkillInterrupted);&#10;            BossEventSystem.Subscribe(BossEventType.StateChanged, OnStateChanged);&#10;        }&#10;&#10;        private void OnSkillCasted(BossEventData data)&#10;        {&#10;            SetVisible(true);&#10;            &#10;            if (skillNameText != null &amp;&amp; data != null)&#10;            {&#10;                skillNameText.text = data.stringValue ?? &quot;Casting Skill...&quot;;&#10;            }&#10;            &#10;            if (castSlider != null)&#10;            {&#10;                castSlider.value = 0f;&#10;            }&#10;        }&#10;&#10;        private void OnSkillCastProgress(BossEventData data)&#10;        {&#10;            if (castSlider != null &amp;&amp; isVisible)&#10;            {&#10;                castSlider.value = data.floatValue;&#10;            }&#10;        }&#10;&#10;        private void OnSkillInterrupted(BossEventData data)&#10;        {&#10;            SetVisible(false);&#10;        }&#10;&#10;        private void OnStateChanged(BossEventData data)&#10;        {&#10;            // Hide cast bar when state changes (skill completed)&#10;            if (isVisible)&#10;            {&#10;                SetVisible(false);&#10;            }&#10;        }&#10;&#10;        private void SetVisible(bool visible)&#10;        {&#10;            isVisible = visible;&#10;            if (castBarContainer != null)&#10;            {&#10;                castBarContainer.SetActive(visible);&#10;            }&#10;            else&#10;            {&#10;                gameObject.SetActive(visible);&#10;            }&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.SkillCasted, OnSkillCasted);&#10;            BossEventSystem.Unsubscribe(BossEventType.SkillCastProgress, OnSkillCastProgress);&#10;            BossEventSystem.Unsubscribe(BossEventType.SkillInterrupted, OnSkillInterrupted);&#10;            BossEventSystem.Unsubscribe(BossEventType.StateChanged, OnStateChanged);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Thanh máu người chơi ở giữa dưới màn hình&#10;    /// &lt;/summary&gt;&#10;    public class PlayerHealthBar : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Components&quot;)]&#10;        [SerializeField] private Slider healthSlider;&#10;        [SerializeField] private TextMeshProUGUI healthText;&#10;        &#10;        private int maxHealth = 3; // Default player health&#10;        private int currentHealth = 3;&#10;&#10;        public void Initialize(int playerMaxHealth)&#10;        {&#10;            maxHealth = playerMaxHealth;&#10;            currentHealth = playerMaxHealth;&#10;            &#10;            SetupUI();&#10;            RegisterEvents();&#10;        }&#10;&#10;        private void SetupUI()&#10;        {&#10;            // Position at bottom center of screen&#10;            RectTransform rectTransform = GetComponent&lt;RectTransform&gt;();&#10;            rectTransform.anchorMin = new Vector2(0.5f, 0f);&#10;            rectTransform.anchorMax = new Vector2(0.5f, 0f);&#10;            rectTransform.anchoredPosition = new Vector2(0, 50); // 50 pixels from bottom&#10;            &#10;            // Setup health slider&#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.maxValue = maxHealth;&#10;                healthSlider.value = currentHealth;&#10;                &#10;                // Set green color for player health&#10;                var fillImage = healthSlider.fillRect.GetComponent&lt;Image&gt;();&#10;                if (fillImage != null)&#10;                {&#10;                    fillImage.color = Color.green;&#10;                }&#10;            }&#10;            &#10;            UpdateHealthText();&#10;        }&#10;&#10;        private void RegisterEvents()&#10;        {&#10;            BossEventSystem.Subscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamage);&#10;        }&#10;&#10;        private void OnPlayerTakeDamage(BossEventData data)&#10;        {&#10;            int damage = data.intValue;&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            &#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.value = currentHealth;&#10;            }&#10;            &#10;            UpdateHealthText();&#10;            &#10;            // Check if player is defeated&#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPlayerDefeated();&#10;            }&#10;        }&#10;&#10;        private void UpdateHealthText()&#10;        {&#10;            if (healthText != null)&#10;            {&#10;                healthText.text = $&quot;{currentHealth}/{maxHealth}&quot;;&#10;            }&#10;        }&#10;&#10;        private void OnPlayerDefeated()&#10;        {&#10;            // Handle player defeat&#10;            Debug.Log(&quot;Player Defeated!&quot;);&#10;            // This could trigger game over screen, respawn, etc.&#10;        }&#10;&#10;        public void HealPlayer(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealth, currentHealth + amount);&#10;            &#10;            if (healthSlider != null)&#10;            {&#10;                healthSlider.value = currentHealth;&#10;            }&#10;            &#10;            UpdateHealthText();&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.PlayerTakeDamage, OnPlayerTakeDamage);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossConfig.cs" />
              <option name="originalContent" value="using System;&#10;using FMODUnity;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Cấu hình toàn bộ boss - File config duy nhất để điều chỉnh toàn bộ boss&#10;    /// &lt;/summary&gt;&#10;    [CreateAssetMenu(fileName = &quot;BossConfig&quot;, menuName = &quot;Boss/Boss Configuration&quot;)]&#10;    public class BossConfig : ScriptableObject&#10;    {&#10;        [Header(&quot;Debug&quot;)]&#10;        [Tooltip(&quot;Chọn phase để test nhanh. None: Bình thường, Phase1: Phase 1, Phase2: Phase 2, ...&quot;)]&#10;        public BossDebugPhase debugStartPhase = BossDebugPhase.None;&#10;     &#10;        [Header(&quot;Prefab Settings&quot;)]&#10;        [Tooltip(&quot;Prefab của boss để spawn lại khi cần reset&quot;)]&#10;        public GameObject bossPrefab;&#10;        [Tooltip(&quot;Prefab memory fragment rớt ra khi boss chết&quot;)]&#10;        public GameObject memoryFragmentPrefab;&#10;        [Tooltip(&quot;Effect xung quanh memory fragment&quot;)]&#10;        public GameObject memoryFragmentEffectPrefab;&#10;        &#10;        [Header(&quot;General Boss Settings&quot;)]&#10;        public int maxHealthPerPhase = 3;&#10;        public float moveSpeed = 5f;&#10;        public float rotationSpeed = 90f;&#10;        &#10;        [Header(&quot;Phase 1 Settings&quot;)]&#10;        [Space]&#10;        public Phase1Config phase1;&#10;        &#10;        [Header(&quot;Phase 2 Settings&quot;)]&#10;        [Space]&#10;        public Phase2Config phase2;&#10;        &#10;        [Header(&quot;Soul Settings&quot;)]&#10;        [Space]&#10;        public SoulConfig soulConfig;&#10;        &#10;        [Header(&quot;UI Settings&quot;)]&#10;        [Space]&#10;        public UIConfig uiConfig;&#10;        &#10;        [Header(&quot;Audio Settings&quot;)]&#10;        [Space]&#10;        public AudioConfig audioConfig;&#10;        &#10;        [Header(&quot;FMOD Studio Settings&quot;)]&#10;        [Space]&#10;        public FMODAudioConfig fmodAudioConfig;&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase1Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float idleDuration = 2f;&#10;        public float lureDuration = 3f;&#10;        public float mockDuration = 2f;&#10;        public float decoyCastTime = 2f;&#10;        public float decoyDuration = 10f;&#10;        public float soulStateCastTime = 1.5f;&#10;        &#10;        [Header(&quot;Lure State&quot;)]&#10;        public float lureDistance = 5f;&#10;        public float lureApproachSpeed = 3f;&#10;        public float lureRetreatSpeed = 4f;&#10;        &#10;        [Header(&quot;Decoy State&quot;)]&#10;        public float decoyMoveSpeed = 2f;&#10;        public int decoyCount = 2; // 1 thật, 1 giả&#10;        public float decoySpawnRadius = 8f;&#10;        public GameObject decoyPrefab; // Prefab cho decoy&#10;        public GameObject decoySpawnEffectPrefab; // Prefab hiệu ứng khi spawn decoy&#10;        public GameObject realDecoyRevealEffectPrefab; // Prefab hiệu ứng khi reveal decoy thật&#10;    }&#10;&#10;    [Serializable]&#10;    public class Phase2Config&#10;    {&#10;        [Header(&quot;State Durations&quot;)]&#10;        public float angryMoveDuration = 5f;&#10;        public float fearZoneCastTime = 2f;&#10;        public float fearZoneDuration = 8f;&#10;        public float screamCastTime = 3f;&#10;        public float screamDuration = 5f;&#10;        public float cookStateDuration = 3f;&#10;        &#10;        [Header(&quot;Angry State&quot;)]&#10;        public float angryMoveSpeed = 3f;&#10;        public float circleRadius = 10f;&#10;        &#10;        [Header(&quot;Fear Zone&quot;)]&#10;        public float fearZoneRadius = 3f;&#10;        public GameObject fearZoneCastEffectPrefab; // Prefab hiệu ứng khi cast skill&#10;        public GameObject fearZoneZoneEffectPrefab; // Prefab hiệu ứng khi zone xuất hiện&#10;        &#10;        [Header(&quot;Scream State&quot;)]&#10;        public float screenShakeIntensity = 1f;&#10;        public float visionShrinkAmount = 0.5f;&#10;    }&#10;&#10;    [Serializable]&#10;    public class SoulConfig&#10;    {&#10;        public int maxSouls = 2;&#10;        public float soulMoveSpeed = 4f;&#10;        public float soulSpawnRadius = 15f;&#10;        public float soulFollowDistance = 1f;&#10;        public GameObject soulPrefab;&#10;        public GameObject soulSpawnEffectPrefab; // Prefab hiệu ứng khi spawn soul&#10;    }&#10;&#10;    [Serializable]&#10;    public class UIConfig&#10;    {&#10;        [Header(&quot;Colors&quot;)]&#10;        public Color bossHealthColor = Color.red;&#10;        public Color playerHealthColor = Color.green;&#10;        public Color skillCastColor = Color.yellow;&#10;        &#10;        [Header(&quot;Animation Settings&quot;)]&#10;        public float uiAnimationSpeed = 1f;                                                                     // Tốc độ animation chung cho UI&#10;        public AnimationCurve uiAnimationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);          // Curve cho smooth animation&#10;    }&#10;&#10;    [Serializable]&#10;    public class AudioConfig&#10;    {&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#10;        public AudioClip mockLaughSound;&#10;        public AudioClip decoySpawnSound;&#10;        public AudioClip soulSpawnSound;&#10;        &#10;        [Header(&quot;Phase 2 Audio&quot;)]&#10;        public AudioClip screamSound;&#10;        public AudioClip fearZoneSound;&#10;        public AudioClip heartbeatSound;&#10;        &#10;        [Header(&quot;General Audio&quot;)]&#10;        public AudioClip phaseChangeSound;&#10;        public AudioClip damageSound;&#10;        public AudioClip defeatSound;&#10;        &#10;        [Header(&quot;Volume Settings&quot;)]&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#10;        [Range(0f, 1f)] public float sfxVolume = 0.8f;&#10;        [Range(0f, 1f)] public float ambientVolume = 0.6f;&#10;    }&#10;    &#10;    [Serializable]&#10;    public class FMODAudioConfig&#10;    {&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#10;        public EventReference mockLaughEvent;&#10;        public EventReference decoySpawnEvent;&#10;        public EventReference soulSpawnEvent;&#10;        [Header(&quot;Phase 2 Audio&quot;)]&#10;        public EventReference screamEvent;&#10;        public EventReference fearZoneEvent;&#10;        public EventReference heartbeatEvent;&#10;        [Header(&quot;General Audio&quot;)]&#10;        public EventReference phaseChangeEvent;&#10;        public EventReference damageEvent;&#10;        public EventReference defeatEvent;&#10;    }&#10;&#10;    public enum BossDebugPhase&#10;    {&#10;        None = -1,&#10;        Phase1 = 0,&#10;        Phase2 = 1&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using FMODUnity;&#13;&#10;using UnityEngine;&#13;&#10;&#13;&#10;namespace Code.Boss&#13;&#10;{&#13;&#10;    /// &lt;summary&gt;&#13;&#10;    /// Cấu hình toàn bộ boss - File config duy nhất để điều chỉnh toàn bộ boss&#13;&#10;    /// &lt;/summary&gt;&#13;&#10;    [CreateAssetMenu(fileName = &quot;BossConfig&quot;, menuName = &quot;Boss/Boss Configuration&quot;)]&#13;&#10;    public class BossConfig : ScriptableObject&#13;&#10;    {&#13;&#10;        [Header(&quot;Debug&quot;)]&#13;&#10;        [Tooltip(&quot;Chọn phase để test nhanh. None: Bình thường, Phase1: Phase 1, Phase2: Phase 2, ...&quot;)]&#13;&#10;        public BossDebugPhase debugStartPhase = BossDebugPhase.None;&#13;&#10;     &#13;&#10;        [Header(&quot;Prefab Settings&quot;)]&#13;&#10;        [Tooltip(&quot;Prefab của boss để spawn lại khi cần reset&quot;)]&#13;&#10;        public GameObject bossPrefab;&#13;&#10;        [Tooltip(&quot;Prefab memory fragment rớt ra khi boss chết&quot;)]&#13;&#10;        public GameObject memoryFragmentPrefab;&#13;&#10;        [Tooltip(&quot;Effect xung quanh memory fragment&quot;)]&#13;&#10;        public GameObject memoryFragmentEffectPrefab;&#13;&#10;        &#13;&#10;        [Header(&quot;General Boss Settings&quot;)]&#13;&#10;        public int maxHealthPerPhase = 3;&#13;&#10;        public float moveSpeed = 5f;&#13;&#10;        public float rotationSpeed = 90f;&#13;&#10;        &#13;&#10;        [Header(&quot;Phase 1 Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public Phase1Config phase1;&#13;&#10;        &#13;&#10;        [Header(&quot;Phase 2 Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public Phase2Config phase2;&#13;&#10;        &#13;&#10;        [Header(&quot;Soul Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public SoulConfig soulConfig;&#13;&#10;        &#13;&#10;        [Header(&quot;UI Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public UIConfig uiConfig;&#13;&#10;        &#13;&#10;        [Header(&quot;Audio Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public AudioConfig audioConfig;&#13;&#10;        &#13;&#10;        [Header(&quot;FMOD Studio Settings&quot;)]&#13;&#10;        [Space]&#13;&#10;        public FMODAudioConfig fmodAudioConfig;&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class Phase1Config&#13;&#10;    {&#13;&#10;        [Header(&quot;State Durations&quot;)]&#13;&#10;        public float idleDuration = 2f;&#13;&#10;        public float lureDuration = 3f;&#13;&#10;        public float mockDuration = 2f;&#13;&#10;        public float decoyCastTime = 2f;&#13;&#10;        public float decoyDuration = 10f;&#13;&#10;        public float soulStateCastTime = 1.5f;&#13;&#10;        &#13;&#10;        [Header(&quot;Lure State&quot;)]&#13;&#10;        public float lureDistance = 5f;&#13;&#10;        public float lureApproachSpeed = 3f;&#13;&#10;        public float lureRetreatSpeed = 4f;&#13;&#10;        &#13;&#10;        [Header(&quot;Decoy State&quot;)]&#13;&#10;        public float decoyMoveSpeed = 2f;&#13;&#10;        public int decoyCount = 2; // 1 thật, 1 giả&#13;&#10;        public float decoySpawnRadius = 8f;&#13;&#10;        public GameObject decoyPrefab; // Prefab cho decoy&#13;&#10;        public GameObject decoySpawnEffectPrefab; // Prefab hiệu ứng khi spawn decoy&#13;&#10;        public GameObject realDecoyRevealEffectPrefab; // Prefab hiệu ứng khi reveal decoy thật&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class Phase2Config&#13;&#10;    {&#13;&#10;        [Header(&quot;State Durations&quot;)]&#13;&#10;        public float angryMoveDuration = 5f;&#13;&#10;        public float fearZoneCastTime = 2f;&#13;&#10;        public float fearZoneDuration = 8f;&#13;&#10;        public float screamCastTime = 3f;&#13;&#10;        public float screamDuration = 5f;&#13;&#10;        public float cookStateDuration = 3f;&#13;&#10;        &#13;&#10;        [Header(&quot;Angry State&quot;)]&#13;&#10;        public float angryMoveSpeed = 3f;&#13;&#10;        public float circleRadius = 10f;&#13;&#10;        &#13;&#10;        [Header(&quot;Fear Zone&quot;)]&#13;&#10;        public float fearZoneRadius = 3f;&#13;&#10;        public GameObject fearZoneCastEffectPrefab; // Prefab hiệu ứng khi cast skill&#13;&#10;        public GameObject fearZoneZoneEffectPrefab; // Prefab hiệu ứng khi zone xuất hiện&#13;&#10;        public GameObject fearZonePlayerEffectPrefab; // Prefab hiệu ứng bao quanh player khi trong fear zone&#13;&#10;        [Header(&quot;Scream State&quot;)]&#13;&#10;        public float screenShakeIntensity = 1f;&#13;&#10;        public float visionShrinkAmount = 0.5f;&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class SoulConfig&#13;&#10;    {&#13;&#10;        public int maxSouls = 2;&#13;&#10;        public float soulMoveSpeed = 4f;&#13;&#10;        public float soulSpawnRadius = 15f;&#13;&#10;        public float soulFollowDistance = 1f;&#13;&#10;        public GameObject soulPrefab;&#13;&#10;        public GameObject soulSpawnEffectPrefab; // Prefab hiệu ứng khi spawn soul&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class UIConfig&#13;&#10;    {&#13;&#10;        [Header(&quot;Colors&quot;)]&#13;&#10;        public Color bossHealthColor = Color.red;&#13;&#10;        public Color playerHealthColor = Color.green;&#13;&#10;        public Color skillCastColor = Color.yellow;&#13;&#10;        &#13;&#10;        [Header(&quot;Animation Settings&quot;)]&#13;&#10;        public float uiAnimationSpeed = 1f;                                                                     // Tốc độ animation chung cho UI&#13;&#10;        public AnimationCurve uiAnimationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);          // Curve cho smooth animation&#13;&#10;    }&#13;&#10;&#13;&#10;    [Serializable]&#13;&#10;    public class AudioConfig&#13;&#10;    {&#13;&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#13;&#10;        public AudioClip mockLaughSound;&#13;&#10;        public AudioClip decoySpawnSound;&#13;&#10;        public AudioClip soulSpawnSound;&#13;&#10;        &#13;&#10;        [Header(&quot;Phase 2 Audio&quot;)]&#13;&#10;        public AudioClip screamSound;&#13;&#10;        public AudioClip fearZoneSound;&#13;&#10;        public AudioClip heartbeatSound;&#13;&#10;        &#13;&#10;        [Header(&quot;General Audio&quot;)]&#13;&#10;        public AudioClip phaseChangeSound;&#13;&#10;        public AudioClip damageSound;&#13;&#10;        public AudioClip defeatSound;&#13;&#10;        &#13;&#10;        [Header(&quot;Volume Settings&quot;)]&#13;&#10;        [Range(0f, 1f)] public float masterVolume = 1f;&#13;&#10;        [Range(0f, 1f)] public float sfxVolume = 0.8f;&#13;&#10;        [Range(0f, 1f)] public float ambientVolume = 0.6f;&#13;&#10;    }&#13;&#10;    &#13;&#10;    [Serializable]&#13;&#10;    public class FMODAudioConfig&#13;&#10;    {&#13;&#10;        [Header(&quot;Phase 1 Audio&quot;)]&#13;&#10;        public EventReference mockLaughEvent;&#13;&#10;        public EventReference decoySpawnEvent;&#13;&#10;        public EventReference soulSpawnEvent;&#13;&#10;        [Header(&quot;Phase 2 Audio&quot;)]&#13;&#10;        public EventReference screamEvent;&#13;&#10;        public EventReference fearZoneEvent;&#13;&#10;        public EventReference heartbeatEvent;&#13;&#10;        [Header(&quot;General Audio&quot;)]&#13;&#10;        public EventReference phaseChangeEvent;&#13;&#10;        public EventReference damageEvent;&#13;&#10;        public EventReference defeatEvent;&#13;&#10;    }&#13;&#10;&#13;&#10;    public enum BossDebugPhase&#13;&#10;    {&#13;&#10;        None = -1,&#13;&#10;        Phase1 = 0,&#13;&#10;        Phase2 = 1&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossSubSystems.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/CoreSystem/BossSubSystems.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Quản lý hệ thống máu của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossHealthSystem&#10;    {&#10;        private int maxHealthPerPhase;&#10;        private int currentHealth;&#10;        private int currentPhase = 1;&#10;        &#10;        public int CurrentHealth =&gt; currentHealth;&#10;        public int MaxHealthPerPhase =&gt; maxHealthPerPhase;&#10;        public int CurrentPhase =&gt; currentPhase;&#10;        public float HealthPercentage =&gt; (float)currentHealth / maxHealthPerPhase;&#10;        &#10;        public event Action&lt;int, int&gt; OnHealthChanged; // current, max&#10;        public event Action OnPhaseHealthDepleted;&#10;&#10;        public BossHealthSystem(int maxHealthPerPhase)&#10;        {&#10;            this.maxHealthPerPhase = maxHealthPerPhase;&#10;            currentHealth = maxHealthPerPhase;&#10;        }&#10;&#10;        public void TakeDamage(int damage)&#10;        {&#10;            currentHealth = Mathf.Max(0, currentHealth - damage);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;            &#10;            if (currentHealth &lt;= 0)&#10;            {&#10;                OnPhaseHealthDepleted?.Invoke();&#10;            }&#10;        }&#10;&#10;        public void ResetPhaseHealth()&#10;        {&#10;            currentHealth = maxHealthPerPhase;&#10;            currentPhase++;&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;&#10;        public void Heal(int amount)&#10;        {&#10;            currentHealth = Mathf.Min(maxHealthPerPhase, currentHealth + amount);&#10;            OnHealthChanged?.Invoke(currentHealth, maxHealthPerPhase);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý Soul entities&#10;    /// &lt;/summary&gt;&#10;    public class BossSoulManager&#10;    {&#10;        private BossController bossController;&#10;        private List&lt;GameObject&gt; activeSouls = new List&lt;GameObject&gt;();&#10;        &#10;        public int ActiveSoulCount =&gt; activeSouls.Count;&#10;        public int MaxSouls =&gt; bossController.Config.soulConfig.maxSouls;&#10;&#10;        public BossSoulManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            &#10;            // Listen for Fa skill usage to destroy souls&#10;            BossEventSystem.Subscribe(BossEventType.FaSkillUsed, OnFaSkillUsed);&#10;        }&#10;&#10;        public void SpawnSoul()&#10;        {&#10;            if (activeSouls.Count &gt;= MaxSouls) return;&#10;            &#10;            var soulConfig = bossController.Config.soulConfig;&#10;            if (soulConfig.soulPrefab == null) return;&#10;            &#10;            // Find spawn position around boss&#10;            Vector3 spawnPos = GetRandomSpawnPosition();&#10;            GameObject soul = GameObject.Instantiate(soulConfig.soulPrefab, spawnPos, Quaternion.identity);&#10;            &#10;            // Setup soul behavior&#10;            var soulBehavior = soul.GetComponent&lt;SoulBehavior&gt;();&#10;            if (soulBehavior == null)&#10;                soulBehavior = soul.AddComponent&lt;SoulBehavior&gt;();&#10;            &#10;            soulBehavior.Initialize(bossController.Player, soulConfig);&#10;            &#10;            activeSouls.Add(soul);&#10;            BossEventSystem.Trigger(BossEventType.SoulSpawned, new BossEventData(soul));&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition()&#10;        {&#10;            var config = bossController.Config.soulConfig;&#10;            Vector3 randomDirection = UnityEngine.Random.insideUnitCircle.normalized;&#10;            Vector3 spawnPos = bossController.transform.position + &#10;                              new Vector3(randomDirection.x, 0, randomDirection.y) * config.soulSpawnRadius;&#10;            return spawnPos;&#10;        }&#10;&#10;        public void DestroyAllSouls()&#10;        {&#10;            foreach (var soul in activeSouls)&#10;            {&#10;                if (soul != null)&#10;                {&#10;                    BossEventSystem.Trigger(BossEventType.SoulDestroyed, new BossEventData(soul));&#10;                    GameObject.Destroy(soul);&#10;                }&#10;            }&#10;            activeSouls.Clear();&#10;        }&#10;&#10;        private void OnFaSkillUsed(BossEventData data)&#10;        {&#10;            // Assuming Fa's radar skill destroys all souls&#10;            if (data.stringValue == &quot;Radar&quot;)&#10;            {&#10;                DestroyAllSouls();&#10;            }&#10;        }&#10;&#10;        public void CleanupDestroyed()&#10;        {&#10;            activeSouls.RemoveAll(soul =&gt; soul == null);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Quản lý UI của Boss&#10;    /// &lt;/summary&gt;&#10;    public class BossUIManager&#10;    {&#10;        private BossController bossController;&#10;        private BossHealthBar bossHealthBar;&#10;        private BossSkillCastBar skillCastBar;&#10;        private PlayerHealthBar playerHealthBar;&#10;        &#10;        public BossUIManager(BossController controller)&#10;        {&#10;            bossController = controller;&#10;            InitializeUI();&#10;        }&#10;&#10;        private void InitializeUI()&#10;        {&#10;            // Tìm và khởi tạo UI components đã được gán trong scene&#10;            FindAndInitializeUIComponents();&#10;        }&#10;&#10;        private void FindAndInitializeUIComponents()&#10;        {&#10;            // Tìm BossHealthBar trong scene&#10;            bossHealthBar = UnityEngine.Object.FindObjectOfType&lt;BossHealthBar&gt;();&#10;            if (bossHealthBar != null)&#10;            {&#10;                bossHealthBar.Initialize(bossController);&#10;                Debug.Log(&quot;Boss Health Bar found and initialized&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;BossHealthBar not found in scene! Please add BossHealthBar component to a UI GameObject.&quot;);&#10;            }&#10;&#10;            // Tìm BossSkillCastBar trong scene&#10;            skillCastBar = UnityEngine.Object.FindObjectOfType&lt;BossSkillCastBar&gt;();&#10;            if (skillCastBar != null)&#10;            {&#10;                skillCastBar.Initialize(bossController);&#10;                Debug.Log(&quot;Boss Skill Cast Bar found and initialized&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;BossSkillCastBar not found in scene! Please add BossSkillCastBar component to a UI GameObject.&quot;);&#10;            }&#10;&#10;            // Tìm PlayerHealthBar trong scene&#10;            playerHealthBar = UnityEngine.Object.FindObjectOfType&lt;PlayerHealthBar&gt;();&#10;            if (playerHealthBar != null)&#10;            {&#10;                playerHealthBar.Initialize(3); // Default player health&#10;                Debug.Log(&quot;Player Health Bar found and initialized&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;PlayerHealthBar not found in scene! Please add PlayerHealthBar component to a UI GameObject.&quot;);&#10;            }&#10;        }&#10;&#10;        // Methods để show/hide UI&#10;        public void ShowBossHealthBar(bool show)&#10;        {&#10;            if (bossHealthBar != null)&#10;                bossHealthBar.gameObject.SetActive(show);&#10;        }&#10;&#10;        public void ShowSkillCastBar(bool show)&#10;        {&#10;            if (skillCastBar != null)&#10;                skillCastBar.gameObject.SetActive(show);&#10;        }&#10;&#10;        public void ShowPlayerHealthBar(bool show)&#10;        {&#10;            if (playerHealthBar != null)&#10;                playerHealthBar.gameObject.SetActive(show);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    // File này giờ chỉ chứa các using statements và namespace&#10;    // Các systems đã được tách ra thành files riêng:&#10;    // - BossHealthSystem.cs&#10;    // - BossSoulManager.cs  &#10;    // - BossUIManager.cs&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/FaBossIntegration.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/FaBossIntegration.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Interface tích hợp với hệ thống kỹ năng của Fa&#10;    /// &lt;/summary&gt;&#10;    public class FaBossIntegration : MonoBehaviour&#10;    {&#10;        [Header(&quot;Integration Settings&quot;)]&#10;        [SerializeField] private bool enableFaIntegration = true;&#10;        &#10;        private BossManager bossManager;&#10;        &#10;        // Events để thông báo cho Fa system&#10;        public static System.Action&lt;string&gt; OnRequestFaSkill;&#10;        public static System.Action&lt;int&gt; OnSoulCountChanged;&#10;        public static System.Action&lt;bool&gt; OnBossVulnerable; // Khi boss có thể bị tấn công&#10;&#10;        private void Start()&#10;        {&#10;            bossManager = BossManager.Instance;&#10;            &#10;            if (enableFaIntegration)&#10;            {&#10;                RegisterForBossEvents();&#10;            }&#10;        }&#10;&#10;        private void RegisterForBossEvents()&#10;        {&#10;            // Lắng nghe các sự kiện boss để thông báo cho Fa&#10;            BossEventSystem.Subscribe(BossEventType.SoulSpawned, OnSoulSpawned);&#10;            BossEventSystem.Subscribe(BossEventType.SoulDestroyed, OnSoulDestroyed);&#10;            BossEventSystem.Subscribe(BossEventType.DecoyStarted, OnDecoyStarted);&#10;            BossEventSystem.Subscribe(BossEventType.ScreamStarted, OnScreamStarted);&#10;            BossEventSystem.Subscribe(BossEventType.RequestRadarSkill, OnRadarSkillRequested);&#10;        }&#10;&#10;        private void OnSoulSpawned(BossEventData data)&#10;        {&#10;            // Thông báo cho Fa rằng có soul mới được spawn&#10;            int currentSoulCount = FindObjectsOfType&lt;SoulBehavior&gt;().Length;&#10;            OnSoulCountChanged?.Invoke(currentSoulCount);&#10;            &#10;            // Nếu có &gt;= 2 souls, suggest Fa use Radar skill&#10;            if (currentSoulCount &gt;= 2)&#10;            {&#10;                SuggestRadarSkill();&#10;            }&#10;        }&#10;&#10;        private void OnSoulDestroyed(BossEventData data)&#10;        {&#10;            int currentSoulCount = FindObjectsOfType&lt;SoulBehavior&gt;().Length - 1; // -1 vì soul sắp bị destroy&#10;            OnSoulCountChanged?.Invoke(currentSoulCount);&#10;        }&#10;&#10;        private void OnDecoyStarted(BossEventData data)&#10;        {&#10;            // Boss bắt đầu cast Decoy - đây là thời điểm boss có thể bị tấn công&#10;            OnBossVulnerable?.Invoke(true);&#10;        }&#10;&#10;        private void OnScreamStarted(BossEventData data)&#10;        {&#10;            // Boss bắt đầu cast Scream - đây cũng là thời điểm boss có thể bị tấn công&#10;            OnBossVulnerable?.Invoke(true);&#10;        }&#10;&#10;        private void OnRadarSkillRequested(BossEventData data)&#10;        {&#10;            SuggestRadarSkill();&#10;        }&#10;&#10;        private void SuggestRadarSkill()&#10;        {&#10;            // Gửi signal cho Fa system để suggest sử dụng Radar skill&#10;            OnRequestFaSkill?.Invoke(&quot;Radar&quot;);&#10;            &#10;            Debug.Log(&quot;Suggesting Fa to use Radar skill to clear souls&quot;);&#10;        }&#10;&#10;        // Method để Fa system gọi khi skill được sử dụng&#10;        public static void NotifyFaSkillUsed(string skillName, bool success = true)&#10;        {&#10;            if (BossManager.Instance != null)&#10;            {&#10;                BossManager.Instance.OnFaSkillCompleted(skillName, success);&#10;            }&#10;        }&#10;&#10;        // Method để Fa system kiểm tra trạng thái boss&#10;        public static bool IsBossVulnerable()&#10;        {&#10;            if (BossManager.Instance == null) return false;&#10;            &#10;            string currentState = BossManager.Instance.GetCurrentBossState();&#10;            return currentState == &quot;DecoyState&quot; || currentState == &quot;ScreamState&quot;;&#10;        }&#10;&#10;        // Method để Fa system kiểm tra số lượng soul&#10;        public static int GetCurrentSoulCount()&#10;        {&#10;            return FindObjectsOfType&lt;SoulBehavior&gt;().Length;&#10;        }&#10;&#10;        // Method để Fa system kiểm tra phase hiện tại&#10;        public static int GetCurrentBossPhase()&#10;        {&#10;            return BossManager.Instance?.GetCurrentBossPhase() ?? 0;&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            BossEventSystem.Unsubscribe(BossEventType.SoulSpawned, OnSoulSpawned);&#10;            BossEventSystem.Unsubscribe(BossEventType.SoulDestroyed, OnSoulDestroyed);&#10;            BossEventSystem.Unsubscribe(BossEventType.DecoyStarted, OnDecoyStarted);&#10;            BossEventSystem.Unsubscribe(BossEventType.ScreamStarted, OnScreamStarted);&#10;            BossEventSystem.Unsubscribe(BossEventType.RequestRadarSkill, OnRadarSkillRequested);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Example integration với Fa skill system&#10;    /// &lt;/summary&gt;&#10;    public static class FaSkillIntegrationExample&#10;    {&#10;        // Ví dụ cách Fa system có thể tích hợp&#10;        public static void InitializeFaIntegration()&#10;        {&#10;            // Đăng ký lắng nghe boss events&#10;            FaBossIntegration.OnRequestFaSkill += HandleFaSkillRequest;&#10;            FaBossIntegration.OnSoulCountChanged += HandleSoulCountChanged;&#10;            FaBossIntegration.OnBossVulnerable += HandleBossVulnerabilityChanged;&#10;        }&#10;&#10;        private static void HandleFaSkillRequest(string skillName)&#10;        {&#10;            Debug.Log($&quot;Boss system is requesting Fa to use skill: {skillName}&quot;);&#10;            &#10;            // Fa system logic here&#10;            // Example:&#10;            // if (FaSkillManager.CanUseSkill(skillName))&#10;            // {&#10;            //     FaSkillManager.UseSkill(skillName, OnFaSkillComplete);&#10;            // }&#10;        }&#10;&#10;        private static void HandleSoulCountChanged(int soulCount)&#10;        {&#10;            Debug.Log($&quot;Soul count changed to: {soulCount}&quot;);&#10;            &#10;            // Fa system có thể update UI hoặc AI logic dựa trên số soul&#10;        }&#10;&#10;        private static void HandleBossVulnerabilityChanged(bool isVulnerable)&#10;        {&#10;            Debug.Log($&quot;Boss vulnerability changed to: {isVulnerable}&quot;);&#10;            &#10;            // Fa system có thể update UI để hiển thị cơ hội tấn công&#10;        }&#10;&#10;        // Callback khi Fa skill hoàn thành&#10;        private static void OnFaSkillComplete(string skillName, bool success)&#10;        {&#10;            // Thông báo lại cho boss system&#10;            FaBossIntegration.NotifyFaSkillUsed(skillName, success);&#10;        }&#10;&#10;        public static void CleanupFaIntegration()&#10;        {&#10;            FaBossIntegration.OnRequestFaSkill -= HandleFaSkillRequest;&#10;            FaBossIntegration.OnSoulCountChanged -= HandleSoulCountChanged;&#10;            FaBossIntegration.OnBossVulnerable -= HandleBossVulnerabilityChanged;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Phase1States.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Phase1States.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Idle State: Boss đứng yên tại chỗ&#10;    /// &lt;/summary&gt;&#10;    public class IdleState : BossState&#10;    {&#10;        private float idleTimer;&#10;        private bool canTransition = true;&#10;&#10;        public override void Enter()&#10;        {&#10;            idleTimer = 0f;&#10;            bossController.PlayAnimation(&quot;Idle&quot;);&#10;            &#10;            // Stop movement&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(bossController.transform.position);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            idleTimer += Time.deltaTime;&#10;            &#10;            if (idleTimer &gt;= config.phase1.idleDuration &amp;&amp; canTransition)&#10;            {&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        private void TransitionToNextState()&#10;        {&#10;            if (config.phase1.enableRandomStates)&#10;            {&#10;                BossState nextState = GetRandomNextState();&#10;                bossController.ChangeState(nextState);&#10;            }&#10;            else&#10;            {&#10;                // Default sequence: Idle -&gt; Lure -&gt; Mock -&gt; Decoy&#10;                bossController.ChangeState(new LureState());&#10;            }&#10;        }&#10;&#10;        private BossState GetRandomNextState()&#10;        {&#10;            float[] weights = config.phase1.stateWeights;&#10;            float totalWeight = weights[1] + weights[2] + weights[3]; // Exclude Idle weight&#10;            float randomValue = Random.Range(0f, totalWeight);&#10;            &#10;            float currentWeight = 0f;&#10;            &#10;            currentWeight += weights[1]; // Lure&#10;            if (randomValue &lt;= currentWeight)&#10;                return new LureState();&#10;                &#10;            currentWeight += weights[2]; // Mock&#10;            if (randomValue &lt;= currentWeight)&#10;                return new MockState();&#10;                &#10;            return new DecoyState(); // Decoy&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Idle state (only in Decoy state)&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false; // Idle state cannot be interrupted&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Lure State: Boss tiến lại gần người chơi rồi rút lui&#10;    /// &lt;/summary&gt;&#10;    public class LureState : BossState&#10;    {&#10;        private enum LurePhase { Approaching, Retreating, Completed }&#10;        private LurePhase currentPhase = LurePhase.Approaching;&#10;        private Vector3 originalPosition;&#10;        private Vector3 targetPosition;&#10;        private float stateTimer;&#10;&#10;        public override void Enter()&#10;        {&#10;            originalPosition = bossController.transform.position;&#10;            currentPhase = LurePhase.Approaching;&#10;            stateTimer = 0f;&#10;            &#10;            bossController.PlayAnimation(&quot;Lure&quot;);&#10;            BossEventSystem.Trigger(BossEventType.LureStarted);&#10;            &#10;            CalculateTargetPosition();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            stateTimer += Time.deltaTime;&#10;            &#10;            switch (currentPhase)&#10;            {&#10;                case LurePhase.Approaching:&#10;                    HandleApproaching();&#10;                    break;&#10;                case LurePhase.Retreating:&#10;                    HandleRetreating();&#10;                    break;&#10;                case LurePhase.Completed:&#10;                    // Transition to next state&#10;                    bossController.ChangeState(new MockState());&#10;                    break;&#10;            }&#10;        }&#10;&#10;        private void CalculateTargetPosition()&#10;        {&#10;            Vector3 directionToPlayer = (bossController.Player.position - bossController.transform.position).normalized;&#10;            targetPosition = bossController.Player.position - directionToPlayer * config.phase1.lureDistance;&#10;        }&#10;&#10;        private void HandleApproaching()&#10;        {&#10;            MoveTowards(targetPosition, config.phase1.lureApproachSpeed);&#10;            &#10;            float distanceToTarget = Vector3.Distance(bossController.transform.position, targetPosition);&#10;            if (distanceToTarget &lt; 0.5f || stateTimer &gt; config.phase1.lureDuration * 0.6f)&#10;            {&#10;                currentPhase = LurePhase.Retreating;&#10;            }&#10;        }&#10;&#10;        private void HandleRetreating()&#10;        {&#10;            MoveTowards(originalPosition, config.phase1.lureRetreatSpeed);&#10;            &#10;            float distanceToOriginal = Vector3.Distance(bossController.transform.position, originalPosition);&#10;            if (distanceToOriginal &lt; 0.5f || stateTimer &gt; config.phase1.lureDuration)&#10;            {&#10;                currentPhase = LurePhase.Completed;&#10;            }&#10;        }&#10;&#10;        private void MoveTowards(Vector3 target, float speed)&#10;        {&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = speed;&#10;                bossController.NavAgent.SetDestination(target);&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Reset movement speed&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = config.moveSpeed;&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Lure state&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Mock State: Boss phát tư thế vặn vẹo và tiếng cười méo mó&#10;    /// &lt;/summary&gt;&#10;    public class MockState : BossState&#10;    {&#10;        private float mockTimer;&#10;&#10;        public override void Enter()&#10;        {&#10;            mockTimer = 0f;&#10;            bossController.PlayAnimation(&quot;Mock&quot;);&#10;            BossEventSystem.Trigger(BossEventType.MockStarted);&#10;            &#10;            // Play mock laugh sound&#10;            if (config.audioConfig.mockLaughSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.mockLaughSound, config.audioConfig.sfxVolume);&#10;            }&#10;            &#10;            // Stop movement&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(bossController.transform.position);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            mockTimer += Time.deltaTime;&#10;            &#10;            if (mockTimer &gt;= config.phase1.mockDuration)&#10;            {&#10;                bossController.ChangeState(new DecoyState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Mock state&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Decoy State: Spawn 2 bóng ảo (1 thật 1 giả) truy đuổi người chơi&#10;    /// &lt;/summary&gt;&#10;    public class DecoyState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated = false;&#10;        private GameObject realDecoy;&#10;        private GameObject fakeDecoy;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            &#10;            bossController.PlayAnimation(&quot;DecoyCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.DecoyStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;            &#10;            // Play decoy spawn sound&#10;            if (config.audioConfig.decoySpawnSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.decoySpawnSound, config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                HandleSkillActive();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase1.decoyCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase1.decoyCastTime)&#10;            {&#10;                ActivateSkill();&#10;            }&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            &#10;            SpawnDecoys();&#10;            bossController.PlayAnimation(&quot;DecoyActive&quot;);&#10;        }&#10;&#10;        private void SpawnDecoys()&#10;        {&#10;            Vector3 spawnCenter = bossController.Player.position;&#10;            float spawnRadius = config.phase1.decoySpawnRadius;&#10;            &#10;            // Spawn real decoy (this is actually the boss)&#10;            Vector3 realPos = GetRandomSpawnPosition(spawnCenter, spawnRadius);&#10;            realDecoy = CreateDecoy(realPos, true);&#10;            &#10;            // Spawn fake decoy&#10;            Vector3 fakePos = GetRandomSpawnPosition(spawnCenter, spawnRadius);&#10;            fakeDecoy = CreateDecoy(fakePos, false);&#10;            &#10;            // Hide original boss&#10;            bossController.gameObject.SetActive(false);&#10;        }&#10;&#10;        private Vector3 GetRandomSpawnPosition(Vector3 center, float radius)&#10;        {&#10;            Vector2 randomCircle = Random.insideUnitCircle.normalized * radius;&#10;            return center + new Vector3(randomCircle.x, 0, randomCircle.y);&#10;        }&#10;&#10;        private GameObject CreateDecoy(Vector3 position, bool isReal)&#10;        {&#10;            // Create decoy GameObject (assuming we have a prefab)&#10;            GameObject decoy = new GameObject(isReal ? &quot;RealDecoy&quot; : &quot;FakeDecoy&quot;);&#10;            decoy.transform.position = position;&#10;            &#10;            // Add decoy behavior&#10;            var decoyBehavior = decoy.AddComponent&lt;DecoyBehavior&gt;();&#10;            decoyBehavior.Initialize(bossController, isReal, config.phase1.decoyMoveSpeed);&#10;            &#10;            bossController.AddDecoy(decoy);&#10;            return decoy;&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            &#10;            if (skillTimer &gt;= config.phase1.decoyDuration)&#10;            {&#10;                EndDecoyState();&#10;            }&#10;        }&#10;&#10;        private void EndDecoyState()&#10;        {&#10;            // Clean up decoys&#10;            bossController.ClearDecoys();&#10;            &#10;            // Show original boss&#10;            bossController.gameObject.SetActive(true);&#10;            &#10;            // Return to idle&#10;            bossController.ChangeState(new IdleState());&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Ensure cleanup&#10;            if (skillActivated)&#10;            {&#10;                bossController.ClearDecoys();&#10;                bossController.gameObject.SetActive(true);&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                // Skill interrupted&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                bossController.ChangeState(new IdleState());&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting; // Can only be interrupted during casting&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Phase2States.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Phase2States.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Angry State: Boss di chuyển xoay quanh trung tâm NavMesh&#10;    /// &lt;/summary&gt;&#10;    public class AngryState : BossState&#10;    {&#10;        private float stateTimer;&#10;        private float currentAngle = 0f;&#10;        private Vector3 centerPosition;&#10;        private bool canTransition = true;&#10;&#10;        public override void Enter()&#10;        {&#10;            stateTimer = 0f;&#10;            centerPosition = bossController.NavMeshCenter != null ? &#10;                           bossController.NavMeshCenter.position : &#10;                           bossController.transform.position;&#10;            &#10;            bossController.PlayAnimation(&quot;Angry&quot;);&#10;            &#10;            // Set movement speed for angry state&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = config.phase2.angryMoveSpeed;&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            stateTimer += Time.deltaTime;&#10;            &#10;            // Move in circle around center&#10;            MoveInCircle();&#10;            &#10;            if (stateTimer &gt;= config.phase2.angryMoveDuration &amp;&amp; canTransition)&#10;            {&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        private void MoveInCircle()&#10;        {&#10;            float radius = config.phase2.circleRadius;&#10;            currentAngle += (config.phase2.angryMoveSpeed / radius) * Time.deltaTime;&#10;            &#10;            Vector3 targetPosition = centerPosition + new Vector3(&#10;                Mathf.Cos(currentAngle) * radius,&#10;                0,&#10;                Mathf.Sin(currentAngle) * radius&#10;            );&#10;            &#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(targetPosition);&#10;            }&#10;        }&#10;&#10;        private void TransitionToNextState()&#10;        {&#10;            // Random between FearZone and Scream states&#10;            if (Random.Range(0f, 1f) &lt; 0.5f)&#10;            {&#10;                bossController.ChangeState(new FearZoneState());&#10;            }&#10;            else&#10;            {&#10;                bossController.ChangeState(new ScreamState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Reset movement speed&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.speed = config.moveSpeed;&#10;            }&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage in Angry state&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Fear Zone State: Tạo vùng tối dưới chân người chơi&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated = false;&#10;        private GameObject fearZone;&#10;        private Vector3 fearZonePosition;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            playerInZone = false;&#10;            playerInZoneTime = 0f;&#10;            &#10;            bossController.PlayAnimation(&quot;FearZoneCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.FearZoneCreated);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;            &#10;            // Record player position for fear zone&#10;            fearZonePosition = bossController.Player.position;&#10;            &#10;            // Play fear zone sound&#10;            if (config.audioConfig.fearZoneSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.fearZoneSound, config.audioConfig.ambientVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                HandleSkillActive();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase2.fearZoneCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase2.fearZoneCastTime)&#10;            {&#10;                ActivateSkill();&#10;            }&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            &#10;            CreateFearZone();&#10;            bossController.PlayAnimation(&quot;FearZoneActive&quot;);&#10;        }&#10;&#10;        private void CreateFearZone()&#10;        {&#10;            // Create fear zone GameObject&#10;            fearZone = new GameObject(&quot;FearZone&quot;);&#10;            fearZone.transform.position = fearZonePosition;&#10;            &#10;            // Add fear zone behavior&#10;            var fearZoneBehavior = fearZone.AddComponent&lt;FearZoneBehavior&gt;();&#10;            fearZoneBehavior.Initialize(config.phase2.fearZoneRadius, config.phase2.visionBlurIntensity);&#10;            &#10;            // Add trigger collider&#10;            var collider = fearZone.AddComponent&lt;SphereCollider&gt;();&#10;            collider.isTrigger = true;&#10;            collider.radius = config.phase2.fearZoneRadius;&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            &#10;            // Check if player is in fear zone&#10;            CheckPlayerInZone();&#10;            &#10;            if (skillTimer &gt;= config.phase2.fearZoneDuration)&#10;            {&#10;                EndFearZoneState();&#10;            }&#10;        }&#10;&#10;        private void CheckPlayerInZone()&#10;        {&#10;            if (fearZone == null) return;&#10;            &#10;            float distanceToPlayer = Vector3.Distance(fearZonePosition, bossController.Player.position);&#10;            bool currentlyInZone = distanceToPlayer &lt;= config.phase2.fearZoneRadius;&#10;            &#10;            if (currentlyInZone)&#10;            {&#10;                if (!playerInZone)&#10;                {&#10;                    playerInZone = true;&#10;                    playerInZoneTime = 0f;&#10;                    StartHeartbeatSound();&#10;                }&#10;                &#10;                playerInZoneTime += Time.deltaTime;&#10;                &#10;                if (playerInZoneTime &gt;= config.phase2.fearZoneActivationTime)&#10;                {&#10;                    ApplyFearEffects();&#10;                }&#10;            }&#10;            else&#10;            {&#10;                if (playerInZone)&#10;                {&#10;                    playerInZone = false;&#10;                    playerInZoneTime = 0f;&#10;                    StopHeartbeatSound();&#10;                }&#10;            }&#10;        }&#10;&#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (config.audioConfig.heartbeatSound != null)&#10;            {&#10;                bossController.AudioSource.clip = config.audioConfig.heartbeatSound;&#10;                bossController.AudioSource.loop = true;&#10;                bossController.AudioSource.Play();&#10;            }&#10;        }&#10;&#10;        private void StopHeartbeatSound()&#10;        {&#10;            bossController.AudioSource.Stop();&#10;            bossController.AudioSource.loop = false;&#10;        }&#10;&#10;        private void ApplyFearEffects()&#10;        {&#10;            // Apply vision blur and other fear effects&#10;            // This would integrate with a camera effects system&#10;            BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(0)); // Psychological damage&#10;        }&#10;&#10;        private void EndFearZoneState()&#10;        {&#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;            }&#10;            &#10;            StopHeartbeatSound();&#10;            bossController.ChangeState(new AngryState());&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;            }&#10;            StopHeartbeatSound();&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Scream State: Phát âm thanh chê trách và hiệu ứng&#10;    /// &lt;/summary&gt;&#10;    public class ScreamState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;        private bool skillActivated = false;&#10;        private bool playerAttacked = false;&#10;        private bool playerHitBoss = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            skillActivated = false;&#10;            playerAttacked = false;&#10;            playerHitBoss = false;&#10;            &#10;            bossController.PlayAnimation(&quot;ScreamCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.ScreamStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                HandleSkillActive();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase2.screamCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase2.screamCastTime)&#10;            {&#10;                ActivateSkill();&#10;            }&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            skillActivated = true;&#10;            &#10;            bossController.PlayAnimation(&quot;ScreamActive&quot;);&#10;            &#10;            // Apply scream effects&#10;            ApplyScreamEffects();&#10;            &#10;            // Play scream sound&#10;            if (config.audioConfig.screamSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.screamSound, config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        private void ApplyScreamEffects()&#10;        {&#10;            // Apply screen shake&#10;            ApplyScreenShake();&#10;            &#10;            // Apply vision shrink&#10;            ApplyVisionShrink();&#10;        }&#10;&#10;        private void ApplyScreenShake()&#10;        {&#10;            // This would integrate with a camera shake system&#10;            // For now, trigger event for external system to handle&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;ScreenShake&quot;, floatValue = config.phase2.screenShakeIntensity });&#10;        }&#10;&#10;        private void ApplyVisionShrink()&#10;        {&#10;            // This would integrate with a camera/UI system&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;VisionShrink&quot;, floatValue = config.phase2.visionShrinkAmount });&#10;        }&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            &#10;            if (skillTimer &gt;= config.phase2.screamDuration)&#10;            {&#10;                EndScreamState();&#10;            }&#10;        }&#10;&#10;        private void EndScreamState()&#10;        {&#10;            if (playerHitBoss)&#10;            {&#10;                // Player hit boss successfully - boss takes damage&#10;                bossController.TakeDamage(1);&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;            else&#10;            {&#10;                // Player missed or didn't attack - player takes damage and spawn soul&#10;                BossEventSystem.Trigger(BossEventType.PlayerTakeDamage, new BossEventData(1));&#10;                bossController.ChangeState(new SoulState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Remove scream effects&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;RemoveEffects&quot; });&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;            else if (skillActivated)&#10;            {&#10;                // Player hit boss during scream&#10;                playerHitBoss = true;&#10;                playerAttacked = true;&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting;&#10;        }&#10;&#10;        // Method to be called when player attacks (hit or miss)&#10;        public void OnPlayerAttack(bool hitBoss)&#10;        {&#10;            if (skillActivated)&#10;            {&#10;                playerAttacked = true;&#10;                playerHitBoss = hitBoss;&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Cook State: Boss bị đánh bại và rớt mảnh ghép&#10;    /// &lt;/summary&gt;&#10;    public class CookState : BossState&#10;    {&#10;        private float cookTimer;&#10;        private bool memoryFragmentDropped = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            cookTimer = 0f;&#10;            memoryFragmentDropped = false;&#10;            &#10;            bossController.PlayAnimation(&quot;Cook&quot;);&#10;            &#10;            // Stop all movement&#10;            if (bossController.NavAgent != null)&#10;            {&#10;                bossController.NavAgent.SetDestination(bossController.transform.position);&#10;                bossController.NavAgent.enabled = false;&#10;            }&#10;            &#10;            // Clear all souls&#10;            bossController.SoulManager.DestroyAllSouls();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            cookTimer += Time.deltaTime;&#10;            &#10;            // Gradually fade boss&#10;            FadeBoss();&#10;            &#10;            if (cookTimer &gt;= config.phase2.cookStateDuration &amp;&amp; !memoryFragmentDropped)&#10;            {&#10;                DropMemoryFragment();&#10;                memoryFragmentDropped = true;&#10;            }&#10;            &#10;            if (cookTimer &gt;= config.phase2.cookStateDuration + 1f)&#10;            {&#10;                CompleteBossDefeat();&#10;            }&#10;        }&#10;&#10;        private void FadeBoss()&#10;        {&#10;            float fadeProgress = cookTimer / config.phase2.cookStateDuration;&#10;            &#10;            // This would integrate with a material/shader system to fade the boss&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, &#10;                new BossEventData { stringValue = &quot;FadeBoss&quot;, floatValue = 1f - fadeProgress });&#10;        }&#10;&#10;        private void DropMemoryFragment()&#10;        {&#10;            // Create memory fragment at boss position&#10;            GameObject memoryFragment = new GameObject(&quot;MemoryFragment&quot;);&#10;            memoryFragment.transform.position = bossController.transform.position;&#10;            &#10;            // Add memory fragment behavior (to be implemented)&#10;            var fragmentBehavior = memoryFragment.AddComponent&lt;MemoryFragmentBehavior&gt;();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossDefeated, new BossEventData(memoryFragment));&#10;        }&#10;&#10;        private void CompleteBossDefeat()&#10;        {&#10;            // Boss completely defeated&#10;            bossController.gameObject.SetActive(false);&#10;            // Or destroy the boss GameObject&#10;            // Object.Destroy(bossController.gameObject);&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed - boss is defeated&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Boss cannot take damage when cooking/defeated&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/SoulAndTransitionStates.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/SoulAndTransitionStates.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Soul State: Teleport và spawn soul (dùng cho cả Phase 1 và Phase 2)&#10;    /// &lt;/summary&gt;&#10;    public class SoulState : BossState&#10;    {&#10;        private float castTimer;&#10;        private bool isCasting = true;&#10;        private Vector3 teleportPosition;&#10;&#10;        public override void Enter()&#10;        {&#10;            castTimer = 0f;&#10;            isCasting = true;&#10;            &#10;            bossController.PlayAnimation(&quot;SoulCast&quot;);&#10;            BossEventSystem.Trigger(BossEventType.SoulStateStarted);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted);&#10;            &#10;            // Calculate teleport position&#10;            CalculateTeleportPosition();&#10;            &#10;            // Play soul spawn sound&#10;            if (config.audioConfig.soulSpawnSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.soulSpawnSound, config.audioConfig.sfxVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting)&#10;            {&#10;                HandleCasting();&#10;            }&#10;            else&#10;            {&#10;                // Immediately transition after teleport and soul spawn&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            float progress = castTimer / config.phase1.soulStateCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            &#10;            if (castTimer &gt;= config.phase1.soulStateCastTime)&#10;            {&#10;                ExecuteTeleportAndSpawnSoul();&#10;            }&#10;        }&#10;&#10;        private void CalculateTeleportPosition()&#10;        {&#10;            // Teleport to a random position away from player&#10;            Vector3 playerPos = bossController.Player.position;&#10;            Vector2 randomDirection = Random.insideUnitCircle.normalized;&#10;            float teleportDistance = config.soulConfig.soulSpawnRadius * 0.8f;&#10;            &#10;            teleportPosition = playerPos + new Vector3(randomDirection.x, 0, randomDirection.y) * teleportDistance;&#10;        }&#10;&#10;        private void ExecuteTeleportAndSpawnSoul()&#10;        {&#10;            isCasting = false;&#10;            &#10;            // Teleport boss&#10;            bossController.transform.position = teleportPosition;&#10;            bossController.PlayAnimation(&quot;SoulActive&quot;);&#10;            &#10;            // Spawn soul if under limit&#10;            if (bossController.SoulManager.ActiveSoulCount &lt; bossController.SoulManager.MaxSouls)&#10;            {&#10;                bossController.SoulManager.SpawnSoul();&#10;            }&#10;        }&#10;&#10;        private void TransitionToNextState()&#10;        {&#10;            // Transition based on current phase&#10;            if (bossController.CurrentPhase == 1)&#10;            {&#10;                bossController.ChangeState(new IdleState());&#10;            }&#10;            else // Phase 2&#10;            {&#10;                bossController.ChangeState(new AngryState());&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // No special cleanup needed&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            if (isCasting &amp;&amp; CanBeInterrupted())&#10;            {&#10;                BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;                TransitionToNextState();&#10;            }&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return isCasting;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Phase 1 - Phase Change State: Chuyển đổi sang Phase 2&#10;    /// &lt;/summary&gt;&#10;    public class PhaseChangeState : BossState&#10;    {&#10;        private float transitionTimer;&#10;        private bool transitionCompleted = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            transitionTimer = 0f;&#10;            transitionCompleted = false;&#10;            &#10;            bossController.PlayAnimation(&quot;PhaseChange&quot;);&#10;            &#10;            // Play phase change sound&#10;            if (config.audioConfig.phaseChangeSound != null)&#10;            {&#10;                bossController.PlaySound(config.audioConfig.phaseChangeSound, config.audioConfig.sfxVolume);&#10;            }&#10;            &#10;            // Clear any remaining decoys and souls&#10;            bossController.ClearDecoys();&#10;            bossController.SoulManager.DestroyAllSouls();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            transitionTimer += Time.deltaTime;&#10;            &#10;            if (transitionTimer &gt;= 2f &amp;&amp; !transitionCompleted) // 2 second transition&#10;            {&#10;                transitionCompleted = true;&#10;                bossController.ChangeToPhase(2);&#10;            }&#10;        }&#10;&#10;        public override void Exit()&#10;        {&#10;            // Cleanup handled in Enter()&#10;        }&#10;&#10;        public override void OnTakeDamage()&#10;        {&#10;            // Cannot take damage during phase transition&#10;        }&#10;&#10;        public override bool CanBeInterrupted()&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/States/Phase2/CookState.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/States/Phase2/CookState.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss.States.Phase2&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Cook State: Boss bị đánh bại và rớt mảnh ghép&#10;    /// &lt;/summary&gt;&#10;    public class CookState : BossState&#10;    {&#10;        private float cookTimer;&#10;        private bool memoryFragmentDropped = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            cookTimer = 0f;&#10;            memoryFragmentDropped = false;&#10;            BossController.PlayAnimation(&quot;Cook&quot;); // Play death/cook animation&#10;            &#10;            BossEventSystem.Trigger(BossEventType.SkillInterrupted); &#10;            BossEventSystem.Trigger(BossEventType.BossDefeated); &#10;            &#10;            // Stop all movement&#10;            if (BossController.NavAgent != null)&#10;            {&#10;                BossController.NavAgent.SetDestination(BossController.transform.position);&#10;                BossController.NavAgent.enabled = false;&#10;            }&#10;            &#10;            // Clear all souls&#10;            BossController.SoulManager.DestroyAllSouls();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            cookTimer += Time.deltaTime;&#10;            if (cookTimer &gt;= Config.phase2.cookStateDuration &amp;&amp; !memoryFragmentDropped)&#10;            {&#10;                DropMemoryFragment();&#10;                memoryFragmentDropped = true;&#10;            }&#10;            &#10;            if (cookTimer &gt;= Config.phase2.cookStateDuration + 1f)&#10;            {&#10;                CompleteBossDefeat();&#10;            }&#10;        }&#10;        &#10;        private void DropMemoryFragment()&#10;        {&#10;            // Create memory fragment at boss position&#10;            var memoryFragment = new GameObject(&quot;MemoryFragment&quot;);&#10;            memoryFragment.transform.position = BossController.transform.position;&#10;            &#10;            // Add memory fragment behavior&#10;            var fragmentBehavior = memoryFragment.AddComponent&lt;MemoryFragmentBehavior&gt;();&#10;            &#10;            BossEventSystem.Trigger(BossEventType.BossDefeated, new BossEventData(memoryFragment));&#10;        }&#10;&#10;        private void CompleteBossDefeat()&#10;        {&#10;            Object.Destroy(BossController.gameObject);&#10;        }&#10;&#10;        public override void Exit() { }&#10;&#10;        public override void OnTakeDamage() { }&#10;&#10;        public override bool CanTakeDamage() =&gt; false;&#10;&#10;        public override bool CanBeInterrupted() =&gt; false;&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;namespace Code.Boss.States.Phase2&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Cook State: Boss bị đánh bại và rớt mảnh ghép&#10;    /// &lt;/summary&gt;&#10;    public class CookState : BossState&#10;    {&#10;        private float cookTimer;&#10;        private bool memoryFragmentDropped = false;&#10;&#10;        public override void Enter()&#10;        {&#10;            cookTimer = 0f;&#10;            memoryFragmentDropped = false;&#10;            BossController.PlayAnimation(&quot;Cook&quot;); // Play death/cook animation&#10;            &#10;            BossEventSystem.Trigger(BossEventType.SkillInterrupted); &#10;            BossEventSystem.Trigger(BossEventType.BossDefeated); &#10;            &#10;            // Stop all movement&#10;            if (BossController.NavAgent != null)&#10;            {&#10;                BossController.NavAgent.SetDestination(BossController.transform.position);&#10;                BossController.NavAgent.enabled = false;&#10;            }&#10;            &#10;            // Clear all souls&#10;            BossController.SoulManager.DestroyAllSouls();&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            cookTimer += Time.deltaTime;&#10;            if (cookTimer &gt;= Config.phase2.cookStateDuration &amp;&amp; !memoryFragmentDropped)&#10;            {&#10;                DropMemoryFragment();&#10;                memoryFragmentDropped = true;&#10;            }&#10;            &#10;            if (cookTimer &gt;= Config.phase2.cookStateDuration + 1f)&#10;            {&#10;                CompleteBossDefeat();&#10;            }&#10;        }&#10;        &#10;        private void DropMemoryFragment()&#10;        {&#10;            // Spawn memory fragment prefab từ BossConfig tại vị trí boss&#10;            if (Config.memoryFragmentPrefab != null)&#10;            {&#10;                var memoryFragment = Object.Instantiate(Config.memoryFragmentPrefab, &#10;                    BossController.transform.position, &#10;                    Quaternion.identity);&#10;                &#10;                BossEventSystem.Trigger(BossEventType.BossDefeated, new BossEventData(memoryFragment));&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;[CookState] Memory Fragment Prefab not assigned in BossConfig!&quot;);&#10;                BossEventSystem.Trigger(BossEventType.BossDefeated);&#10;            }&#10;        }&#10;&#10;        private void CompleteBossDefeat()&#10;        {&#10;            Object.Destroy(BossController.gameObject);&#10;        }&#10;&#10;        public override void Exit() { }&#10;&#10;        public override void OnTakeDamage() { }&#10;&#10;        public override bool CanTakeDamage() =&gt; false;&#10;&#10;        public override bool CanBeInterrupted() =&gt; false;&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/States/Phase2/FearZoneState.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/States/Phase2/FearZoneState.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss.States.Phase2&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Fear Zone State: Tạo vùng tối dưới chân người chơi&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;&#10;&#10;        private GameObject fearZoneCastEffect;&#10;        private GameObject fearZoneZoneEffect;&#10;        private GameObject fearZone;&#10;        private Vector3 fearZonePosition;&#10;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;        private GameObject playerFearEffect; // Effect bao quanh player&#10;&#10;        public override void Enter()&#10;        {&#10;            Debug.Log(&quot;[Boss State] Entered FearZoneState&quot;);&#10;            //BossController.PlayAnimation(&quot;CastSkillA&quot;);&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            BossEventSystem.Trigger(BossEventType.FearZoneCreated);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, new BossEventData { stringValue = &quot;Fear Zone&quot; });&#10;            fearZonePosition = BossController.Player.position;&#10;            &#10;            if (Config.phase2.fearZoneCastEffectPrefab != null)&#10;            {&#10;                fearZoneCastEffect = Object.Instantiate(Config.phase2.fearZoneCastEffectPrefab, fearZonePosition, Quaternion.identity);&#10;            }&#10;            if (Config.audioConfig.fearZoneSound != null)&#10;            {&#10;                BossController.PlaySound(Config.audioConfig.fearZoneSound, Config.audioConfig.ambientVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting) HandleCasting();&#10;            else HandleSkillActive();&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            var progress = castTimer / Config.phase2.fearZoneCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            if (castTimer &gt;= Config.phase2.fearZoneCastTime) ActivateSkill();&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;            if (Config.phase2.fearZoneZoneEffectPrefab != null)&#10;            {&#10;                fearZoneZoneEffect = Object.Instantiate(Config.phase2.fearZoneZoneEffectPrefab, fearZonePosition, Quaternion.identity);&#10;            }&#10;            if (fearZoneCastEffect != null)&#10;            {&#10;                Object.Destroy(fearZoneCastEffect);&#10;                fearZoneCastEffect = null;&#10;            }&#10;            CreateFearZone();&#10;        }&#10;        &#10;        private void CreateFearZone()&#10;        {&#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;            }&#10;            fearZone = new GameObject(&quot;FearZone&quot;)&#10;            {&#10;                transform =&#10;                {&#10;                    position = fearZonePosition&#10;                }&#10;            };&#10;            var collider = fearZone.AddComponent&lt;SphereCollider&gt;();&#10;            collider.isTrigger = true;&#10;            collider.radius = Config.phase2.fearZoneRadius;&#10;        }&#10;&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            CheckPlayerInZone();&#10;            if (skillTimer &gt;= Config.phase2.fearZoneDuration) BossController.ChangeState(new ScreamState());&#10;        }&#10;        &#10;        private void CheckPlayerInZone()&#10;        {&#10;            if (fearZone == null) return;&#10;            var distanceToPlayer = Vector3.Distance(fearZone.transform.position, BossController.Player.position);&#10;            var currentlyInZone = distanceToPlayer &lt;= Config.phase2.fearZoneRadius;&#10;            switch (currentlyInZone)&#10;            {&#10;                case true when !playerInZone:&#10;                    playerInZone = true;&#10;                    playerInZoneTime = 0f;&#10;                    ApplyFearEffects(true);&#10;                    StartHeartbeatSound();&#10;                    break;&#10;                case false when playerInZone:&#10;                    playerInZone = false;&#10;                    playerInZoneTime = 0f;&#10;                    ApplyFearEffects(false);&#10;                    StopHeartbeatSound();&#10;                    break;&#10;            }&#10;            if (playerInZone)&#10;            {&#10;                playerInZoneTime += Time.deltaTime;&#10;            }&#10;        }&#10;        &#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            Debug.Log(&quot;[Boss State] Player &quot; + (enable ? &quot;entered&quot; : &quot;left&quot;) + &quot; fear zone&quot;);&#10;            &#10;            if (enable)&#10;            {&#10;                // Spawn effect bao quanh player khi vào fear zone&#10;                if (Config.phase2.fearZonePlayerEffectPrefab != null &amp;&amp; playerFearEffect == null)&#10;                {&#10;                    playerFearEffect = Object.Instantiate(Config.phase2.fearZonePlayerEffectPrefab, &#10;                        BossController.Player.position, &#10;                        Quaternion.identity, &#10;                        BossController.Player);&#10;                }&#10;                &#10;                // Giảm tốc độ di chuyển của player&#10;                var playerController = BossController.Player.GetComponent&lt;PlayerController_02&gt;();&#10;                if (playerController != null)&#10;                {&#10;                    playerController.ReduceMovementSpeed(0.3f); // Giảm 70% tốc độ&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Destroy effect khi player rời khỏi fear zone&#10;                if (playerFearEffect != null)&#10;                {&#10;                    Object.Destroy(playerFearEffect);&#10;                    playerFearEffect = null;&#10;                }&#10;                &#10;                // Khôi phục tốc độ di chuyển của player&#10;                var playerController = BossController.Player.GetComponent&lt;PlayerController_02&gt;();&#10;                if (playerController != null)&#10;                {&#10;                    playerController.RestoreMovementSpeed();&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (Config.audioConfig.heartbeatSound == null) return;&#10;            BossController.AudioSource.clip = Config.audioConfig.heartbeatSound;&#10;            BossController.AudioSource.loop = true;&#10;            BossController.AudioSource.Play();&#10;        }&#10;        &#10;        private void StopHeartbeatSound()&#10;        {&#10;            BossController.AudioSource.Stop();&#10;            BossController.AudioSource.loop = false;&#10;        }&#10;        &#10;        public override void Exit()&#10;        {&#10;            StopHeartbeatSound();&#10;            &#10;            // Cleanup tốc độ player nếu vẫn đang bị giảm&#10;            if (playerInZone)&#10;            {&#10;                var playerController = BossController.Player.GetComponent&lt;PlayerController_02&gt;();&#10;                if (playerController != null)&#10;                {&#10;                    playerController.RestoreMovementSpeed();&#10;                }&#10;            }&#10;            &#10;            // Cleanup effect khi exit state&#10;            if (playerFearEffect != null)&#10;            {&#10;                Object.Destroy(playerFearEffect);&#10;                playerFearEffect = null;&#10;            }&#10;            &#10;            // Cleanup fear zone effect&#10;            if (fearZoneZoneEffect != null)&#10;            {&#10;                Object.Destroy(fearZoneZoneEffect);&#10;                fearZoneZoneEffect = null;&#10;            }&#10;            &#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;                fearZone = null;&#10;            }&#10;            &#10;            // Reset trạng thái&#10;            playerInZone = false;&#10;            playerInZoneTime = 0f;&#10;        }&#10;&#10;        public override void OnTakeDamage() {}&#10;        public override bool CanTakeDamage() =&gt; false;&#10;        public override bool CanBeInterrupted() =&gt; false;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.Boss.States.Phase2&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Phase 2 - Fear Zone State: Tạo vùng tối dưới chân người chơi&#10;    /// &lt;/summary&gt;&#10;    public class FearZoneState : BossState&#10;    {&#10;        private float castTimer;&#10;        private float skillTimer;&#10;        private bool isCasting = true;&#10;&#10;&#10;        private GameObject fearZoneCastEffect;&#10;        private GameObject fearZoneZoneEffect;&#10;        private GameObject fearZone;&#10;        private Vector3 fearZonePosition;&#10;&#10;        private bool playerInZone = false;&#10;        private float playerInZoneTime = 0f;&#10;        private GameObject playerFearEffect; // Effect bao quanh player&#10;&#10;        public override void Enter()&#10;        {&#10;            Debug.Log(&quot;[Boss State] Entered FearZoneState&quot;);&#10;            //BossController.PlayAnimation(&quot;CastSkillA&quot;);&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            isCasting = true;&#10;            BossEventSystem.Trigger(BossEventType.FearZoneCreated);&#10;            BossEventSystem.Trigger(BossEventType.SkillCasted, new BossEventData { stringValue = &quot;Fear Zone&quot; });&#10;            fearZonePosition = BossController.Player.position;&#10;            &#10;            if (Config.phase2.fearZoneCastEffectPrefab != null)&#10;            {&#10;                fearZoneCastEffect = Object.Instantiate(Config.phase2.fearZoneCastEffectPrefab, fearZonePosition, Quaternion.identity);&#10;            }&#10;            if (Config.audioConfig.fearZoneSound != null)&#10;            {&#10;                BossController.PlaySound(Config.audioConfig.fearZoneSound, Config.audioConfig.ambientVolume);&#10;            }&#10;        }&#10;&#10;        public override void Update()&#10;        {&#10;            if (isCasting) HandleCasting();&#10;            else HandleSkillActive();&#10;        }&#10;&#10;        private void HandleCasting()&#10;        {&#10;            castTimer += Time.deltaTime;&#10;            &#10;            // Update skill cast progress for UI&#10;            var progress = castTimer / Config.phase2.fearZoneCastTime;&#10;            BossEventSystem.Trigger(BossEventType.SkillCastProgress, new BossEventData(progress));&#10;            if (castTimer &gt;= Config.phase2.fearZoneCastTime) ActivateSkill();&#10;        }&#10;&#10;        private void ActivateSkill()&#10;        {&#10;            isCasting = false;&#10;            BossEventSystem.Trigger(BossEventType.SkillInterrupted);&#10;            if (Config.phase2.fearZoneZoneEffectPrefab != null)&#10;            {&#10;                fearZoneZoneEffect = Object.Instantiate(Config.phase2.fearZoneZoneEffectPrefab, fearZonePosition, Quaternion.identity);&#10;            }&#10;            if (fearZoneCastEffect != null)&#10;            {&#10;                Object.Destroy(fearZoneCastEffect);&#10;                fearZoneCastEffect = null;&#10;            }&#10;            CreateFearZone();&#10;        }&#10;        &#10;        private void CreateFearZone()&#10;        {&#10;            if (fearZone != null)&#10;            {&#10;                Object.Destroy(fearZone);&#10;            }&#10;            fearZone = new GameObject(&quot;FearZone&quot;)&#10;            {&#10;                transform =&#10;                {&#10;                    position = fearZonePosition&#10;                }&#10;            };&#10;            var collider = fearZone.AddComponent&lt;SphereCollider&gt;();&#10;            collider.isTrigger = true;&#10;            collider.radius = Config.phase2.fearZoneRadius;&#10;        }&#10;&#10;&#10;        private void HandleSkillActive()&#10;        {&#10;            skillTimer += Time.deltaTime;&#10;            CheckPlayerInZone();&#10;            if (skillTimer &gt;= Config.phase2.fearZoneDuration) BossController.ChangeState(new ScreamState());&#10;        }&#10;        &#10;        private void CheckPlayerInZone()&#10;        {&#10;            if (fearZone == null) return;&#10;            var distanceToPlayer = Vector3.Distance(fearZone.transform.position, BossController.Player.position);&#10;            var currentlyInZone = distanceToPlayer &lt;= Config.phase2.fearZoneRadius;&#10;            switch (currentlyInZone)&#10;            {&#10;                case true when !playerInZone:&#10;                    playerInZone = true;&#10;                    playerInZoneTime = 0f;&#10;                    ApplyFearEffects(true);&#10;                    StartHeartbeatSound();&#10;                    break;&#10;                case false when playerInZone:&#10;                    playerInZone = false;&#10;                    playerInZoneTime = 0f;&#10;                    ApplyFearEffects(false);&#10;                    StopHeartbeatSound();&#10;                    break;&#10;            }&#10;            if (playerInZone)&#10;            {&#10;                playerInZoneTime += Time.deltaTime;&#10;            }&#10;        }&#10;        &#10;        private void ApplyFearEffects(bool enable)&#10;        {&#10;            Debug.Log(&quot;[Boss State] Player &quot; + (enable ? &quot;entered&quot; : &quot;left&quot;) + &quot; fear zone&quot;);&#10;            &#10;            if (enable)&#10;            {&#10;                // Spawn effect bao quanh player khi vào fear zone&#10;                if (Config.phase2.fearZonePlayerEffectPrefab != null &amp;&amp; playerFearEffect == null)&#10;                {&#10;                    playerFearEffect = Object.Instantiate(Config.phase2.fearZonePlayerEffectPrefab, &#10;                        BossController.Player.position, &#10;                        Quaternion.identity, &#10;                        BossController.Player);&#10;                }&#10;                &#10;                // Giảm tốc độ di chuyển của player&#10;                var playerController = BossController.Player.GetComponent&lt;PlayerController_02&gt;();&#10;                if (playerController != null)&#10;                {&#10;                    playerController.ReduceMovementSpeed(0.3f); // Giảm 70% tốc độ&#10;                }&#10;            }&#10;            else&#10;            {&#10;                // Destroy effect khi player rời khỏi fear zone&#10;                if (playerFearEffect != null)&#10;                {&#10;                    Object.Destroy(playerFearEffect);&#10;                    playerFearEffect = null;&#10;                }&#10;                &#10;                // Khôi phục tốc độ di chuyển của player&#10;                var playerController = BossController.Player.GetComponent&lt;PlayerController_02&gt;();&#10;                if (playerController != null)&#10;                {&#10;                    playerController.RestoreMovementSpeed();&#10;                }&#10;            }&#10;        }&#10;        &#10;        private void StartHeartbeatSound()&#10;        {&#10;            if (Config.audioConfig.heartbeatSound == null) return;&#10;            BossController.AudioSource.clip = Config.audioConfig.heartbeatSound;&#10;            BossController.AudioSource.loop = true;&#10;            BossController.AudioSource.Play();&#10;        }&#10;        &#10;        private void StopHeartbeatSound()&#10;        {&#10;            BossController.AudioSource.Stop();&#10;            BossController.AudioSource.loop = false;&#10;        }&#10;        &#10;        public override void Exit()&#10;        {&#10;            StopHeartbeatSound();&#10;            &#10;            // Cleanup tốc độ player nếu vẫn đang bị giảm&#10;            if (playerInZone)&#10;            {&#10;                var playerController = BossController.Player.GetComponent&lt;PlayerController_02&gt;();&#10;                if (playerController != null)&#10;                {&#10;                    playerController.RestoreMovementSpeed();&#10;                }&#10;            }&#10;            &#10;            // Cleanup tất cả effect ngay lập tức&#10;            if (playerFearEffect != null)&#10;            {&#10;                Object.DestroyImmediate(playerFearEffect);&#10;                playerFearEffect = null;&#10;            }&#10;            &#10;            if (fearZoneCastEffect != null)&#10;            {&#10;                Object.DestroyImmediate(fearZoneCastEffect);&#10;                fearZoneCastEffect = null;&#10;            }&#10;            &#10;            if (fearZoneZoneEffect != null)&#10;            {&#10;                Object.DestroyImmediate(fearZoneZoneEffect);&#10;                fearZoneZoneEffect = null;&#10;            }&#10;            &#10;            if (fearZone != null)&#10;            {&#10;                Object.DestroyImmediate(fearZone);&#10;                fearZone = null;&#10;            }&#10;            &#10;            // Reset trạng thái&#10;            playerInZone = false;&#10;            playerInZoneTime = 0f;&#10;            isCasting = true;&#10;            castTimer = 0f;&#10;            skillTimer = 0f;&#10;            &#10;            Debug.Log(&quot;[FearZoneState] Exit cleanup completed - all effects destroyed&quot;);&#10;        }&#10;&#10;        public override void OnTakeDamage() {}&#10;        public override bool CanTakeDamage() =&gt; false;&#10;        public override bool CanBeInterrupted() =&gt; false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Manager chính để setup và quản lý toàn bộ test environment&#10;    /// &lt;/summary&gt;&#10;    public class BossTestManager : MonoBehaviour&#10;    {&#10;        [Header(&quot;Test Setup&quot;)]&#10;        [SerializeField] private GameObject playerPrefab;&#10;        [SerializeField] private GameObject bossPrefab;&#10;        [SerializeField] private BossConfig testBossConfig;&#10;        &#10;        [Header(&quot;Test Environment&quot;)]&#10;        [SerializeField] private Vector3 playerSpawnPoint = new Vector3(0, 1, -10);&#10;        [SerializeField] private Vector3 bossSpawnPoint = new Vector3(0, 1, 10);&#10;        [SerializeField] private Vector3 navMeshCenter = Vector3.zero;&#10;        &#10;        [Header(&quot;Test Settings&quot;)]&#10;        [SerializeField] private bool autoStartTest = true;&#10;        [SerializeField] private bool showTestUI = true;&#10;        [SerializeField] private KeyCode resetTestKey = KeyCode.F1;&#10;        [SerializeField] private KeyCode nextPhaseKey = KeyCode.F2;&#10;        [SerializeField] private KeyCode spawnSoulKey = KeyCode.F3;&#10;        &#10;        // Test objects&#10;        private GameObject testPlayer;&#10;        private GameObject testBoss;&#10;        private BossController bossController;&#10;        private PlayerTestController playerController;&#10;        private FaSkillSimulator faSimulator;&#10;        &#10;        // Test data&#10;        private float testStartTime;&#10;        private int playerDeaths = 0;&#10;        private int bossDeaths = 0;&#10;        private int skillsUsed = 0;&#10;&#10;        private void Start()&#10;        {&#10;            if (autoStartTest)&#10;            {&#10;                StartTest();&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            HandleTestInput();&#10;        }&#10;&#10;        private void HandleTestInput()&#10;        {&#10;            // Reset test&#10;            if (Input.GetKeyDown(resetTestKey))&#10;            {&#10;                ResetTest();&#10;            }&#10;            &#10;            // Force next phase&#10;            if (Input.GetKeyDown(nextPhaseKey))&#10;            {&#10;                ForceNextPhase();&#10;            }&#10;            &#10;            // Spawn test soul&#10;            if (Input.GetKeyDown(spawnSoulKey))&#10;            {&#10;                SpawnTestSoul();&#10;            }&#10;            &#10;            // Quick damage boss (for testing)&#10;            if (Input.GetKeyDown(KeyCode.F4))&#10;            {&#10;                if (bossController != null)&#10;                {&#10;                    bossController.TakeDamage(1);&#10;                    Debug.Log(&quot;[Test] Boss took 1 damage&quot;);&#10;                }&#10;            }&#10;            &#10;            // Quick heal player (for testing)&#10;            if (Input.GetKeyDown(KeyCode.F5))&#10;            {&#10;                var bossManager = BossManager.Instance;&#10;                if (bossManager != null)&#10;                {&#10;                    bossManager.HealPlayer(1);&#10;                    Debug.Log(&quot;[Test] Player healed 1 HP&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void StartTest()&#10;        {&#10;            Debug.Log(&quot;[Test Manager] Starting Boss FSM Test...&quot;);&#10;            testStartTime = Time.time;&#10;            &#10;            // Clean up existing test objects&#10;            CleanupTest();&#10;            &#10;            // Create test environment&#10;            CreateTestEnvironment();&#10;            &#10;            // Setup test objects&#10;            SetupTestPlayer();&#10;            SetupTestBoss();&#10;            SetupFaSimulator();&#10;            &#10;            Debug.Log(&quot;[Test Manager] Test environment ready!&quot;);&#10;        }&#10;&#10;        private void CreateTestEnvironment()&#10;        {&#10;            // Create a simple test ground&#10;            GameObject ground = GameObject.CreatePrimitive(PrimitiveType.Plane);&#10;            ground.name = &quot;TestGround&quot;;&#10;            ground.transform.localScale = new Vector3(5, 1, 5); // 50x50 units&#10;            ground.transform.position = Vector3.zero;&#10;            &#10;            // Add a simple material&#10;            var groundRenderer = ground.GetComponent&lt;Renderer&gt;();&#10;            if (groundRenderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = new Color(0.3f, 0.7f, 0.3f); // Green ground&#10;                groundRenderer.material = material;&#10;            }&#10;            &#10;            // Create NavMesh center marker&#10;            GameObject navCenter = GameObject.CreatePrimitive(PrimitiveType.Cylinder);&#10;            navCenter.name = &quot;NavMeshCenter&quot;;&#10;            navCenter.transform.position = navMeshCenter;&#10;            navCenter.transform.localScale = new Vector3(1, 0.1f, 1);&#10;            &#10;            var centerRenderer = navCenter.GetComponent&lt;Renderer&gt;();&#10;            if (centerRenderer != null)&#10;            {&#10;                var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                material.color = Color.blue;&#10;                centerRenderer.material = material;&#10;            }&#10;        }&#10;&#10;        private void SetupTestPlayer()&#10;        {&#10;            // Create test player&#10;            if (playerPrefab != null)&#10;            {&#10;                testPlayer = Instantiate(playerPrefab, playerSpawnPoint, Quaternion.identity);&#10;            }&#10;            else&#10;            {&#10;                testPlayer = GameObject.CreatePrimitive(PrimitiveType.Capsule);&#10;                testPlayer.name = &quot;TestPlayer&quot;;&#10;                testPlayer.transform.position = playerSpawnPoint;&#10;                testPlayer.tag = &quot;Player&quot;;&#10;                &#10;                // Make player blue&#10;                var renderer = testPlayer.GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                    material.color = Color.blue;&#10;                    renderer.material = material;&#10;                }&#10;            }&#10;            &#10;            // Add player test controller&#10;            playerController = testPlayer.GetComponent&lt;PlayerTestController&gt;();&#10;            if (playerController == null)&#10;            {&#10;                playerController = testPlayer.AddComponent&lt;PlayerTestController&gt;();&#10;            }&#10;            &#10;            Debug.Log(&quot;[Test Manager] Test player created&quot;);&#10;        }&#10;&#10;        private void SetupTestBoss()&#10;        {&#10;            // Create test boss&#10;            if (bossPrefab != null)&#10;            {&#10;                testBoss = Instantiate(bossPrefab, bossSpawnPoint, Quaternion.identity);&#10;            }&#10;            else&#10;            {&#10;                testBoss = GameObject.CreatePrimitive(PrimitiveType.Cube);&#10;                testBoss.name = &quot;TestBoss&quot;;&#10;                testBoss.transform.position = bossSpawnPoint;&#10;                testBoss.transform.localScale = Vector3.one * 2;&#10;                &#10;                // Make boss red&#10;                var renderer = testBoss.GetComponent&lt;Renderer&gt;();&#10;                if (renderer != null)&#10;                {&#10;                    var material = new Material(Shader.Find(&quot;Standard&quot;));&#10;                    material.color = Color.red;&#10;                    renderer.material = material;&#10;                }&#10;            }&#10;            &#10;            // Add boss components&#10;            bossController = testBoss.GetComponent&lt;BossController&gt;();&#10;            if (bossController == null)&#10;            {&#10;                bossController = testBoss.AddComponent&lt;BossController&gt;();&#10;            }&#10;            &#10;            // Add NavMeshAgent&#10;            var navAgent = testBoss.GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();&#10;            if (navAgent == null)&#10;            {&#10;                navAgent = testBoss.AddComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();&#10;            }&#10;            &#10;            // Setup boss configuration&#10;            if (testBossConfig != null)&#10;            {&#10;                // Use reflection to set the private config field&#10;                var configField = typeof(BossController).GetField(&quot;bossConfig&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                configField?.SetValue(bossController, testBossConfig);&#10;            }&#10;            &#10;            // Set references&#10;            SetBossReferences();&#10;            &#10;            Debug.Log(&quot;[Test Manager] Test boss created&quot;);&#10;        }&#10;&#10;        private void SetBossReferences()&#10;        {&#10;            // Set player reference&#10;            var playerField = typeof(BossController).GetField(&quot;player&quot;, &#10;                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;            playerField?.SetValue(bossController, testPlayer.transform);&#10;            &#10;            // Set NavMesh center&#10;            GameObject navCenterObj = GameObject.Find(&quot;NavMeshCenter&quot;);&#10;            if (navCenterObj != null)&#10;            {&#10;                var navCenterField = typeof(BossController).GetField(&quot;navMeshCenter&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                navCenterField?.SetValue(bossController, navCenterObj.transform);&#10;            }&#10;        }&#10;&#10;        private void SetupFaSimulator()&#10;        {&#10;            // Create Fa simulator&#10;            GameObject faSimulatorObj = new GameObject(&quot;FaSimulator&quot;);&#10;            faSimulator = faSimulatorObj.AddComponent&lt;FaSkillSimulator&gt;();&#10;            &#10;            // Add boss integration&#10;            var faIntegration = faSimulatorObj.AddComponent&lt;FaBossIntegration&gt;();&#10;            &#10;            Debug.Log(&quot;[Test Manager] Fa simulator created&quot;);&#10;        }&#10;&#10;        public void ResetTest()&#10;        {&#10;            Debug.Log(&quot;[Test Manager] Resetting test...&quot;);&#10;            &#10;            CleanupTest();&#10;            StartTest();&#10;        }&#10;&#10;        private void CleanupTest()&#10;        {&#10;            // Destroy test objects&#10;            if (testPlayer != null)&#10;                DestroyImmediate(testPlayer);&#10;            if (testBoss != null)&#10;                DestroyImmediate(testBoss);&#10;            if (faSimulator != null)&#10;                DestroyImmediate(faSimulator.gameObject);&#10;            &#10;            // Clean up environment objects&#10;            var ground = GameObject.Find(&quot;TestGround&quot;);&#10;            if (ground != null)&#10;                DestroyImmediate(ground);&#10;            &#10;            var navCenter = GameObject.Find(&quot;NavMeshCenter&quot;);&#10;            if (navCenter != null)&#10;                DestroyImmediate(navCenter);&#10;            &#10;            // Clear boss event system&#10;            BossEventSystem.ClearAllListeners();&#10;        }&#10;&#10;        private void ForceNextPhase()&#10;        {&#10;            if (bossController != null)&#10;            {&#10;                int currentPhase = bossController.CurrentPhase;&#10;                int nextPhase = currentPhase == 1 ? 2 : 1;&#10;                bossController.ChangeToPhase(nextPhase);&#10;                Debug.Log($&quot;[Test] Forced phase change from {currentPhase} to {nextPhase}&quot;);&#10;            }&#10;        }&#10;&#10;        private void SpawnTestSoul()&#10;        {&#10;            if (bossController != null &amp;&amp; bossController.SoulManager != null)&#10;            {&#10;                bossController.SoulManager.SpawnSoul();&#10;                Debug.Log(&quot;[Test] Test soul spawned&quot;);&#10;            }&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (!showTestUI) return;&#10;            &#10;            GUILayout.BeginArea(new Rect(640, 10, 350, 250));&#10;            GUILayout.Label(&quot;=== BOSS TEST MANAGER ===&quot;);&#10;            &#10;            GUILayout.Space(5);&#10;            GUILayout.Label(&quot;QUICK ACTIONS:&quot;);&#10;            if (GUILayout.Button(&quot;Reset Test (F1)&quot;))&#10;            {&#10;                ResetTest();&#10;            }&#10;            if (GUILayout.Button(&quot;Force Next Phase (F2)&quot;))&#10;            {&#10;                ForceNextPhase();&#10;            }&#10;            if (GUILayout.Button(&quot;Spawn Soul (F3)&quot;))&#10;            {&#10;                SpawnTestSoul();&#10;            }&#10;            if (GUILayout.Button(&quot;Damage Boss (F4)&quot;))&#10;            {&#10;                bossController?.TakeDamage(1);&#10;            }&#10;            if (GUILayout.Button(&quot;Heal Player (F5)&quot;))&#10;            {&#10;                BossManager.Instance?.HealPlayer(1);&#10;            }&#10;            &#10;            GUILayout.Space(10);&#10;            GUILayout.Label(&quot;TEST INFO:&quot;);&#10;            GUILayout.Label($&quot;Test Time: {Time.time - testStartTime:F1}s&quot;);&#10;            if (bossController != null)&#10;            {&#10;                GUILayout.Label($&quot;Boss Phase: {bossController.CurrentPhase}&quot;);&#10;                GUILayout.Label($&quot;Boss State: {BossManager.Instance?.GetCurrentBossState() ?? &quot;None&quot;}&quot;);&#10;                GUILayout.Label($&quot;Boss HP: {bossController.HealthSystem?.CurrentHealth ?? 0}&quot;);&#10;            }&#10;            GUILayout.Label($&quot;Active Souls: {FaBossIntegration.GetCurrentSoulCount()}&quot;);&#10;            &#10;            GUILayout.EndArea();&#10;        }&#10;&#10;        private void OnApplicationQuit()&#10;        {&#10;            CleanupTest();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestSceneSetup.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/BossTestSceneSetup.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEditor;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Scene setup helper để tạo test scene tự động&#10;    /// &lt;/summary&gt;&#10;    public class BossTestSceneSetup : MonoBehaviour&#10;    {&#10;        [Header(&quot;Auto Setup&quot;)]&#10;        [SerializeField] private bool setupOnStart = false;&#10;        &#10;        [Header(&quot;Scene Objects&quot;)]&#10;        [SerializeField] private Camera mainCamera;&#10;        [SerializeField] private Light directionalLight;&#10;        &#10;        private void Start()&#10;        {&#10;            if (setupOnStart)&#10;            {&#10;                SetupTestScene();&#10;            }&#10;        }&#10;&#10;        [ContextMenu(&quot;Setup Test Scene&quot;)]&#10;        public void SetupTestScene()&#10;        {&#10;            Debug.Log(&quot;[Scene Setup] Setting up Boss test scene...&quot;);&#10;            &#10;            // Setup camera&#10;            SetupCamera();&#10;            &#10;            // Setup lighting&#10;            SetupLighting();&#10;            &#10;            // Setup test manager&#10;            SetupTestManager();&#10;            &#10;            // Setup UI canvas&#10;            SetupUICanvas();&#10;            &#10;            Debug.Log(&quot;[Scene Setup] Test scene setup complete!&quot;);&#10;        }&#10;&#10;        private void SetupCamera()&#10;        {&#10;            if (mainCamera == null)&#10;            {&#10;                var cameraObj = GameObject.FindObjectOfType&lt;Camera&gt;();&#10;                if (cameraObj == null)&#10;                {&#10;                    cameraObj = new GameObject(&quot;Main Camera&quot;).AddComponent&lt;Camera&gt;();&#10;                }&#10;                mainCamera = cameraObj;&#10;            }&#10;            &#10;            // Position camera for good view of test area&#10;            mainCamera.transform.position = new Vector3(0, 12, -15);&#10;            mainCamera.transform.rotation = Quaternion.Euler(25, 0, 0);&#10;            mainCamera.clearFlags = CameraClearFlags.Skybox;&#10;            &#10;            // Add audio listener if not present&#10;            if (mainCamera.GetComponent&lt;AudioListener&gt;() == null)&#10;            {&#10;                mainCamera.gameObject.AddComponent&lt;AudioListener&gt;();&#10;            }&#10;            &#10;            Debug.Log(&quot;[Scene Setup] Camera configured&quot;);&#10;        }&#10;&#10;        private void SetupLighting()&#10;        {&#10;            if (directionalLight == null)&#10;            {&#10;                var lightObj = GameObject.FindObjectOfType&lt;Light&gt;();&#10;                if (lightObj == null)&#10;                {&#10;                    lightObj = new GameObject(&quot;Directional Light&quot;).AddComponent&lt;Light&gt;();&#10;                }&#10;                directionalLight = lightObj;&#10;            }&#10;            &#10;            directionalLight.type = LightType.Directional;&#10;            directionalLight.transform.rotation = Quaternion.Euler(45, 45, 0);&#10;            directionalLight.intensity = 1.2f;&#10;            directionalLight.shadows = LightShadows.Soft;&#10;            &#10;            // Set ambient lighting&#10;            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Trilight;&#10;            RenderSettings.ambientSkyColor = Color.white;&#10;            RenderSettings.ambientEquatorColor = Color.gray;&#10;            RenderSettings.ambientGroundColor = new Color(0.2f, 0.2f, 0.2f);&#10;            &#10;            Debug.Log(&quot;[Scene Setup] Lighting configured&quot;);&#10;        }&#10;&#10;        private void SetupTestManager()&#10;        {&#10;            var testManager = FindObjectOfType&lt;BossTestManager&gt;();&#10;            if (testManager == null)&#10;            {&#10;                var testManagerObj = new GameObject(&quot;BossTestManager&quot;);&#10;                testManager = testManagerObj.AddComponent&lt;BossTestManager&gt;();&#10;                &#10;                // Create and assign test boss config&#10;                var testConfigCreator = testManagerObj.AddComponent&lt;TestBossConfig&gt;();&#10;                var testConfig = testConfigCreator.CreateTestConfig();&#10;                &#10;                // Use reflection to set the test config&#10;                var configField = typeof(BossTestManager).GetField(&quot;testBossConfig&quot;, &#10;                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);&#10;                configField?.SetValue(testManager, testConfig);&#10;                &#10;                Debug.Log(&quot;[Scene Setup] Test Manager created with config&quot;);&#10;            }&#10;        }&#10;&#10;        private void SetupUICanvas()&#10;        {&#10;            var canvas = FindObjectOfType&lt;Canvas&gt;();&#10;            if (canvas == null)&#10;            {&#10;                var canvasObj = new GameObject(&quot;TestUI Canvas&quot;);&#10;                canvas = canvasObj.AddComponent&lt;Canvas&gt;();&#10;                canvas.renderMode = RenderMode.ScreenSpaceOverlay;&#10;                canvas.sortingOrder = 100;&#10;                &#10;                canvasObj.AddComponent&lt;UnityEngine.UI.CanvasScaler&gt;();&#10;                canvasObj.AddComponent&lt;UnityEngine.UI.GraphicRaycaster&gt;();&#10;                &#10;                Debug.Log(&quot;[Scene Setup] UI Canvas created&quot;);&#10;            }&#10;        }&#10;&#10;        #if UNITY_EDITOR&#10;        [MenuItem(&quot;Boss Test/Setup Test Scene&quot;)]&#10;        public static void SetupTestSceneFromMenu()&#10;        {&#10;            var setup = FindObjectOfType&lt;BossTestSceneSetup&gt;();&#10;            if (setup == null)&#10;            {&#10;                var setupObj = new GameObject(&quot;BossTestSceneSetup&quot;);&#10;                setup = setupObj.AddComponent&lt;BossTestSceneSetup&gt;();&#10;            }&#10;            &#10;            setup.SetupTestScene();&#10;        }&#10;&#10;        [MenuItem(&quot;Boss Test/Create Test Config Asset&quot;)]&#10;        public static void CreateTestConfigAsset()&#10;        {&#10;            var testConfig = ScriptableObject.CreateInstance&lt;TestBossConfig&gt;();&#10;            var config = testConfig.CreateTestConfig();&#10;            &#10;            AssetDatabase.CreateAsset(config, &quot;Assets/Code/Boss/Testing/TestBossConfig.asset&quot;);&#10;            AssetDatabase.SaveAssets();&#10;            &#10;            EditorUtility.FocusProjectWindow();&#10;            Selection.activeObject = config;&#10;            &#10;            Debug.Log(&quot;Test Boss Config asset created!&quot;);&#10;        }&#10;        #endif&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (GUILayout.Button(&quot;Setup Test Scene&quot;, GUILayout.Width(150)))&#10;            {&#10;                SetupTestScene();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/PlayerTestController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/PlayerTestController.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Test controller để giả lập player movement và tương tác với Boss&#10;    /// &lt;/summary&gt;&#10;    public class PlayerTestController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Movement Settings&quot;)]&#10;        [SerializeField] private float moveSpeed = 5f;&#10;        [SerializeField] private float rotationSpeed = 10f;&#10;        &#10;        [Header(&quot;Attack Settings&quot;)]&#10;        [SerializeField] private float attackRange = 3f;&#10;        [SerializeField] private float attackCooldown = 1f;&#10;        &#10;        [Header(&quot;UI Testing&quot;)]&#10;        [SerializeField] private bool showDebugUI = true;&#10;        &#10;        private CharacterController characterController;&#10;        private float lastAttackTime;&#10;        private BossManager bossManager;&#10;        private Vector3 moveDirection;&#10;        private Vector3 velocity; // Thêm velocity riêng cho gravity&#10;        &#10;        // Input tracking&#10;        private bool isMoving;&#10;        private Vector3 inputDirection;&#10;&#10;        private void Start()&#10;        {&#10;            InitializeComponents();&#10;            bossManager = BossManager.Instance;&#10;        }&#10;&#10;        private void InitializeComponents()&#10;        {&#10;            characterController = GetComponent&lt;CharacterController&gt;();&#10;            if (characterController == null)&#10;            {&#10;                characterController = gameObject.AddComponent&lt;CharacterController&gt;();&#10;                characterController.radius = 0.5f;&#10;                characterController.height = 2f;&#10;                characterController.center = new Vector3(0, 1, 0);&#10;            }&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            HandleMovementInput();&#10;            HandleAttackInput();&#10;            HandleFaSkillInput();&#10;            &#10;            MovePlayer();&#10;        }&#10;&#10;        private void HandleMovementInput()&#10;        {&#10;            // WASD movement&#10;            float horizontal = Input.GetAxis(&quot;Horizontal&quot;);&#10;            float vertical = Input.GetAxis(&quot;Vertical&quot;);&#10;            &#10;            inputDirection = new Vector3(horizontal, 0, vertical).normalized;&#10;            isMoving = inputDirection.magnitude &gt; 0.1f;&#10;            &#10;            // Bỏ phần rotation tự động - chỉ di chuyển bình thường&#10;        }&#10;&#10;        private void HandleAttackInput()&#10;        {&#10;            // Space or Left Mouse Button to attack&#10;            if ((Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0)) &amp;&amp; CanAttack())&#10;            {&#10;                PerformAttack();&#10;            }&#10;        }&#10;&#10;        private void HandleFaSkillInput()&#10;        {&#10;            // Q - Radar Skill&#10;            if (Input.GetKeyDown(KeyCode.Q))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Requesting Fa Radar Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;Radar&quot;, true);&#10;            }&#10;            &#10;            // E - Second Skill (example)&#10;            if (Input.GetKeyDown(KeyCode.E))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Second Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;SecondSkill&quot;, true);&#10;            }&#10;            &#10;            // R - Reveal Skill &#10;            if (Input.GetKeyDown(KeyCode.R))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Reveal Skill&quot;);&#10;                // Gọi trực tiếp FaSkillSimulator thay vì thông qua integration&#10;                var faSimulator = FindObjectOfType&lt;FaSkillSimulator&gt;();&#10;                if (faSimulator != null)&#10;                {&#10;                    faSimulator.UseThirdSkill();&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;[Player Test] FaSkillSimulator not found in scene!&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        private void MovePlayer()&#10;        {&#10;            // Handle horizontal movement&#10;            Vector3 horizontalMove = Vector3.zero;&#10;            if (isMoving)&#10;            {&#10;                horizontalMove = inputDirection * moveSpeed;&#10;            }&#10;            &#10;            // Handle gravity properly for CharacterController&#10;            if (characterController != null)&#10;            {&#10;                if (characterController.isGrounded)&#10;                {&#10;                    velocity.y = -2f; // Small downward force to keep grounded&#10;                }&#10;                else&#10;                {&#10;                    velocity.y -= 9.81f * Time.deltaTime; // Apply gravity when not grounded&#10;                }&#10;                &#10;                // Combine horizontal movement with vertical velocity&#10;                Vector3 finalMovement = horizontalMove + velocity;&#10;                characterController.Move(finalMovement * Time.deltaTime);&#10;            }&#10;            else&#10;            {&#10;                // Fallback for transform-based movement (without CharacterController)&#10;                transform.Translate(horizontalMove * Time.deltaTime, Space.World);&#10;            }&#10;        }&#10;&#10;        private bool CanAttack()&#10;        {&#10;            return Time.time &gt;= lastAttackTime + attackCooldown;&#10;        }&#10;&#10;        private void PerformAttack()&#10;        {&#10;            lastAttackTime = Time.time;&#10;            Debug.Log(&quot;[Player Test] Player attacking!&quot;);&#10;            &#10;            // Check if there's a boss or decoy in range&#10;            Collider[] hits = Physics.OverlapSphere(transform.position, attackRange);&#10;            &#10;            foreach (var hit in hits)&#10;            {&#10;                // Check for Boss&#10;                var boss = hit.GetComponent&lt;BossController&gt;();&#10;                if (boss != null)&#10;                {&#10;                    Debug.Log(&quot;[Player Test] Hit Boss directly!&quot;);&#10;                    if (bossManager != null)&#10;                    {&#10;                        bossManager.PlayerAttackBoss();&#10;                    }&#10;                    return;&#10;                }&#10;                &#10;                // Check for Decoy&#10;                var decoy = hit.GetComponent&lt;DecoyBehavior&gt;();&#10;                if (decoy != null)&#10;                {&#10;                    Debug.Log($&quot;[Player Test] Hit {(decoy.IsReal ? &quot;Real&quot; : &quot;Fake&quot;)} Decoy!&quot;);&#10;                    &#10;                    // Gọi trực tiếp OnAttacked() thay vì thông qua BossManager&#10;                    decoy.OnAttacked();&#10;                    return;&#10;                }&#10;            }&#10;            &#10;            Debug.Log(&quot;[Player Test] Attack missed - no target in range&quot;);&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (!showDebugUI) return;&#10;            &#10;            GUILayout.BeginArea(new Rect(10, 10, 300, 200));&#10;            GUILayout.Label(&quot;=== PLAYER TEST CONTROLS ===&quot;);&#10;            GUILayout.Label(&quot;WASD: Move&quot;);&#10;            GUILayout.Label(&quot;Space/LMB: Attack&quot;);&#10;            GUILayout.Label(&quot;Q: Fa Radar Skill&quot;);&#10;            GUILayout.Label(&quot;E: Fa Second Skill&quot;);&#10;            GUILayout.Label(&quot;R: Fa Third Skill&quot;);&#10;            GUILayout.Space(10);&#10;            GUILayout.Label($&quot;Position: {transform.position}&quot;);&#10;            GUILayout.Label($&quot;Moving: {isMoving}&quot;);&#10;            GUILayout.Label($&quot;Can Attack: {CanAttack()}&quot;);&#10;            GUILayout.EndArea();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            // Draw attack range&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, attackRange);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Test controller để giả lập player movement và tương tác với Boss&#10;    /// &lt;/summary&gt;&#10;    public class PlayerTestController : MonoBehaviour&#10;    {&#10;        [Header(&quot;Attack Settings&quot;)]&#10;        [SerializeField] private float attackRange = 3f;&#10;        [SerializeField] private float attackCooldown = 1f;&#10;        &#10;        [Header(&quot;UI Testing&quot;)]&#10;        [SerializeField] private bool showDebugUI = true;&#10;        &#10;        private float lastAttackTime;&#10;        private BossManager bossManager;&#10;&#10;        private void Start()&#10;        {&#10;            bossManager = BossManager.Instance;&#10;        }&#10;&#10;        private void Update()&#10;        {&#10;            HandleAttackInput();&#10;            HandleFaSkillInput();&#10;        }&#10;&#10;        private void HandleAttackInput()&#10;        {&#10;            // Space or Left Mouse Button to attack&#10;            if ((Input.GetKeyDown(KeyCode.Space) || Input.GetMouseButtonDown(0)) &amp;&amp; CanAttack())&#10;            {&#10;                PerformAttack();&#10;            }&#10;        }&#10;&#10;        private void HandleFaSkillInput()&#10;        {&#10;            // Q - Radar Skill&#10;            if (Input.GetKeyDown(KeyCode.Q))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Requesting Fa Radar Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;Radar&quot;, true);&#10;            }&#10;            &#10;            // E - Second Skill (example)&#10;            if (Input.GetKeyDown(KeyCode.E))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Second Skill&quot;);&#10;                FaBossIntegration.NotifyFaSkillUsed(&quot;SecondSkill&quot;, true);&#10;            }&#10;            &#10;            // R - Reveal Skill &#10;            if (Input.GetKeyDown(KeyCode.R))&#10;            {&#10;                Debug.Log(&quot;[Player Test] Using Fa Reveal Skill&quot;);&#10;                // Gọi trực tiếp FaSkillSimulator thay vì thông qua integration&#10;                var faSimulator = FindObjectOfType&lt;FaSkillSimulator&gt;();&#10;                if (faSimulator != null)&#10;                {&#10;                    faSimulator.UseThirdSkill();&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning(&quot;[Player Test] FaSkillSimulator not found in scene!&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        private bool CanAttack()&#10;        {&#10;            return Time.time &gt;= lastAttackTime + attackCooldown;&#10;        }&#10;&#10;        private void PerformAttack()&#10;        {&#10;            lastAttackTime = Time.time;&#10;            Debug.Log(&quot;[Player Test] Player attacking!&quot;);&#10;            &#10;            // Check if there's a boss or decoy in range&#10;            Collider[] hits = Physics.OverlapSphere(transform.position, attackRange);&#10;            &#10;            foreach (var hit in hits)&#10;            {&#10;                // Check for Boss&#10;                var boss = hit.GetComponent&lt;BossController&gt;();&#10;                if (boss != null)&#10;                {&#10;                    Debug.Log(&quot;[Player Test] Hit Boss directly!&quot;);&#10;                    if (bossManager != null)&#10;                    {&#10;                        bossManager.PlayerAttackBoss();&#10;                    }&#10;                    return;&#10;                }&#10;                &#10;                // Check for Decoy&#10;                var decoy = hit.GetComponent&lt;DecoyBehavior&gt;();&#10;                if (decoy != null)&#10;                {&#10;                    Debug.Log($&quot;[Player Test] Hit {(decoy.IsReal ? &quot;Real&quot; : &quot;Fake&quot;)} Decoy!&quot;);&#10;                    &#10;                    // Gọi trực tiếp OnAttacked() thay vì thông qua BossManager&#10;                    decoy.OnAttacked();&#10;                    return;&#10;                }&#10;            }&#10;            &#10;            Debug.Log(&quot;[Player Test] Attack missed - no target in range&quot;);&#10;        }&#10;&#10;        private void OnGUI()&#10;        {&#10;            if (!showDebugUI) return;&#10;            &#10;            GUILayout.BeginArea(new Rect(10, 10, 300, 200));&#10;            GUILayout.Label(&quot;=== PLAYER TEST CONTROLS ===&quot;);&#10;            GUILayout.Label(&quot;WASD: Move&quot;);&#10;            GUILayout.Label(&quot;Space/LMB: Attack&quot;);&#10;            GUILayout.Label(&quot;Q: Fa Radar Skill&quot;);&#10;            GUILayout.Label(&quot;E: Fa Second Skill&quot;);&#10;            GUILayout.Label(&quot;R: Fa Third Skill&quot;);&#10;            GUILayout.Space(10);&#10;            GUILayout.Label($&quot;Position: {transform.position}&quot;);&#10;            GUILayout.Label($&quot;Can Attack: {CanAttack()}&quot;);&#10;            GUILayout.EndArea();&#10;        }&#10;&#10;        private void OnDrawGizmosSelected()&#10;        {&#10;            // Draw attack range&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position, attackRange);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/README.md" />
              <option name="updatedContent" value="# Boss FSM Testing System&#10;&#10;##  Tổng quan&#10;Hệ thống test hoàn chỉnh để kiểm tra Boss FSM, bao gồm:&#10;- Player movement và attack simulation&#10;- 3 kỹ năng Fa (Radar, Protection, Reveal)&#10;- Boss state transitions và behaviors&#10;- UI testing và debug tools&#10;&#10;##  Cấu trúc Files&#10;&#10;### Core Testing Files:&#10;- **PlayerTestController.cs** - Điều khiển player test với WASD, attack, và Fa skills&#10;- **FaSkillSimulator.cs** - Giả lập 3 kỹ năng của Fa với cooldowns và effects&#10;- **BossTestManager.cs** - Manager chính setup toàn bộ test environment&#10;- **TestBossConfig.cs** - Tạo config tối ưu cho testing (thời gian ngắn)&#10;- **BossTestSceneSetup.cs** - Auto setup test scene với camera, lighting, UI&#10;&#10;##  Controls&#10;&#10;### Player Controls:&#10;- **WASD** - Di chuyển player&#10;- **Space/Left Mouse** - Tấn công&#10;- **Q** - Fa Radar Skill (phá hủy souls)&#10;- **E** - Fa Protection Skill (shield 5 giây)&#10;- **R** - Fa Reveal Skill (hiện bóng thật)&#10;&#10;### Debug Controls:&#10;- **F1** - Reset toàn bộ test&#10;- **F2** - Force chuyển phase&#10;- **F3** - Spawn test soul&#10;- **F4** - Damage boss trực tiếp&#10;- **F5** - Heal player&#10;&#10;##  Cách Setup Test&#10;&#10;### Phương pháp 1: Tự động (Khuyến nghị)&#10;1. Tạo empty scene mới&#10;2. Add component `BossTestSceneSetup` vào bất kỳ GameObject nào&#10;3. Click button &quot;Setup Test Scene&quot; trong inspector hoặc OnGUI&#10;4. Hoặc sử dụng menu: `Boss Test &gt; Setup Test Scene`&#10;&#10;### Phương pháp 2: Manual&#10;1. Tạo empty GameObject → Add `BossTestManager`&#10;2. Tạo test config: `Boss Test &gt; Create Test Config Asset`&#10;3. Assign config vào BossTestManager&#10;4. Run scene&#10;&#10;##  Test Features&#10;&#10;### Fa Skills Integration:&#10;```csharp&#10;// Kỹ năng 1: Radar - Phá hủy tất cả souls&#10;FaBossIntegration.NotifyFaSkillUsed(&quot;Radar&quot;, true);&#10;&#10;// Kỹ năng 2: Protection - Shield 5 giây&#10;FaBossIntegration.NotifyFaSkillUsed(&quot;Protection&quot;, true);&#10;&#10;// Kỹ năng 3: Reveal - Hiện bóng thật&#10;FaBossIntegration.NotifyFaSkillUsed(&quot;Reveal&quot;, true);&#10;```&#10;&#10;### Boss Event Integration:&#10;- Tự động suggest Radar khi có ≥2 souls&#10;- Thông báo khi boss vulnerable (DecoyState, ScreamState)&#10;- Real-time soul count tracking&#10;- Phase change notifications&#10;&#10;### Debug UI:&#10;- **Player Panel** - Position, movement, attack status&#10;- **Fa Skills Panel** - Cooldowns, skill status, boss info&#10;- **Test Manager Panel** - Quick actions, test statistics&#10;&#10;##  Test Scenarios&#10;&#10;### Phase 1 Testing:&#10;1. Boss starts in IdleState&#10;2. Transitions: Idle → Lure → Mock → Decoy&#10;3. **DecoyState**: Attack real decoy = boss damage, attack fake = player damage + SoulState&#10;4. **SoulState**: Boss teleports + spawns soul, suggests Fa Radar skill&#10;&#10;### Phase 2 Testing:&#10;1. Boss enters AngryState (circles around center)&#10;2. Random transitions: Angry → FearZone/Scream&#10;3. **FearZoneState**: Stay in dark zone 3s = vision blur + heartbeat&#10;4. **ScreamState**: Attack during scream = boss damage, miss = player damage + SoulState&#10;5. **CookState**: Boss defeated → memory fragment drop&#10;&#10;### Fa Skills Testing:&#10;- **Radar Skill**: Press Q to destroy all souls&#10;- **Protection Skill**: Press E for 5-second shield&#10;- **Reveal Skill**: Press R to highlight real decoy&#10;- Cooldown system prevents spam&#10;- Visual effects for each skill&#10;&#10;##  Test Statistics&#10;- Test duration tracking&#10;- Boss state monitoring&#10;- Health tracking (boss + player)&#10;- Soul count monitoring&#10;- Skill usage statistics&#10;&#10;##  Debug Features&#10;&#10;### Console Logs:&#10;```&#10;[Boss State] Entered IdleState - Boss đứng yên tại chỗ&#10;[Boss Animation] Playing animation: Idle&#10;[Player Test] Player attacking!&#10;[Fa Simulator] === RADAR SKILL ACTIVATED ===&#10;[Test] Boss took 1 damage&#10;```&#10;&#10;### Visual Debug:&#10;- Attack range visualization (red sphere)&#10;- Boss spawn radiuses (yellow/purple/red circles)&#10;- Skill effects (radar waves, shields, highlights)&#10;- Real-time UI status displays&#10;&#10;## ⚡ Performance Settings&#10;&#10;### Fast Testing Config:&#10;- Phase durations: 1-2 seconds (vs normal 3-5s)&#10;- Cast times: 0.8-1.5s (vs normal 2-3s)&#10;- Movement speeds: 1.5x faster&#10;- Favors DecoyState for quick testing&#10;&#10;### Production Ready:&#10;- Simply swap TestBossConfig với BossConfig thật&#10;- Uncomment animation code trong BossController&#10;- Add real audio clips và visual effects&#10;&#10;##  Troubleshooting&#10;&#10;### Common Issues:&#10;1. **No Boss spawned**: Check BossTestManager has testBossConfig assigned&#10;2. **Player can't move**: Ensure CharacterController is added&#10;3. **Skills not working**: Check FaSkillSimulator is in scene&#10;4. **No UI**: Verify Canvas is created in scene&#10;&#10;### Debug Commands:&#10;```csharp&#10;// Force specific state&#10;bossController.ChangeState(new DecoyState());&#10;&#10;// Manual skill trigger&#10;faSimulator.UseRadarSkill();&#10;&#10;// Check integration&#10;Debug.Log($&quot;Souls: {FaBossIntegration.GetCurrentSoulCount()}&quot;);&#10;Debug.Log($&quot;Phase: {FaBossIntegration.GetCurrentBossPhase()}&quot;);&#10;```&#10;&#10;##  Test Complete!&#10;Hệ thống test này cho phép bạn:&#10;- ✅ Test toàn bộ Boss FSM logic&#10;- ✅ Verify Fa skills integration&#10;- ✅ Debug state transitions&#10;- ✅ Performance testing&#10;- ✅ UI/UX validation&#10;- ✅ Dễ dàng chuyển sang production&#10;&#10;Happy Testing! " />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/Testing/TestBossConfig.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/Testing/TestBossConfig.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using Code.Boss;&#10;&#10;namespace Code.Boss.Testing&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Test configuration cho Boss system - tạo config tối ưu cho testing&#10;    /// &lt;/summary&gt;&#10;    [CreateAssetMenu(fileName = &quot;TestBossConfig&quot;, menuName = &quot;Boss/Test Boss Configuration&quot;)]&#10;    public class TestBossConfig : ScriptableObject&#10;    {&#10;        [Header(&quot;Create Test Config&quot;)]&#10;        [SerializeField] private bool autoCreateConfig = true;&#10;        &#10;        public BossConfig CreateTestConfig()&#10;        {&#10;            var config = ScriptableObject.CreateInstance&lt;BossConfig&gt;();&#10;            &#10;            // General settings - faster for testing&#10;            config.maxHealthPerPhase = 3;&#10;            config.moveSpeed = 8f;&#10;            config.rotationSpeed = 180f;&#10;            &#10;            // Phase 1 - shorter durations for quick testing&#10;            config.phase1 = new Phase1Config&#10;            {&#10;                idleDuration = 1f,&#10;                lureDuration = 2f,&#10;                mockDuration = 1.5f,&#10;                decoyCastTime = 1f,&#10;                decoyDuration = 5f,&#10;                soulStateCastTime = 0.8f,&#10;                &#10;                lureDistance = 3f,&#10;                lureApproachSpeed = 6f,&#10;                lureRetreatSpeed = 8f,&#10;                &#10;                decoyMoveSpeed = 3f,&#10;                decoyCount = 2,&#10;                decoySpawnRadius = 5f,&#10;                &#10;                enableRandomStates = true,&#10;                stateWeights = new float[] { 1f, 1f, 1f, 2f } // Favor Decoy for testing&#10;            };&#10;            &#10;            // Phase 2 - shorter durations for quick testing&#10;            config.phase2 = new Phase2Config&#10;            {&#10;                angryMoveDuration = 2f,&#10;                fearZoneCastTime = 1f,&#10;                fearZoneDuration = 4f,&#10;                fearZoneActivationTime = 1.5f,&#10;                screamCastTime = 1.5f,&#10;                screamDuration = 3f,&#10;                cookStateDuration = 2f,&#10;                &#10;                angryMoveSpeed = 4f,&#10;                circleRadius = 6f,&#10;                &#10;                fearZoneRadius = 2.5f,&#10;                visionBlurIntensity = 0.5f,&#10;                &#10;                screenShakeIntensity = 0.8f,&#10;                visionShrinkAmount = 0.4f&#10;            };&#10;            &#10;            // Soul settings&#10;            config.soulConfig = new SoulConfig&#10;            {&#10;                maxSouls = 2,&#10;                soulMoveSpeed = 5f,&#10;                soulSpawnRadius = 8f,&#10;                soulFollowDistance = 1.5f,&#10;                soulPrefab = null // Will be created dynamically in test&#10;            };&#10;            &#10;            // UI settings&#10;            config.uiConfig = new UIConfig&#10;            {&#10;                bossHealthPosition = new Vector2(0f, 0.85f),&#10;                playerHealthPosition = new Vector2(0f, -0.85f),&#10;                healthBarSize = new Vector2(200f, 20f),&#10;                skillCastBarOffset = new Vector2(0f, -30f),&#10;                skillCastBarSize = new Vector2(150f, 15f),&#10;                bossHealthColor = Color.red,&#10;                playerHealthColor = Color.green,&#10;                skillCastColor = Color.yellow&#10;            };&#10;            &#10;            // Audio settings (all null for testing)&#10;            config.audioConfig = new AudioConfig&#10;            {&#10;                mockLaughSound = null,&#10;                decoySpawnSound = null,&#10;                soulSpawnSound = null,&#10;                screamSound = null,&#10;                fearZoneSound = null,&#10;                heartbeatSound = null,&#10;                phaseChangeSound = null,&#10;                damageSound = null,&#10;                defeatSound = null,&#10;                masterVolume = 0.5f,&#10;                sfxVolume = 0.7f,&#10;                ambientVolume = 0.3f&#10;            };&#10;            &#10;            return config;&#10;        }&#10;        &#10;        private void OnValidate()&#10;        {&#10;            if (autoCreateConfig)&#10;            {&#10;                // Auto-create config when this ScriptableObject is created&#10;                // This will be called when the asset is created in Unity&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Boss/UI/BossUIManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Boss/UI/BossUIManager.cs" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/Character/Mode_PL_02/PlayerController_02.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/Character/Mode_PL_02/PlayerController_02.cs" />
              <option name="originalContent" value="using Duckle;&#10;using System;&#10;using UnityEngine;&#10;using UnityEngine.AI;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;&#10;public class PlayerController_02 : PlayerEventListenerBase&#10;{&#10;    #region biến cần thiết&#10;&#10;    [Header(&quot;Debug&quot;)]&#10;    private string mess = null;&#10;    [SerializeField] private float checkInterval = 0.1f;&#10;    private float lastCheckTime;&#10;    private Vector3 groundCheckPosition; // Vị trí kiểm tra mặt đất&#10;&#10;    [Header(&quot;Core base&quot;)]&#10;    private Core_02 _core_02;&#10;    private Animator _animator;&#10;    public PlayerConfig config;&#10;&#10;    [Header(&quot;Reference&quot;)]&#10;    public Rigidbody _rigidbody { get; private set; }&#10;    public NavMeshAgent _navMeshAgent { get; private set; }&#10;&#10;    public PlayerInput_02 _playerInput;&#10;    public Timer throwTimer = new Timer();&#10;&#10;    public CharacterStateType CurrentPlayerState;           // Trạng thái hiện tại của người chơi&#10;    public IUsable CurrentUsable { get; set; }&#10;&#10;    [Header(&quot;Body&quot;)]&#10;    public GameObject FacePlayer;                           // mặt người chơi (tạm thời)&#10;    [SerializeField] private List&lt;Transform&gt; ListBody;      //   Danh sách các slot vũ khí&#10;    public GameObject ListSlot;                             // Danh sách Slot (tạm thời)&#10;&#10;&#10;    [Header(&quot;Slot Settings&quot;)]&#10;    [SerializeField] private LayerMask invironmentLayer;    // Lớp để kiểm tra môi trường&#10;    [SerializeField] private LayerMask lookAtLayerMask;     // Lớp để kiểm tra đối tượng khi nhìn vào&#10;    public GameObject CurrentSourcesLookAt { get; set; }    // Đối tượng mà người chơi đang nhìn vào&#10;    [SerializeField] public GameObject RightHandObject;     // đối tượng đang được sử dụng (đang nằm trong tay phải)&#10;&#10;&#10;    [Header(&quot;Currrent character setting&quot;)]&#10;    private Vector3 lastRotationDirection = Vector3.forward;&#10;    [SerializeField] private bool useNavMesh = false;&#10;    [SerializeField] private bool isGrounded = true;&#10;&#10;    [Header(&quot;Nav character Settings&quot;)]&#10;    [SerializeField] private float N_speed = 1.3f;&#10;    [SerializeField] private float airDrag = 1f;&#10;    [SerializeField] private float extraGravity = 30f;&#10;&#10;    [SerializeField] private float JumpMomentumBoost = 2f;&#10;    [SerializeField] private float dashForce = 15f;         // lực dash&#10;    [SerializeField] private float dashDuration = 0.3f;     // thời gian dash&#10;    [SerializeField] private float dashMomentumBoost = 1.3f;// nhân vận tốc ngang&#10;&#10;    [Header(&quot;Character action Settings&quot;)]&#10;    public int previousIndex = -1;                          // Lưu chỉ mục trước đó của item được trang bị&#10;    public Coroutine deactivateCoroutine;                   // Coroutine để hủy kích hoạt item sau khi ném&#10;    [SerializeField] private GameObject markerPrefab;       // Prefab dùng để đánh dấu (test)&#10;    [SerializeField] private Material laserMaterial;        // Material cho laser line (test)&#10;    [SerializeField] private float laserWidth = 0.02f;      // Độ rộng của laser line (test)&#10;    private GameObject currentMarker;&#10;    private LineRenderer laserLine;&#10;    private float savedDistance = 0f;&#10;    private float savedHeight = 0f;&#10;    private bool isCameraSettingsSaved = false;&#10;&#10;    private float currentDirectionX = 0f;&#10;    private float currentDirectionZ = 0f;&#10;    [SerializeField] private float smoothSpeed = 10f; // Tốc độ làm mượt (có thể chỉnh trong Inspector)&#10;    public Vector3 CurrentLookAtHitPoint { get; private set; } // tọa độ điểm va chạm của tia nhìn&#10;&#10;    [Header(&quot;Attack Settings&quot;)]&#10;    public bool ActiveAttack = false;&#10;    public bool isAttacking;&#10;    public bool wait = false;&#10;    public float waitTimeAt = 2f; // Thời gian chờ 2 giây&#10;    private float timer = 0f;&#10;    private float lastAttackTime;&#10;&#10;    [SerializeField] private float[] attackDurations;&#10;    [SerializeField] private float groundCheckRadius = 1f; // Radius of the sphere for ground check&#10;    [SerializeField] private float groundCheckDistance = 0.4f; // Distance to check below the player&#10;&#10;    #endregion&#10;&#10;    protected override void Awake()&#10;    {&#10;        if (_core_02 == null) _core_02 = Core_02.Instance;&#10;        if (_rigidbody == null) _rigidbody = GetComponent&lt;Rigidbody&gt;();&#10;        if (_navMeshAgent == null) _navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();&#10;&#10;        base.Awake();&#10;        if (_core_02 == null)&#10;        {&#10;            Debug.LogError(&quot;Core_02 instance is null in PlayerController_02.&quot;);&#10;            _core_02 = Core_02.Instance;&#10;        }&#10;        _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;&#10;        // Cấu hình NavMeshAgent&#10;        if (_navMeshAgent != null)&#10;        {&#10;            _navMeshAgent.updatePosition = useNavMesh; // Chỉ cập nhật vị trí nếu dùng NavMesh&#10;            _navMeshAgent.updateRotation = false; // Tắt xoay tự động để tự xử lý&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        if (_playerInput == null) _playerInput = GetComponent&lt;PlayerInput_02&gt;();&#10;        if (_animator == null) _animator = GetComponent&lt;Animator&gt;();&#10;        if (_navMeshAgent == null)&#10;        {&#10;            _navMeshAgent = gameObject.AddComponent&lt;NavMeshAgent&gt;();&#10;            _navMeshAgent.updatePosition = useNavMesh;&#10;            _navMeshAgent.updateRotation = false;&#10;        }&#10;&#10;        _animator.SetInteger(&quot;State&quot;, 0); // Idle&#10;        _animator.SetFloat(&quot;DirectionX&quot;, 0f);&#10;        _animator.SetFloat(&quot;DirectionZ&quot;, 0f);&#10;    }&#10;&#10;    public void Update()&#10;    {&#10;        if (Input.GetKeyDown(KeyCode.N))&#10;        {&#10;            useNavMesh = !useNavMesh;&#10;            if (useNavMesh)&#10;            {&#10;                _navMeshAgent.Warp(transform.position); // Đồng bộ vị trí NavMeshAgent với Rigidbody&#10;                _navMeshAgent.updatePosition = true;&#10;            }&#10;            else&#10;            {&#10;                _navMeshAgent.updatePosition = false;&#10;            }&#10;            Debug.Log($&quot;Switched to {(useNavMesh ? &quot;NavMesh&quot; : &quot;Rigidbody&quot;)} movement.&quot;);&#10;        }&#10;&#10;        UsingResource();&#10;        CheckItemByLooking();&#10;&#10;        if (!aim)&#10;        {&#10;            // đợi 1 giây và setbool throw = false&#10;            if (_animator != null &amp;&amp; _animator.GetBool(&quot;Throw&quot;) == true)&#10;            {&#10;                _animator.SetBool(&quot;Throw&quot;, false);&#10;            }&#10;        }&#10;        WaitCheck();&#10;    }&#10;&#10;    private void LateUpdate()&#10;    {&#10;        if (_navMeshAgent != null &amp;&amp; isGrounded)&#10;        {&#10;            EnableNavMeshAgent();&#10;        }&#10;&#10;    }&#10;&#10;    private void FixedUpdate()&#10;    {&#10;        // AirControl: giảm quán tính ngang khi ở trên không&#10;        if (!isGrounded &amp;&amp; CurrentPlayerState == CharacterStateType.Jump)&#10;        {&#10;            Vector3 vel = _rigidbody.linearVelocity;&#10;            vel.x *= airDrag;&#10;            vel.z *= airDrag;&#10;            _rigidbody.linearVelocity = vel;&#10;&#10;            // tăng gravity&#10;            _rigidbody.AddForce(Vector3.down * extraGravity, ForceMode.Acceleration);&#10;        }&#10;    }&#10;&#10;    #region base Event/state&#10;&#10;    public override void RegisterEvent(PlayerEvent e)&#10;    {&#10;        e.OnChangePlayerState += UpdateCurrentPlayerState;&#10;    }&#10;&#10;    public override void UnregisterEvent(PlayerEvent e)&#10;    {&#10;        e.OnChangePlayerState -= UpdateCurrentPlayerState;&#10;    }&#10;&#10;    private void UpdateCurrentPlayerState(CharacterStateType stateType)&#10;    {&#10;        CurrentPlayerState = stateType;&#10;    }&#10;    #endregion&#10;&#10;    #region get input&#10;&#10;    public void PerformMoveInput(CharacterActionType actionType, Vector3 direction)&#10;    {&#10;        if (_core_02 == null)&#10;        {&#10;            Debug.LogError(&quot;Core_02 is null in PerformMoveInput.&quot;);&#10;            return;&#10;        }&#10;        if (_core_02._stateMachine == null)&#10;        {&#10;            Debug.LogError(&quot;StateMachine is null in PerformMoveInput.&quot;);&#10;            return;&#10;        }&#10;        if (config == null)&#10;        {&#10;            Debug.LogError(&quot;PlayerConfig is not assigned in PlayerController_02!&quot;);&#10;            return;&#10;        }&#10;&#10;        // Chuyển state&#10;        _core_02._stateMachine.HandleAction(actionType);&#10;&#10;        if (_animator != null)&#10;        {&#10;            SetAnimationParameters(actionType, direction);&#10;        }&#10;&#10;        float moveSpeed = config.walkSpeed; // mặc định là walk&#10;        // Chọn tốc độ dựa trên type action&#10;        switch (actionType)&#10;        {&#10;            case CharacterActionType.Run:&#10;                moveSpeed = config.runSpeed;&#10;                break;&#10;            case CharacterActionType.Sprint:&#10;                moveSpeed = config.sprintSpeed;&#10;                break;&#10;            case CharacterActionType.Jump:&#10;                Jump(config.jumpImpulse);&#10;                return;&#10;            case CharacterActionType.Dash:&#10;                Dash();&#10;                return;&#10;        }&#10;&#10;        if (!isGrounded &amp;&amp; CurrentPlayerState != CharacterStateType.Jump &amp;&amp; CurrentPlayerState != CharacterStateType.Dash)&#10;            HelpCheckGround();&#10;        if (isGrounded &amp;&amp; !isAttacking)&#10;        {&#10;            // Chọn phương thức di chuyển&#10;            if (useNavMesh &amp;&amp; _navMeshAgent != null)&#10;            {&#10;                MoveNavMesh(direction, moveSpeed, actionType);&#10;            }&#10;            else&#10;            {&#10;                Move(direction * moveSpeed, actionType);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void PerformAttackInput(CharacterActionType actionType, Vector3 direction)&#10;    {&#10;        _core_02._stateMachine.HandleAction(actionType);&#10;        //Debug.LogWarning($&quot;PerformAttackInput: {actionType} with direction {direction}&quot;);&#10;&#10;        switch (actionType)&#10;        {&#10;            case CharacterActionType.Attack:&#10;                if (ActiveAttack)&#10;                {&#10;                    //Attack(direction, config.attackRange, config.attackDuration, config.attackDamage, config.attackCooldown);&#10;                    int attackIndex = GetAttackIndexFromDirection(direction);&#10;                    if (!isAttacking)&#10;                    {&#10;                        TryAttack(attackIndex);&#10;                    }&#10;                }&#10;                break;&#10;            case CharacterActionType.ThrowItem:&#10;                Thrown(2f); // tạm thời&#10;                break;&#10;            case CharacterActionType.ThrowWeapon:&#10;                Thrown(config.throwForce);&#10;                break;&#10;        }&#10;    }&#10;&#10;    public void PerformInteractInput(CharacterActionType actionType, GameObject currentSources)&#10;    {&#10;        _core_02._stateMachine.HandleAction(actionType);&#10;&#10;        switch (actionType)&#10;        {&#10;            case CharacterActionType.PickUp:&#10;                PickUp();&#10;                break;&#10;            case CharacterActionType.Drop:&#10;&#10;                break;&#10;            case CharacterActionType.Active:&#10;&#10;                break;&#10;        }&#10;    }&#10;&#10;    #endregion&#10;&#10;    #region Action Resource&#10;    public void EquipUsable(IUsable usable)&#10;    {&#10;        if (usable == null)&#10;        {&#10;            Debug.LogError(&quot;Attempted to equip null usable&quot;);&#10;            return;&#10;        }&#10;        CurrentUsable = usable;&#10;        Debug.Log($&quot;Equipped usable: {CurrentUsable.Name}&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Sử dụng tài nguyên từ ListBody[1] (tay phải).&#10;    /// &lt;/summary&gt;&#10;    public void UsingResource()&#10;    {&#10;        if (ListBody == null)&#10;        {&#10;            Debug.LogError(&quot;ListBody is null! Please initialize it in the Inspector or code.&quot;);&#10;            return;&#10;        }&#10;&#10;        // kiểm tra ListBody[1] có tồn tại và có con không&#10;        if (ListBody.Count &gt; 2 &amp;&amp; ListBody[1] != null &amp;&amp; ListBody[1].childCount &gt; 0)&#10;        {&#10;            Transform childTransform = ListBody[1].transform.GetChild(0);&#10;            if (childTransform != null)&#10;            {&#10;                GameObject childObject = childTransform.gameObject;&#10;                RightHandObject = childObject;&#10;                Component component = null;&#10;&#10;                Component[] components = RightHandObject.GetComponents&lt;Component&gt;();&#10;                foreach (var c in components)&#10;                {&#10;                    if (c.GetType().Name == &quot;Weapon&quot;)&#10;                    {&#10;                        component = c;&#10;                        break;&#10;                    }&#10;                    else if (c.GetType().Name == &quot;Loot&quot;)&#10;                    {&#10;                        component = c;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (component is IUsable usable)&#10;                {&#10;                    CurrentUsable = usable;&#10;                    EquipUsable(CurrentUsable);&#10;                    Debug.Log($&quot;Equipped usable: {CurrentUsable.Name}, Classify: {CurrentUsable.Classify}, Effect Value: {CurrentUsable.GetEffectValue()}&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;Weapons component not found on {RightHandObject.name}!&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No GameObject found in the children of ListBody[1]!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            //Debug.LogWarning(&quot;ListBody[1] is null or has no children!&quot;);&#10;        }&#10;    }&#10;    #endregion&#10;&#10;    #region Move&#10;&#10;    /// &lt;summary&gt;&#10;    /// Move bằng Rigidbody.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;direction&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;moveType&quot;&gt;&lt;/param&gt;&#10;    private void Move(Vector3 direction, CharacterActionType moveType)&#10;    {&#10;        float acceleration = config.acceleration;&#10;        float rotationSpeed = config.rotationSpeed;&#10;&#10;        if (this._rigidbody == null)&#10;        {&#10;            Debug.LogError(&quot;Rigidbody is null in MoveAction.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (direction.sqrMagnitude &lt;= 0.001f &amp;&amp; moveType != CharacterActionType.Jump)&#10;        {&#10;            _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;            return;&#10;        }&#10;&#10;        _rigidbody.interpolation = RigidbodyInterpolation.Interpolate;&#10;        float deltaTime = Time.fixedDeltaTime;&#10;        Vector3 currentVelocity = this._rigidbody.linearVelocity;&#10;&#10;        Vector3 targetVelocity = direction;&#10;        Vector3 horizontalVelocity = new Vector3(currentVelocity.x, 0f, currentVelocity.z);&#10;        Vector3 velocityChange = targetVelocity - horizontalVelocity;&#10;&#10;        velocityChange = Vector3.ClampMagnitude(velocityChange, acceleration * deltaTime);&#10;        this._rigidbody.linearVelocity += new Vector3(velocityChange.x, 0f, velocityChange.z);&#10;&#10;        Quaternion currentRotation = this._rigidbody.rotation;&#10;&#10;        if (_playerInput == null)&#10;        {&#10;            Debug.LogError(&quot;_playerInput is null in MoveAction.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (_playerInput._characterCamera == null)&#10;        {&#10;            Debug.LogWarning(&quot;_characterCamera is null in MoveAction. Using default rotation.&quot;);&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;&#10;            if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;                this._rigidbody.MoveRotation(Quaternion.Lerp(currentRotation, targetRotation, rotationSpeed * deltaTime));&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (!_playerInput._characterCamera.isAiming)&#10;        {&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;&#10;            if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;                this._rigidbody.MoveRotation(Quaternion.Lerp(currentRotation, targetRotation, rotationSpeed * deltaTime));&#10;            }&#10;        }&#10;&#10;        else if (_playerInput._characterCamera.mainCamera != null)&#10;        {&#10;            Vector3 camForward = _playerInput._characterCamera.mainCamera.transform.forward;&#10;            camForward.y = 0;&#10;&#10;            if (camForward./*direction.*/sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = camForward.normalized /*direction*/;&#10;            }&#10;&#10;            if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;                this._rigidbody.MoveRotation(Quaternion.Lerp(currentRotation, targetRotation, rotationSpeed * deltaTime));&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Move bằng NavMeshAgent.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;direction&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;moveSpeed&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;moveType&quot;&gt;&lt;/param&gt;&#10;    private void MoveNavMesh(Vector3 direction, float moveSpeed, CharacterActionType moveType)&#10;    {&#10;        float speed_n = N_speed;&#10;        float deltaTime = Time.fixedDeltaTime;&#10;&#10;        if (_navMeshAgent == null)&#10;        {&#10;            Debug.LogError(&quot;NavMeshAgent is null in MoveNavMesh.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (direction.sqrMagnitude &lt;= 0.001f &amp;&amp; moveType != CharacterActionType.Jump)&#10;        {&#10;            _navMeshAgent.isStopped = true;&#10;            _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;            return;&#10;        }&#10;        _rigidbody.interpolation = RigidbodyInterpolation.None;&#10;&#10;        // Cập nhật tốc độ của NavMeshAgent&#10;        _navMeshAgent.speed = moveSpeed * speed_n;&#10;        _navMeshAgent.angularSpeed = config.rotationSpeed * config.rotationSpeed;&#10;        _navMeshAgent.acceleration = config.acceleration * speed_n;&#10;&#10;        // Tính toán điểm đích dựa trên hướng di chuyển&#10;        Vector3 targetPosition = transform.position + direction * moveSpeed /* * deltaTime*/;&#10;&#10;        // Đặt điểm đích cho NavMeshAgent&#10;        _navMeshAgent.isStopped = false;&#10;        _navMeshAgent.SetDestination(targetPosition);&#10;&#10;        // Xử lý xoay nhân vật&#10;        if (_playerInput == null)&#10;        {&#10;            Debug.LogError(&quot;_playerInput is null in MoveNavMesh.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (_playerInput._characterCamera == null)&#10;        {&#10;            Debug.LogWarning(&quot;_characterCamera is null in MoveNavMesh. Using default rotation.&quot;);&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;        }&#10;        else if (!_playerInput._characterCamera.isAiming)&#10;        {&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;        }&#10;        else if (_playerInput._characterCamera.mainCamera != null)&#10;        {&#10;            Vector3 camForward = _playerInput._characterCamera.mainCamera.transform.forward;&#10;            camForward.y = 0;&#10;            if (camForward.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = camForward.normalized;&#10;            }&#10;        }&#10;&#10;        // Xoay nhân vật&#10;        if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;        {&#10;            Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, config.rotationSpeed * deltaTime);&#10;        }&#10;    }&#10;&#10;    private bool Jump(float jumpForce)&#10;    {&#10;        if (!isGrounded)&#10;        {&#10;            //Debug.Log(&quot;Cannot jump: Player is not grounded.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (_animator != null)&#10;        {&#10;            SetAnimationParameters(CharacterActionType.Jump, Vector3.zero);&#10;        }&#10;&#10;        if (useNavMesh &amp;&amp; _navMeshAgent != null)&#10;        {&#10;            _navMeshAgent.enabled = false;&#10;            _rigidbody.isKinematic = false;&#10;            _rigidbody.interpolation = RigidbodyInterpolation.Interpolate;&#10;        }&#10;&#10;        Vector3 horizontalVel = new Vector3(_rigidbody.linearVelocity.x, 0, _rigidbody.linearVelocity.z);&#10;&#10;        if (horizontalVel.sqrMagnitude &lt; 0.01f &amp;&amp; _playerInput != null)&#10;            horizontalVel = _playerInput.GetMoveInput().normalized * config.runSpeed;&#10;&#10;        float momentumBoost = JumpMomentumBoost; // boost&#10;        Vector3 jumpVelocity = (horizontalVel * momentumBoost) + Vector3.up * jumpForce;&#10;&#10;        _rigidbody.linearVelocity = jumpVelocity;&#10;&#10;        isGrounded = false;&#10;        _core_02._stateMachine.SetState(new JumpState(_core_02._stateMachine, _playerEvent));&#10;        return true;&#10;    }&#10;&#10;    private bool Dash()&#10;    {&#10;        try&#10;        {&#10;            if (isGrounded)&#10;            {&#10;                Debug.Log(&quot;Cannot dash: Player is grounded.&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (_animator != null) _animator.SetTrigger(&quot;Dash&quot;);&#10;            if (useNavMesh &amp;&amp; _navMeshAgent != null)&#10;            {&#10;                _navMeshAgent.enabled = false;&#10;                _rigidbody.isKinematic = false;&#10;            }&#10;&#10;            // Giữ vận tốc ngang hiện tại và tăng cường&#10;            Vector3 horizontalVel = new Vector3(_rigidbody.linearVelocity.x, 0, _rigidbody.linearVelocity.z);&#10;            if (horizontalVel.sqrMagnitude &lt; 0.01f &amp;&amp; _playerInput != null)&#10;            {&#10;                Vector3 inputDir = _playerInput.GetMoveInput();&#10;                if (inputDir.sqrMagnitude &gt; 0.01f)&#10;                    horizontalVel = inputDir.normalized * config.runSpeed;&#10;            }&#10;&#10;            // Tạo vận tốc dash&#10;            Vector3 dashVelocity = horizontalVel.normalized * (horizontalVel.magnitude * dashMomentumBoost + dashForce);&#10;            dashVelocity.y = _rigidbody.linearVelocity.y; // giữ Y (đang rơi)&#10;&#10;            // Gán velocity ngay lập tức&#10;            _rigidbody.linearVelocity = dashVelocity;&#10;&#10;            //Debug.Log($&quot;Dashing with velocity: {dashVelocity}&quot;);&#10;&#10;            // Chuyển state Dash&#10;            _core_02._stateMachine.SetState(new DashState(_core_02._stateMachine, _playerEvent));&#10;&#10;            // Dừng dash sau dashDuration&#10;            StartCoroutine(EndDashAfterTime(dashDuration));&#10;&#10;            return true;&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            mess = e.Message;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private IEnumerator EndDashAfterTime(float time)&#10;    {&#10;        yield return new WaitForSeconds(time);&#10;&#10;        // Sau khi dash, trở về JumpState (vì vẫn đang trên không)&#10;        if (!isGrounded)&#10;        {&#10;            _core_02._stateMachine.SetState(new JumpState(_core_02._stateMachine, _playerEvent));&#10;        }&#10;    }&#10;&#10;    private void EnableNavMeshAgent()&#10;    {&#10;        if (_navMeshAgent != null)&#10;        {&#10;            _navMeshAgent.enabled = true;&#10;&#10;        }&#10;    }&#10;&#10;    #endregion&#10;&#10;    #region Attack&#10;    private IEnumerator ThrownCoroutine(float force, float delay)&#10;    {&#10;&#10;        _animator.SetBool(&quot;Throw&quot;, true);&#10;&#10;        // Đợi một khoảng thời gian để animation chạy&#10;        yield return new WaitForSeconds(delay);&#10;&#10;        GameObject thrownObject = RightHandObject?.gameObject;&#10;        if (thrownObject != null)&#10;        {&#10;            thrownObject.SetActive(true);&#10;            RightHandObject.gameObject.transform.SetParent(null);&#10;            RightHandObject = null;&#10;        }&#10;        if (thrownObject == null)&#10;        {&#10;            // Tạo một đối tượng ném mặc định nếu không có item nào được trang bị&#10;            GameObject DefaulObjThrow = Resources.Load&lt;GameObject&gt;(config.prefabPath);&#10;            if (DefaulObjThrow == null)&#10;            {&#10;                Debug.LogError($&quot;Prefab not found at path: {config.prefabPath}&quot;);&#10;                yield break;&#10;            }&#10;            thrownObject = Instantiate(DefaulObjThrow);&#10;        }&#10;&#10;        _core_02._stateMachine.SetState(new ThrowWeaponState(_core_02._stateMachine, _playerEvent));&#10;&#10;        if (_animator != null)&#10;        {&#10;            SetAnimationParameters(CharacterActionType.ThrowItem, Vector3.zero);&#10;        }&#10;&#10;        Ray camRay = GetCameraRayCenter();&#10;        Vector3 forward = camRay.direction.normalized;&#10;&#10;        Vector3 spawnPosition = FacePlayer.transform.position + forward * 1.5f;&#10;        thrownObject.transform.position = spawnPosition;&#10;&#10;        if (thrownObject.TryGetComponent&lt;Rigidbody&gt;(out var rb))&#10;        {&#10;            rb.linearVelocity = forward * force;&#10;        }&#10;        if (thrownObject.TryGetComponent&lt;ThrowableObject&gt;(out var throwable))&#10;        {&#10;            throwable.SetThrower_02(this);&#10;            if (CurrentUsable != null) throwable.SetUsableData(CurrentUsable.Name, CurrentUsable.GetEffectValue());&#10;        }&#10;&#10;        CurrentUsable?.OnUse_2(this);&#10;&#10;    }&#10;&#10;    private void Thrown(float force)&#10;    {&#10;        StartCoroutine(ThrownCoroutine(force, 0.2f)); // Độ trễ 0.5 giây, bạn có thể điều chỉnh&#10;    }&#10;&#10;    private int GetAttackIndexFromDirection(Vector3 direction)&#10;    {&#10;        // Chuẩn hóa direction để dễ so sánh&#10;        direction = direction.normalized;&#10;&#10;        // Tính góc giữa direction và các hướng chuẩn&#10;        float dotRight = Vector3.Dot(direction, Vector3.right);&#10;        float dotLeft = Vector3.Dot(direction, Vector3.left);&#10;        float dotForward = Vector3.Dot(direction, Vector3.forward);&#10;        float dotBack = Vector3.Dot(direction, Vector3.back);&#10;&#10;        // Tìm hướng có giá trị dot lớn nhất (gần nhất với direction)&#10;        float maxDot = Mathf.Max(dotRight, dotLeft, dotForward, dotBack);&#10;&#10;        if (maxDot &lt; 0.5f) // Ngưỡng để đảm bảo hướng rõ ràng&#10;        {&#10;            return 3; // Không xác định được hướng&#10;        }&#10;&#10;        if (maxDot == dotRight)&#10;            return 1; // Right&#10;        if (maxDot == dotLeft)&#10;            return 2; // Left&#10;        if (maxDot == dotForward)&#10;            return 3; // Forward&#10;        if (maxDot == dotBack)&#10;            return 4; // Back&#10;&#10;        return 0; // Trường hợp không xác định&#10;    }&#10;&#10;    private bool TryAttack(int attackIndex)&#10;    {&#10;        // Kiểm tra chỉ số hợp lệ&#10;        if (attackIndex &lt; 1 || attackIndex &gt; attackDurations.Length)&#10;        {&#10;            Debug.LogError($&quot;Invalid attack index: {attackIndex}&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Lấy thời lượng animation tương ứng&#10;        float attackDuration = attackDurations[attackIndex - 1];&#10;        float attackCooldown = attackDuration + 0.5f; // Cooldown bằng thời gian animation + buffer&#10;&#10;        // Kiểm tra cooldown&#10;        if (Time.time - lastAttackTime &lt; attackCooldown)&#10;        {&#10;            Debug.Log(&quot;Attack on cooldown.&quot;);&#10;            return false;&#10;        }&#10;&#10;        return Attack(Vector3.forward, config.attackRange, attackDuration, config.attackDamage, attackCooldown, attackIndex);&#10;    }&#10;&#10;    private bool Attack(Vector3 attackDir, float attackRange, float attackDuration, float attackDamage, float attackCooldown, int attackIndex)&#10;    {&#10;        try&#10;        {&#10;            if (_animator == null)&#10;            {&#10;                Debug.LogWarning(&quot;Animator is null in Attack. No animation will be played.&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Thiết lập parameter để chạy animation&#10;            isAttacking = true;&#10;            lastAttackTime = Time.time;&#10;            _animator.SetInteger(&quot;AnimationIndex&quot;, attackIndex);&#10;&#10;&#10;            //Debug.Log($&quot;Performing attack {attackIndex} with range={attackRange}, duration={attackDuration}, damage={attackDamage}, cooldown={attackCooldown}&quot;);&#10;&#10;            _core_02._stateMachine.SetState(new AttackState(_core_02._stateMachine, _playerEvent));&#10;&#10;            //Kiểm tra va chạm với đối tượng trong phạm vi tấn công&#10;            Collider[] hits = Physics.OverlapSphere(transform.position + transform.forward * attackRange * 0.5f, attackRange);&#10;            foreach (Collider hit in hits)&#10;            {&#10;                if (hit.CompareTag(&quot;Boss&quot;))&#10;                {&#10;                    PlayerEvent.Instance.TriggerTakeOutDamage(this.gameObject, attackDamage, hit.gameObject);&#10;                    Debug.Log($&quot;Hit {hit.gameObject.name} with attack {attackIndex}, damage: {attackDamage} at range: {attackRange}.&quot;);&#10;                }&#10;            }&#10;&#10;            // Đặt lại trạng thái sau khi animation hoàn thành&#10;            Invoke(nameof(ResetAttackState), attackDuration);&#10;&#10;            //ApplyForceAttack(attackIndex, _rigidbody);&#10;            StartCoroutine(WaitApplyForceAttack(attackIndex, _rigidbody));&#10;&#10;            Debug.Log($&quot;Attack {attackIndex} performed: range={attackRange}, duration={attackDuration}, damage={attackDamage}, cooldown={attackCooldown}&quot;);&#10;            return true;&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            Debug.LogError($&quot;Attack failed: {e.Message}&quot;);&#10;            isAttacking = false; // Đặt lại trạng thái nếu lỗi&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private void ResetAttackState()&#10;    {&#10;        isAttacking = false; // Cho phép attack tiếp theo sau khi animation hoàn thành&#10;        _animator.SetInteger(&quot;AnimationIndex&quot;, 0); // Đặt lại parameter về trạng thái mặc định (nếu cần)&#10;    }&#10;&#10;    private IEnumerator WaitApplyForceAttack(int attackIndex, Rigidbody rb)&#10;    {&#10;        // Đợi một khoảng thời gian trước khi áp dụng lực&#10;        yield return new WaitForSeconds(0.7f);&#10;        ApplyForceAttack(attackIndex, rb);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// tạo lực cho Rigidbody dựa trên attackIndex.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;attackIndex&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;rb&quot;&gt;&lt;/param&gt;&#10;    public void ApplyForceAttack(int attackIndex, Rigidbody rb)&#10;    {&#10;        // Lấy hướng phía trước của nhân vật&#10;        Vector3 forwardDirection = transform.forward;&#10;&#10;        switch (attackIndex)&#10;        {&#10;            case 1:&#10;                // Lực hướng về phía trước, cường độ 5f&#10;                //rb.AddForce(forwardDirection * 15f, ForceMode.Impulse);&#10;                ApplyRadialForce(rb, 15f, false);&#10;                Debug.LogWarning(&quot;Applied force for attack 1: Forward direction with intensity 5f.&quot;);&#10;                break;&#10;&#10;            case 2:&#10;                // Lực hướng về phía trước, cường độ 4f&#10;                //rb.AddForce(forwardDirection * 20f, ForceMode.Impulse);&#10;                ApplyRadialForce(rb, 20f, true);&#10;                Debug.LogWarning(&quot;Applied force for attack 2: Forward direction with intensity 4f.&quot;);&#10;                break;&#10;&#10;            case 3:&#10;                // Lực hướng ra tất cả các hướng xung quanh (trừ hướng xuống)&#10;                ApplyRadialForce(rb, 30f, false);&#10;                Debug.LogWarning(&quot;Applied radial force for attack 3: All directions except down with intensity 6f.&quot;);&#10;                break;&#10;&#10;            case 4:&#10;                // Lực hướng ra tất cả các hướng xung quanh (trừ hướng lên)&#10;                ApplyRadialForce(rb, 40f, true);&#10;                Debug.LogWarning(&quot;Applied radial force for attack 4: All directions except up with intensity 10f.&quot;);&#10;                break;&#10;&#10;            default:&#10;                Debug.LogWarning(&quot;Invalid attackIndex: &quot; + attackIndex);&#10;                break;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// hàm phụ để tạo lực hướng ra xung quanh từ vị trí của nhân vật.&#10;    /// nhận vào 3 tham số: Rigidbody, cường độ lực và Bool ForceUp.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;rb&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;forceMagnitude&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;excludeUp&quot;&gt;&lt;/param&gt;&#10;    private void ApplyRadialForce(Rigidbody rb, float forceMagnitude, bool excludeUp)&#10;    {&#10;        // Lấy tất cả các Rigidbody trong bán kính 10f&#10;        Collider[] colliders = Physics.OverlapSphere(transform.position, 10f);&#10;&#10;        foreach (Collider col in colliders)&#10;        {&#10;            Rigidbody targetRb = col.GetComponent&lt;Rigidbody&gt;();&#10;            if (targetRb != null &amp;&amp; targetRb != rb) // Không áp dụng lực cho chính nhân vật&#10;            {&#10;                // Tính hướng từ nhân vật đến đối tượng&#10;                Vector3 direction = (col.transform.position - transform.position).normalized;&#10;&#10;                // Nếu excludeUp = true, loại bỏ thành phần hướng lên (y dương)&#10;                if (excludeUp &amp;&amp; direction.y &gt; 0)&#10;                {&#10;                    direction.y = 0;&#10;                    direction = direction.normalized;&#10;                }&#10;                // Nếu excludeUp = false, loại bỏ thành phần hướng xuống (y âm)&#10;                else if (!excludeUp &amp;&amp; direction.y &lt; 0)&#10;                {&#10;                    direction.y = 0;&#10;                    direction = direction.normalized;&#10;                }&#10;&#10;                // Áp dụng lực&#10;                targetRb.AddForce(direction * forceMagnitude, ForceMode.Impulse);&#10;            }&#10;        }&#10;    }&#10;&#10;    #endregion&#10;&#10;    #region Animation Parameters&#10;    private void SetAnimationParameters(CharacterActionType actionType, Vector3 dir)&#10;    {&#10;        if (_animator == null)&#10;        {&#10;            Debug.LogWarning(&quot;Animator is null in SetAnimationParameters.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Ánh xạ actionType sang State&#10;        int state = actionType switch&#10;        {&#10;            CharacterActionType.Idle =&gt; 0,&#10;            CharacterActionType.Walk =&gt; 1,&#10;            CharacterActionType.Run =&gt; 2,&#10;            CharacterActionType.Sprint =&gt; 3,&#10;            CharacterActionType.Dash =&gt; 4,&#10;            CharacterActionType.Attack =&gt; 5,&#10;            CharacterActionType.Jump =&gt; 6,&#10;            CharacterActionType.ThrowItem =&gt; 7,&#10;            CharacterActionType.ThrowWeapon =&gt; 8,&#10;            _ =&gt; 0 // Mặc định là Idle&#10;        };&#10;&#10;        // Set State&#10;        _animator.SetInteger(&quot;State&quot;, state);&#10;&#10;        // Tính toán hướng nếu cần&#10;        float targetDirectionX = 0f;&#10;        float targetDirectionZ = 0f;&#10;        if (actionType == CharacterActionType.Walk || actionType == CharacterActionType.Run ||&#10;            actionType == CharacterActionType.Sprint || actionType == CharacterActionType.Dash ||&#10;            actionType == CharacterActionType.Attack)&#10;        {&#10;            // Nếu không có hướng di chuyển, sử dụng hướng nhân vật đang đối mặt&#10;            if (dir.sqrMagnitude &lt;= 0.001f)&#10;            {&#10;                if (actionType != CharacterActionType.Attack)&#10;                {&#10;                    _animator.SetInteger(&quot;State&quot;, 0); // Idle&#10;                    _animator.SetFloat(&quot;DirectionX&quot;, 0f);&#10;                    _animator.SetFloat(&quot;DirectionZ&quot;, 0f);&#10;                    currentDirectionX = 0f;&#10;                    currentDirectionZ = 0f;&#10;                    return;&#10;                }&#10;                dir = lastRotationDirection;&#10;            }&#10;&#10;            // Lấy hướng camera (nếu có) hoặc hướng nhân vật&#10;            Vector3 referenceForward = _playerInput._characterCamera?.mainCamera != null&#10;                ? _playerInput._characterCamera.mainCamera.transform.forward&#10;                : transform.forward;&#10;            referenceForward.y = 0;&#10;            referenceForward = referenceForward.normalized;&#10;&#10;            Vector3 referenceRight = Vector3.Cross(Vector3.up, referenceForward).normalized;&#10;&#10;            // Tính Dot product để xác định hướng mục tiêu&#10;            targetDirectionX = Vector3.Dot(dir.normalized, referenceRight);&#10;            targetDirectionZ = Vector3.Dot(dir.normalized, referenceForward);&#10;        }&#10;&#10;        // Làm mượt DirectionX và DirectionZ&#10;        currentDirectionX = Mathf.Lerp(currentDirectionX, targetDirectionX, smoothSpeed * Time.deltaTime);&#10;        currentDirectionZ = Mathf.Lerp(currentDirectionZ, targetDirectionZ, smoothSpeed * Time.deltaTime);&#10;&#10;        // Set DirectionX và DirectionZ&#10;        _animator.SetFloat(&quot;DirectionX&quot;, currentDirectionX);&#10;        _animator.SetFloat(&quot;DirectionZ&quot;, currentDirectionZ);&#10;&#10;        //Debug.Log($&quot;SetAnimationParameters: State={state}, DirectionX={currentDirectionX}, DirectionZ={currentDirectionZ}, TargetX={targetDirectionX}, TargetZ={targetDirectionZ}, dir={dir}&quot;);&#10;    }&#10;&#10;    // Hàm chạy animation tương ứng&#10;    private void PlayAnimation(int index)&#10;    {&#10;        // Đảm bảo Animator đã được gán&#10;        if (_animator == null)&#10;        {&#10;            Debug.LogError(&quot;Animator chưa được gán trong Inspector!&quot;);&#10;            return;&#10;        }&#10;&#10;        // Tên parameter trong Animator, giả sử là &quot;AnimationIndex&quot;&#10;        _animator.SetInteger(&quot;AnimationIndex&quot;, index);&#10;    }&#10;    #endregion&#10;&#10;    #region check collision&#10;&#10;    private void OnCollisionEnter(Collision collision)&#10;    {&#10;        if (collision?.gameObject.CompareTag(&quot;Ground&quot;) == true)&#10;        {&#10;            isGrounded = true;&#10;&#10;            // Triệt tiêu quán tính ngang khi tiếp đất&#10;            Vector3 vel = _rigidbody.linearVelocity;&#10;            vel.x = 0;&#10;            vel.z = 0;&#10;            _rigidbody.linearVelocity = vel;&#10;&#10;            // Thoát JumpState&#10;            if (CurrentPlayerState == CharacterStateType.Jump)&#10;            {&#10;                _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void OnCollisionExit(Collision collision)&#10;    {&#10;        if (collision == null) { return; }&#10;&#10;        if (collision.gameObject.CompareTag(&quot;Ground&quot;))&#10;        {&#10;            isGrounded = false;&#10;        }&#10;    }&#10;&#10;    private void HelpCheckGround()&#10;    {&#10;        //if (Time.time - lastCheckTime &lt; checkInterval) return;&#10;        //lastCheckTime = Time.time;&#10;&#10;        groundCheckPosition = transform.position + Vector3.down * 0.2f;&#10;&#10;        isGrounded = Physics.CheckSphere(groundCheckPosition, groundCheckRadius, invironmentLayer);&#10;    }&#10;&#10;    private void OnDrawGizmos()&#10;    {&#10;        if (config != null)&#10;        {&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position + transform.forward * config.attackRange * 0.5f, config.attackRange);&#10;&#10;            Gizmos.color = isGrounded ? Color.green : Color.red;&#10;            Gizmos.DrawWireSphere(groundCheckPosition, groundCheckRadius);&#10;        }&#10;    }&#10;    #endregion&#10;&#10;    #region Actions &amp; logic Action&#10;&#10;    private bool WaitCheck()&#10;    {&#10;        if (Input.GetMouseButtonDown(0) &amp;&amp; !wait)&#10;        {&#10;            wait = true;&#10;            timer = waitTimeAt;&#10;        }&#10;        if (wait)&#10;        {&#10;            timer -= Time.deltaTime;&#10;            if (timer &lt;= 0)&#10;            {&#10;                wait = false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Trả về hướng nhìn hiện tại của camera từ trung tâm màn hình.&#10;    /// &lt;/summary&gt;&#10;    public Ray GetCameraRayCenter()&#10;    {&#10;        Camera cam = Camera.main;&#10;        return cam != null&#10;            ? cam.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f))&#10;            : new Ray(Vector3.zero, Vector3.forward);&#10;    }&#10;&#10;    public void MarkHitPoint(Vector3 point)&#10;    {&#10;        // Tạo marker&#10;        if (currentMarker == null &amp;&amp; markerPrefab != null)&#10;        {&#10;            currentMarker = Instantiate(markerPrefab);&#10;        }&#10;&#10;        if (currentMarker != null)&#10;        {&#10;            currentMarker.transform.position = point;&#10;        }&#10;&#10;        // Tạo laser&#10;        if (laserLine == null)&#10;        {&#10;            GameObject laserObj = new GameObject(&quot;LaserLine&quot;);&#10;            laserLine = laserObj.AddComponent&lt;LineRenderer&gt;();&#10;            laserLine.material = laserMaterial;&#10;            laserLine.positionCount = 2;&#10;            laserLine.startWidth = laserWidth;&#10;            laserLine.endWidth = laserWidth;&#10;            laserLine.useWorldSpace = true;&#10;        }&#10;&#10;        // 3. Cập nhật line&#10;        Camera cam = Camera.main;&#10;        if (cam != null)&#10;        {&#10;            laserLine.SetPosition(0, FacePlayer.transform.position);&#10;            laserLine.SetPosition(1, point);&#10;        }&#10;    }&#10;&#10;    public Vector3 ReturnPoinHit()&#10;    {&#10;        if (CurrentLookAtHitPoint != null)&#10;        {&#10;            return CurrentLookAtHitPoint;&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;CurrentLookAtHitPoint is null. Returning Vector3.zero.&quot;);&#10;            return Vector3.zero;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// chiếu tia từ camera để kiểm tra đối tượng người chơi đang nhìn vào.&#10;    /// &lt;/summary&gt;&#10;    public void CheckItemByLooking()&#10;    {&#10;        try&#10;        {&#10;            if (Time.time - lastCheckTime &lt; checkInterval) return;&#10;            lastCheckTime = Time.time;&#10;&#10;            Ray ray = GetCameraRayCenter();&#10;            Debug.DrawRay(ray.origin, ray.direction * 15f, Color.red, 0.1f, true);&#10;&#10;            if (Physics.Raycast(ray, out RaycastHit hit, 50f, lookAtLayerMask))&#10;            {&#10;                CurrentSourcesLookAt = hit.collider.gameObject;&#10;                CurrentLookAtHitPoint = hit.point; // Lưu tọa độ điểm va chạm&#10;                MarkHitPoint(hit.point); // Gọi hàm đánh dấu&#10;                                         //Debug.Log($&quot;Looking at: {CurrentSourcesLookAt.name}&quot;);&#10;            }&#10;        }&#10;        catch (System.Exception)&#10;        {&#10;            Debug.Log(&quot;[PlayerController] lỗi con me no roi, ngu vai lon&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    public void PickUp()&#10;    {&#10;        if (CurrentSourcesLookAt == null) return;&#10;&#10;        if (CurrentSourcesLookAt.layer == LayerMask.NameToLayer(&quot;Item&quot;))&#10;        {&#10;            CurrentSourcesLookAt.transform.SetParent(ListSlot.transform);&#10;            CurrentSourcesLookAt.SetActive(false);&#10;            Debug.Log($&quot;Added {CurrentSourcesLookAt.name} to ListSlot.&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;The object is not an item and cannot be added to ListSlot.&quot;);&#10;        }&#10;    }&#10;&#10;    public float CalculateThrowForce()&#10;    {&#10;        float holdTime = throwTimer.UpdateTimer(false);&#10;        if (holdTime &lt;= 0f) return config.throwForceMin;&#10;        float force = Mathf.Lerp(config.throwForceMin, config.throwForceMax, holdTime / config.maxHoldTime);&#10;        return Mathf.Clamp(force, config.throwForceMin, config.throwForceMax);&#10;    }&#10;&#10;    private bool aim = false;&#10;    /// &lt;summary&gt;&#10;    /// Thay đổi góc nhìn của camera khi nhấn nút Aim.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;Input_M&quot;&gt;&lt;/param&gt;&#10;    public void Aim(bool Input_M)&#10;    {&#10;        if (_playerInput._characterCamera == null)&#10;        {&#10;            Debug.LogWarning(&quot;CharacterCamera is null in Aim!&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lưu trạng thái camera hiện tại nếu chưa lưu&#10;        if (!isCameraSettingsSaved)&#10;        {&#10;            savedDistance = _playerInput._characterCamera.maxDistance;&#10;            savedHeight = _playerInput._characterCamera.height;&#10;            isCameraSettingsSaved = true;&#10;            //Debug.Log($&quot;Aim: Saved camera state - Distance={savedDistance}, Height={savedHeight}&quot;);&#10;        }&#10;&#10;        if (Input_M)&#10;        {&#10;&#10;            _playerInput._characterCamera.transform.SetParent(transform);&#10;            _playerInput._characterCamera.SetTargetValues(config.targetMaxDistance, config.targetHeight, config.rightOffset, config.isAiming);&#10;            _playerInput._characterCamera.useInterpolation = false;&#10;            //Debug.Log(&quot;Aim: Entered aiming mode&quot;);&#10;            aim = true;&#10;        }&#10;        else&#10;        {&#10;            _playerInput._characterCamera.transform.SetParent(null);&#10;            _playerInput._characterCamera.useInterpolation = true;&#10;            _playerInput._characterCamera.SetTargetValues(savedDistance, savedHeight, _playerInput._characterCamera.rightOffset, false);&#10;            //Debug.Log($&quot;Aim: Exited aiming mode, Restored - Distance={savedDistance}, Height={savedHeight}&quot;);&#10;            isCameraSettingsSaved = false;&#10;            aim = false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Thay đổi tài nguyên giữa các slot trong ListBody.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;SLotBody&quot;&gt;&lt;/param&gt;&#10;    public void ChangeResource(int SLotBody)&#10;    {&#10;        if (ListBody[SLotBody].childCount &gt; 0)&#10;        {&#10;            if (ListBody[SLotBody].childCount &gt; 0 &amp;&amp; ListBody[1].childCount &gt; 0)&#10;            {&#10;                Transform childFromSlot3 = ListBody[SLotBody].GetChild(0);&#10;                Transform childFromSlot1 = ListBody[1].GetChild(0);&#10;&#10;                childFromSlot3.SetParent(ListBody[1], false);&#10;                childFromSlot1.SetParent(ListBody[SLotBody], false);&#10;&#10;                Debug.Log(&quot;Successfully swapped first children between ListBody[3] and ListBody[1]&quot;);&#10;            }&#10;            else if (ListBody[SLotBody].childCount &gt; 0)&#10;            {&#10;                Transform childFromSlot3 = ListBody[SLotBody].GetChild(0);&#10;                childFromSlot3.SetParent(ListBody[1], false);&#10;                Debug.Log(&quot;Moved child from ListBody[3] to ListBody[1]&quot;);&#10;            }&#10;            else if (ListBody[1].childCount &gt; 0)&#10;            {&#10;                Transform childFromSlot1 = ListBody[1].GetChild(0);&#10;                childFromSlot1.SetParent(ListBody[SLotBody], false);&#10;                Debug.Log(&quot;Moved child from ListBody[1] to ListBody[3]&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No children to swap in ListBody[3] or ListBody[1]!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// lấy GameObject từ list Slot và thay đổi chỉ mục của nó vào ListBody[2] &#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;Index&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    /// &lt;summary&gt;&#10;    /// lấy GameObject từ list Slot và thay đổi chỉ mục của nó vào ListBody[2] &#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;Index&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public GameObject ChangeSlotIndex(int index)&#10;    {&#10;        if (ListSlot == null || ListSlot.transform.childCount == 0)&#10;        {&#10;            Debug.LogWarning(&quot;[PlayerController] ListSlot is null or empty.&quot;);&#10;            return null;&#10;        }&#10;&#10;        if (index &lt; 0 || index &gt;= ListSlot.transform.childCount)&#10;        {&#10;            Debug.LogWarning($&quot;[PlayerController] Index {index} is out of bounds.&quot;);&#10;            return null;&#10;        }&#10;&#10;        // Trả item cũ về slot nếu có&#10;        if (previousIndex &gt;= 0 &amp;&amp; RightHandObject != null)&#10;        {&#10;            RightHandObject.transform.SetParent(ListSlot.transform, false);&#10;            //RightHandObject.SetActive(false);&#10;        }&#10;&#10;        // Lấy item mới từ index&#10;        Transform itemTransform = ListSlot.transform.GetChild(index);&#10;        GameObject newItem = itemTransform.gameObject;&#10;&#10;        newItem.transform.SetParent(ListBody[1].transform, false);&#10;        newItem.transform.localPosition = new Vector3(1f, 2f, 0f);&#10;        newItem.transform.localRotation = Quaternion.identity;&#10;        newItem.SetActive(true);&#10;&#10;        RightHandObject = newItem;&#10;        previousIndex = index;&#10;&#10;        if (deactivateCoroutine != null)&#10;            StopCoroutine(deactivateCoroutine);&#10;        deactivateCoroutine = StartCoroutine(DeactivateAfterDelay(newItem, 0.6f));&#10;&#10;        Debug.Log($&quot;[PlayerController] Equipped item '{newItem.name}' from ListSlot[{index}]&quot;);&#10;        return newItem;&#10;    }&#10;&#10;    private IEnumerator DeactivateAfterDelay(GameObject obj, float delay)&#10;    {&#10;        yield return new WaitForSeconds(delay);&#10;        if (obj != null)&#10;        {&#10;            obj.SetActive(false);&#10;        }&#10;    }&#10;&#10;    #endregion&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Duckle;&#10;using System;&#10;using UnityEngine;&#10;using UnityEngine.AI;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;&#10;public class PlayerController_02 : PlayerEventListenerBase&#10;{&#10;    #region biến cần thiết&#10;&#10;    [Header(&quot;Debug&quot;)]&#10;    private string mess = null;&#10;    [SerializeField] private float checkInterval = 0.1f;&#10;    private float lastCheckTime;&#10;    private Vector3 groundCheckPosition; // Vị trí kiểm tra mặt đất&#10;&#10;    [Header(&quot;Core base&quot;)]&#10;    private Core_02 _core_02;&#10;    private Animator _animator;&#10;    public PlayerConfig config;&#10;&#10;    [Header(&quot;Reference&quot;)]&#10;    public Rigidbody _rigidbody { get; private set; }&#10;    public NavMeshAgent _navMeshAgent { get; private set; }&#10;&#10;    public PlayerInput_02 _playerInput;&#10;    public Timer throwTimer = new Timer();&#10;&#10;    public CharacterStateType CurrentPlayerState;           // Trạng thái hiện tại của người chơi&#10;    public IUsable CurrentUsable { get; set; }&#10;&#10;    [Header(&quot;Body&quot;)]&#10;    public GameObject FacePlayer;                           // mặt người chơi (tạm thời)&#10;    [SerializeField] private List&lt;Transform&gt; ListBody;      //   Danh sách các slot vũ khí&#10;    public GameObject ListSlot;                             // Danh sách Slot (tạm thời)&#10;&#10;&#10;    [Header(&quot;Slot Settings&quot;)]&#10;    [SerializeField] private LayerMask invironmentLayer;    // Lớp để kiểm tra môi trường&#10;    [SerializeField] private LayerMask lookAtLayerMask;     // Lớp để kiểm tra đối tượng khi nhìn vào&#10;    public GameObject CurrentSourcesLookAt { get; set; }    // Đối tượng mà người chơi đang nhìn vào&#10;    [SerializeField] public GameObject RightHandObject;     // đối tượng đang được sử dụng (đang nằm trong tay phải)&#10;&#10;&#10;    [Header(&quot;Currrent character setting&quot;)]&#10;    private Vector3 lastRotationDirection = Vector3.forward;&#10;    [SerializeField] private bool useNavMesh = false;&#10;    [SerializeField] private bool isGrounded = true;&#10;&#10;    [Header(&quot;Nav character Settings&quot;)]&#10;    [SerializeField] private float N_speed = 1.3f;&#10;    private float originalSpeed; // Lưu tốc độ gốc&#10;    private bool isSpeedReduced = false; // Kiểm tra xem tốc độ có đang bị giảm không&#10;    [SerializeField] private float airDrag = 1f;&#10;    [SerializeField] private float extraGravity = 30f;&#10;&#10;    [SerializeField] private float JumpMomentumBoost = 2f;&#10;    [SerializeField] private float dashForce = 15f;         // lực dash&#10;    [SerializeField] private float dashDuration = 0.3f;     // thời gian dash&#10;    [SerializeField] private float dashMomentumBoost = 1.3f;// nhân vận tốc ngang&#10;&#10;    [Header(&quot;Character action Settings&quot;)]&#10;    public int previousIndex = -1;                          // Lưu chỉ mục trước đó của item được trang bị&#10;    public Coroutine deactivateCoroutine;                   // Coroutine để hủy kích hoạt item sau khi ném&#10;    [SerializeField] private GameObject markerPrefab;       // Prefab dùng để đánh dấu (test)&#10;    [SerializeField] private Material laserMaterial;        // Material cho laser line (test)&#10;    [SerializeField] private float laserWidth = 0.02f;      // Độ rộng của laser line (test)&#10;    private GameObject currentMarker;&#10;    private LineRenderer laserLine;&#10;    private float savedDistance = 0f;&#10;    private float savedHeight = 0f;&#10;    private bool isCameraSettingsSaved = false;&#10;&#10;    private float currentDirectionX = 0f;&#10;    private float currentDirectionZ = 0f;&#10;    [SerializeField] private float smoothSpeed = 10f; // Tốc độ làm mượt (có thể chỉnh trong Inspector)&#10;    public Vector3 CurrentLookAtHitPoint { get; private set; } // tọa độ điểm va chạm của tia nhìn&#10;&#10;    [Header(&quot;Attack Settings&quot;)]&#10;    public bool ActiveAttack = false;&#10;    public bool isAttacking;&#10;    public bool wait = false;&#10;    public float waitTimeAt = 2f; // Thời gian chờ 2 giây&#10;    private float timer = 0f;&#10;    private float lastAttackTime;&#10;&#10;    [SerializeField] private float[] attackDurations;&#10;    [SerializeField] private float groundCheckRadius = 1f; // Radius of the sphere for ground check&#10;    [SerializeField] private float groundCheckDistance = 0.4f; // Distance to check below the player&#10;&#10;    #endregion&#10;&#10;    protected override void Awake()&#10;    {&#10;        if (_core_02 == null) _core_02 = Core_02.Instance;&#10;        if (_rigidbody == null) _rigidbody = GetComponent&lt;Rigidbody&gt;();&#10;        if (_navMeshAgent == null) _navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();&#10;&#10;        base.Awake();&#10;        if (_core_02 == null)&#10;        {&#10;            Debug.LogError(&quot;Core_02 instance is null in PlayerController_02.&quot;);&#10;            _core_02 = Core_02.Instance;&#10;        }&#10;        _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;&#10;        // Cấu hình NavMeshAgent&#10;        if (_navMeshAgent != null)&#10;        {&#10;            _navMeshAgent.updatePosition = useNavMesh; // Chỉ cập nhật vị trí nếu dùng NavMesh&#10;            _navMeshAgent.updateRotation = false; // Tắt xoay tự động để tự xử lý&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        if (_playerInput == null) _playerInput = GetComponent&lt;PlayerInput_02&gt;();&#10;        if (_animator == null) _animator = GetComponent&lt;Animator&gt;();&#10;        if (_navMeshAgent == null)&#10;        {&#10;            _navMeshAgent = gameObject.AddComponent&lt;NavMeshAgent&gt;();&#10;            _navMeshAgent.updatePosition = useNavMesh;&#10;            _navMeshAgent.updateRotation = false;&#10;        }&#10;&#10;        _animator.SetInteger(&quot;State&quot;, 0); // Idle&#10;        _animator.SetFloat(&quot;DirectionX&quot;, 0f);&#10;        _animator.SetFloat(&quot;DirectionZ&quot;, 0f);&#10;    }&#10;&#10;    public void Update()&#10;    {&#10;        if (Input.GetKeyDown(KeyCode.N))&#10;        {&#10;            useNavMesh = !useNavMesh;&#10;            if (useNavMesh)&#10;            {&#10;                _navMeshAgent.Warp(transform.position); // Đồng bộ vị trí NavMeshAgent với Rigidbody&#10;                _navMeshAgent.updatePosition = true;&#10;            }&#10;            else&#10;            {&#10;                _navMeshAgent.updatePosition = false;&#10;            }&#10;            Debug.Log($&quot;Switched to {(useNavMesh ? &quot;NavMesh&quot; : &quot;Rigidbody&quot;)} movement.&quot;);&#10;        }&#10;&#10;        UsingResource();&#10;        CheckItemByLooking();&#10;&#10;        if (!aim)&#10;        {&#10;            // đợi 1 giây và setbool throw = false&#10;            if (_animator != null &amp;&amp; _animator.GetBool(&quot;Throw&quot;) == true)&#10;            {&#10;                _animator.SetBool(&quot;Throw&quot;, false);&#10;            }&#10;        }&#10;        WaitCheck();&#10;    }&#10;&#10;    private void LateUpdate()&#10;    {&#10;        if (_navMeshAgent != null &amp;&amp; isGrounded)&#10;        {&#10;            EnableNavMeshAgent();&#10;        }&#10;&#10;    }&#10;&#10;    private void FixedUpdate()&#10;    {&#10;        // AirControl: giảm quán tính ngang khi ở trên không&#10;        if (!isGrounded &amp;&amp; CurrentPlayerState == CharacterStateType.Jump)&#10;        {&#10;            Vector3 vel = _rigidbody.linearVelocity;&#10;            vel.x *= airDrag;&#10;            vel.z *= airDrag;&#10;            _rigidbody.linearVelocity = vel;&#10;&#10;            // tăng gravity&#10;            _rigidbody.AddForce(Vector3.down * extraGravity, ForceMode.Acceleration);&#10;        }&#10;    }&#10;&#10;    #region base Event/state&#10;&#10;    public override void RegisterEvent(PlayerEvent e)&#10;    {&#10;        e.OnChangePlayerState += UpdateCurrentPlayerState;&#10;    }&#10;&#10;    public override void UnregisterEvent(PlayerEvent e)&#10;    {&#10;        e.OnChangePlayerState -= UpdateCurrentPlayerState;&#10;    }&#10;&#10;    private void UpdateCurrentPlayerState(CharacterStateType stateType)&#10;    {&#10;        CurrentPlayerState = stateType;&#10;    }&#10;    #endregion&#10;&#10;    #region get input&#10;&#10;    public void PerformMoveInput(CharacterActionType actionType, Vector3 direction)&#10;    {&#10;        if (_core_02 == null)&#10;        {&#10;            Debug.LogError(&quot;Core_02 is null in PerformMoveInput.&quot;);&#10;            return;&#10;        }&#10;        if (_core_02._stateMachine == null)&#10;        {&#10;            Debug.LogError(&quot;StateMachine is null in PerformMoveInput.&quot;);&#10;            return;&#10;        }&#10;        if (config == null)&#10;        {&#10;            Debug.LogError(&quot;PlayerConfig is not assigned in PlayerController_02!&quot;);&#10;            return;&#10;        }&#10;&#10;        // Chuyển state&#10;        _core_02._stateMachine.HandleAction(actionType);&#10;&#10;        if (_animator != null)&#10;        {&#10;            SetAnimationParameters(actionType, direction);&#10;        }&#10;&#10;        float moveSpeed = config.walkSpeed; // mặc định là walk&#10;        // Chọn tốc độ dựa trên type action&#10;        switch (actionType)&#10;        {&#10;            case CharacterActionType.Run:&#10;                moveSpeed = config.runSpeed;&#10;                break;&#10;            case CharacterActionType.Sprint:&#10;                moveSpeed = config.sprintSpeed;&#10;                break;&#10;            case CharacterActionType.Jump:&#10;                Jump(config.jumpImpulse);&#10;                return;&#10;            case CharacterActionType.Dash:&#10;                Dash();&#10;                return;&#10;        }&#10;&#10;        if (!isGrounded &amp;&amp; CurrentPlayerState != CharacterStateType.Jump &amp;&amp; CurrentPlayerState != CharacterStateType.Dash)&#10;            HelpCheckGround();&#10;        if (isGrounded &amp;&amp; !isAttacking)&#10;        {&#10;            // Chọn phương thức di chuyển&#10;            if (useNavMesh &amp;&amp; _navMeshAgent != null)&#10;            {&#10;                MoveNavMesh(direction, moveSpeed, actionType);&#10;            }&#10;            else&#10;            {&#10;                Move(direction * moveSpeed, actionType);&#10;            }&#10;        }&#10;    }&#10;&#10;    public void PerformAttackInput(CharacterActionType actionType, Vector3 direction)&#10;    {&#10;        _core_02._stateMachine.HandleAction(actionType);&#10;        //Debug.LogWarning($&quot;PerformAttackInput: {actionType} with direction {direction}&quot;);&#10;&#10;        switch (actionType)&#10;        {&#10;            case CharacterActionType.Attack:&#10;                if (ActiveAttack)&#10;                {&#10;                    //Attack(direction, config.attackRange, config.attackDuration, config.attackDamage, config.attackCooldown);&#10;                    int attackIndex = GetAttackIndexFromDirection(direction);&#10;                    if (!isAttacking)&#10;                    {&#10;                        TryAttack(attackIndex);&#10;                    }&#10;                }&#10;                break;&#10;            case CharacterActionType.ThrowItem:&#10;                Thrown(2f); // tạm thời&#10;                break;&#10;            case CharacterActionType.ThrowWeapon:&#10;                Thrown(config.throwForce);&#10;                break;&#10;        }&#10;    }&#10;&#10;    public void PerformInteractInput(CharacterActionType actionType, GameObject currentSources)&#10;    {&#10;        _core_02._stateMachine.HandleAction(actionType);&#10;&#10;        switch (actionType)&#10;        {&#10;            case CharacterActionType.PickUp:&#10;                PickUp();&#10;                break;&#10;            case CharacterActionType.Drop:&#10;&#10;                break;&#10;            case CharacterActionType.Active:&#10;&#10;                break;&#10;        }&#10;    }&#10;&#10;    #endregion&#10;&#10;    #region Action Resource&#10;    public void EquipUsable(IUsable usable)&#10;    {&#10;        if (usable == null)&#10;        {&#10;            Debug.LogError(&quot;Attempted to equip null usable&quot;);&#10;            return;&#10;        }&#10;        CurrentUsable = usable;&#10;        Debug.Log($&quot;Equipped usable: {CurrentUsable.Name}&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Sử dụng tài nguyên từ ListBody[1] (tay phải).&#10;    /// &lt;/summary&gt;&#10;    public void UsingResource()&#10;    {&#10;        if (ListBody == null)&#10;        {&#10;            Debug.LogError(&quot;ListBody is null! Please initialize it in the Inspector or code.&quot;);&#10;            return;&#10;        }&#10;&#10;        // kiểm tra ListBody[1] có tồn tại và có con không&#10;        if (ListBody.Count &gt; 2 &amp;&amp; ListBody[1] != null &amp;&amp; ListBody[1].childCount &gt; 0)&#10;        {&#10;            Transform childTransform = ListBody[1].transform.GetChild(0);&#10;            if (childTransform != null)&#10;            {&#10;                GameObject childObject = childTransform.gameObject;&#10;                RightHandObject = childObject;&#10;                Component component = null;&#10;&#10;                Component[] components = RightHandObject.GetComponents&lt;Component&gt;();&#10;                foreach (var c in components)&#10;                {&#10;                    if (c.GetType().Name == &quot;Weapon&quot;)&#10;                    {&#10;                        component = c;&#10;                        break;&#10;                    }&#10;                    else if (c.GetType().Name == &quot;Loot&quot;)&#10;                    {&#10;                        component = c;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (component is IUsable usable)&#10;                {&#10;                    CurrentUsable = usable;&#10;                    EquipUsable(CurrentUsable);&#10;                    Debug.Log($&quot;Equipped usable: {CurrentUsable.Name}, Classify: {CurrentUsable.Classify}, Effect Value: {CurrentUsable.GetEffectValue()}&quot;);&#10;                }&#10;                else&#10;                {&#10;                    Debug.LogWarning($&quot;Weapons component not found on {RightHandObject.name}!&quot;);&#10;                }&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No GameObject found in the children of ListBody[1]!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            //Debug.LogWarning(&quot;ListBody[1] is null or has no children!&quot;);&#10;        }&#10;    }&#10;    #endregion&#10;&#10;    #region Move&#10;&#10;    /// &lt;summary&gt;&#10;    /// Move bằng Rigidbody.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;direction&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;moveType&quot;&gt;&lt;/param&gt;&#10;    private void Move(Vector3 direction, CharacterActionType moveType)&#10;    {&#10;        float acceleration = config.acceleration;&#10;        float rotationSpeed = config.rotationSpeed;&#10;&#10;        if (this._rigidbody == null)&#10;        {&#10;            Debug.LogError(&quot;Rigidbody is null in MoveAction.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (direction.sqrMagnitude &lt;= 0.001f &amp;&amp; moveType != CharacterActionType.Jump)&#10;        {&#10;            _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;            return;&#10;        }&#10;&#10;        _rigidbody.interpolation = RigidbodyInterpolation.Interpolate;&#10;        float deltaTime = Time.fixedDeltaTime;&#10;        Vector3 currentVelocity = this._rigidbody.linearVelocity;&#10;&#10;        Vector3 targetVelocity = direction;&#10;        Vector3 horizontalVelocity = new Vector3(currentVelocity.x, 0f, currentVelocity.z);&#10;        Vector3 velocityChange = targetVelocity - horizontalVelocity;&#10;&#10;        velocityChange = Vector3.ClampMagnitude(velocityChange, acceleration * deltaTime);&#10;        this._rigidbody.linearVelocity += new Vector3(velocityChange.x, 0f, velocityChange.z);&#10;&#10;        Quaternion currentRotation = this._rigidbody.rotation;&#10;&#10;        if (_playerInput == null)&#10;        {&#10;            Debug.LogError(&quot;_playerInput is null in MoveAction.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (_playerInput._characterCamera == null)&#10;        {&#10;            Debug.LogWarning(&quot;_characterCamera is null in MoveAction. Using default rotation.&quot;);&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;&#10;            if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;                this._rigidbody.MoveRotation(Quaternion.Lerp(currentRotation, targetRotation, rotationSpeed * deltaTime));&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (!_playerInput._characterCamera.isAiming)&#10;        {&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;&#10;            if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;                this._rigidbody.MoveRotation(Quaternion.Lerp(currentRotation, targetRotation, rotationSpeed * deltaTime));&#10;            }&#10;        }&#10;&#10;        else if (_playerInput._characterCamera.mainCamera != null)&#10;        {&#10;            Vector3 camForward = _playerInput._characterCamera.mainCamera.transform.forward;&#10;            camForward.y = 0;&#10;&#10;            if (camForward./*direction.*/sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = camForward.normalized /*direction*/;&#10;            }&#10;&#10;            if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;                this._rigidbody.MoveRotation(Quaternion.Lerp(currentRotation, targetRotation, rotationSpeed * deltaTime));&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Move bằng NavMeshAgent.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;direction&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;moveSpeed&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;moveType&quot;&gt;&lt;/param&gt;&#10;    private void MoveNavMesh(Vector3 direction, float moveSpeed, CharacterActionType moveType)&#10;    {&#10;        float speed_n = N_speed;&#10;        float deltaTime = Time.fixedDeltaTime;&#10;&#10;        if (_navMeshAgent == null)&#10;        {&#10;            Debug.LogError(&quot;NavMeshAgent is null in MoveNavMesh.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (direction.sqrMagnitude &lt;= 0.001f &amp;&amp; moveType != CharacterActionType.Jump)&#10;        {&#10;            _navMeshAgent.isStopped = true;&#10;            _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;            return;&#10;        }&#10;        _rigidbody.interpolation = RigidbodyInterpolation.None;&#10;&#10;        // Cập nhật tốc độ của NavMeshAgent&#10;        _navMeshAgent.speed = moveSpeed * speed_n;&#10;        _navMeshAgent.angularSpeed = config.rotationSpeed * config.rotationSpeed;&#10;        _navMeshAgent.acceleration = config.acceleration * speed_n;&#10;&#10;        // Tính toán điểm đích dựa trên hướng di chuyển&#10;        Vector3 targetPosition = transform.position + direction * moveSpeed /* * deltaTime*/;&#10;&#10;        // Đặt điểm đích cho NavMeshAgent&#10;        _navMeshAgent.isStopped = false;&#10;        _navMeshAgent.SetDestination(targetPosition);&#10;&#10;        // Xử lý xoay nhân vật&#10;        if (_playerInput == null)&#10;        {&#10;            Debug.LogError(&quot;_playerInput is null in MoveNavMesh.&quot;);&#10;            return;&#10;        }&#10;&#10;        if (_playerInput._characterCamera == null)&#10;        {&#10;            Debug.LogWarning(&quot;_characterCamera is null in MoveNavMesh. Using default rotation.&quot;);&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;        }&#10;        else if (!_playerInput._characterCamera.isAiming)&#10;        {&#10;            if (direction.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = direction;&#10;            }&#10;        }&#10;        else if (_playerInput._characterCamera.mainCamera != null)&#10;        {&#10;            Vector3 camForward = _playerInput._characterCamera.mainCamera.transform.forward;&#10;            camForward.y = 0;&#10;            if (camForward.sqrMagnitude &gt; 0.001f)&#10;            {&#10;                lastRotationDirection = camForward.normalized;&#10;            }&#10;        }&#10;&#10;        // Xoay nhân vật&#10;        if (lastRotationDirection.sqrMagnitude &gt; 0.001f)&#10;        {&#10;            Quaternion targetRotation = Quaternion.LookRotation(lastRotationDirection);&#10;            transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, config.rotationSpeed * deltaTime);&#10;        }&#10;    }&#10;&#10;    private bool Jump(float jumpForce)&#10;    {&#10;        if (!isGrounded)&#10;        {&#10;            //Debug.Log(&quot;Cannot jump: Player is not grounded.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (_animator != null)&#10;        {&#10;            SetAnimationParameters(CharacterActionType.Jump, Vector3.zero);&#10;        }&#10;&#10;        if (useNavMesh &amp;&amp; _navMeshAgent != null)&#10;        {&#10;            _navMeshAgent.enabled = false;&#10;            _rigidbody.isKinematic = false;&#10;            _rigidbody.interpolation = RigidbodyInterpolation.Interpolate;&#10;        }&#10;&#10;        Vector3 horizontalVel = new Vector3(_rigidbody.linearVelocity.x, 0, _rigidbody.linearVelocity.z);&#10;&#10;        if (horizontalVel.sqrMagnitude &lt; 0.01f &amp;&amp; _playerInput != null)&#10;            horizontalVel = _playerInput.GetMoveInput().normalized * config.runSpeed;&#10;&#10;        float momentumBoost = JumpMomentumBoost; // boost&#10;        Vector3 jumpVelocity = (horizontalVel * momentumBoost) + Vector3.up * jumpForce;&#10;&#10;        _rigidbody.linearVelocity = jumpVelocity;&#10;&#10;        isGrounded = false;&#10;        _core_02._stateMachine.SetState(new JumpState(_core_02._stateMachine, _playerEvent));&#10;        return true;&#10;    }&#10;&#10;    private bool Dash()&#10;    {&#10;        try&#10;        {&#10;            if (isGrounded)&#10;            {&#10;                Debug.Log(&quot;Cannot dash: Player is grounded.&quot;);&#10;                return false;&#10;            }&#10;&#10;            if (_animator != null) _animator.SetTrigger(&quot;Dash&quot;);&#10;            if (useNavMesh &amp;&amp; _navMeshAgent != null)&#10;            {&#10;                _navMeshAgent.enabled = false;&#10;                _rigidbody.isKinematic = false;&#10;            }&#10;&#10;            // Giữ vận tốc ngang hiện tại và tăng cường&#10;            Vector3 horizontalVel = new Vector3(_rigidbody.linearVelocity.x, 0, _rigidbody.linearVelocity.z);&#10;            if (horizontalVel.sqrMagnitude &lt; 0.01f &amp;&amp; _playerInput != null)&#10;            {&#10;                Vector3 inputDir = _playerInput.GetMoveInput();&#10;                if (inputDir.sqrMagnitude &gt; 0.01f)&#10;                    horizontalVel = inputDir.normalized * config.runSpeed;&#10;            }&#10;&#10;            // Tạo vận tốc dash&#10;            Vector3 dashVelocity = horizontalVel.normalized * (horizontalVel.magnitude * dashMomentumBoost + dashForce);&#10;            dashVelocity.y = _rigidbody.linearVelocity.y; // giữ Y (đang rơi)&#10;&#10;            // Gán velocity ngay lập tức&#10;            _rigidbody.linearVelocity = dashVelocity;&#10;&#10;            //Debug.Log($&quot;Dashing with velocity: {dashVelocity}&quot;);&#10;&#10;            // Chuyển state Dash&#10;            _core_02._stateMachine.SetState(new DashState(_core_02._stateMachine, _playerEvent));&#10;&#10;            // Dừng dash sau dashDuration&#10;            StartCoroutine(EndDashAfterTime(dashDuration));&#10;&#10;            return true;&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            mess = e.Message;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private IEnumerator EndDashAfterTime(float time)&#10;    {&#10;        yield return new WaitForSeconds(time);&#10;&#10;        // Sau khi dash, trở về JumpState (vì vẫn đang trên không)&#10;        if (!isGrounded)&#10;        {&#10;            _core_02._stateMachine.SetState(new JumpState(_core_02._stateMachine, _playerEvent));&#10;        }&#10;    }&#10;&#10;    private void EnableNavMeshAgent()&#10;    {&#10;        if (_navMeshAgent != null)&#10;        {&#10;            _navMeshAgent.enabled = true;&#10;&#10;        }&#10;    }&#10;&#10;    #endregion&#10;&#10;    #region Attack&#10;    private IEnumerator ThrownCoroutine(float force, float delay)&#10;    {&#10;&#10;        _animator.SetBool(&quot;Throw&quot;, true);&#10;&#10;        // Đợi một khoảng thời gian để animation chạy&#10;        yield return new WaitForSeconds(delay);&#10;&#10;        GameObject thrownObject = RightHandObject?.gameObject;&#10;        if (thrownObject != null)&#10;        {&#10;            thrownObject.SetActive(true);&#10;            RightHandObject.gameObject.transform.SetParent(null);&#10;            RightHandObject = null;&#10;        }&#10;        if (thrownObject == null)&#10;        {&#10;            // Tạo một đối tượng ném mặc định nếu không có item nào được trang bị&#10;            GameObject DefaulObjThrow = Resources.Load&lt;GameObject&gt;(config.prefabPath);&#10;            if (DefaulObjThrow == null)&#10;            {&#10;                Debug.LogError($&quot;Prefab not found at path: {config.prefabPath}&quot;);&#10;                yield break;&#10;            }&#10;            thrownObject = Instantiate(DefaulObjThrow);&#10;        }&#10;&#10;        _core_02._stateMachine.SetState(new ThrowWeaponState(_core_02._stateMachine, _playerEvent));&#10;&#10;        if (_animator != null)&#10;        {&#10;            SetAnimationParameters(CharacterActionType.ThrowItem, Vector3.zero);&#10;        }&#10;&#10;        Ray camRay = GetCameraRayCenter();&#10;        Vector3 forward = camRay.direction.normalized;&#10;&#10;        Vector3 spawnPosition = FacePlayer.transform.position + forward * 1.5f;&#10;        thrownObject.transform.position = spawnPosition;&#10;&#10;        if (thrownObject.TryGetComponent&lt;Rigidbody&gt;(out var rb))&#10;        {&#10;            rb.linearVelocity = forward * force;&#10;        }&#10;        if (thrownObject.TryGetComponent&lt;ThrowableObject&gt;(out var throwable))&#10;        {&#10;            throwable.SetThrower_02(this);&#10;            if (CurrentUsable != null) throwable.SetUsableData(CurrentUsable.Name, CurrentUsable.GetEffectValue());&#10;        }&#10;&#10;        CurrentUsable?.OnUse_2(this);&#10;&#10;    }&#10;&#10;    private void Thrown(float force)&#10;    {&#10;        StartCoroutine(ThrownCoroutine(force, 0.2f)); // Độ trễ 0.5 giây, bạn có thể điều chỉnh&#10;    }&#10;&#10;    private int GetAttackIndexFromDirection(Vector3 direction)&#10;    {&#10;        // Chuẩn hóa direction để dễ so sánh&#10;        direction = direction.normalized;&#10;&#10;        // Tính góc giữa direction và các hướng chuẩn&#10;        float dotRight = Vector3.Dot(direction, Vector3.right);&#10;        float dotLeft = Vector3.Dot(direction, Vector3.left);&#10;        float dotForward = Vector3.Dot(direction, Vector3.forward);&#10;        float dotBack = Vector3.Dot(direction, Vector3.back);&#10;&#10;        // Tìm hướng có giá trị dot lớn nhất (gần nhất với direction)&#10;        float maxDot = Mathf.Max(dotRight, dotLeft, dotForward, dotBack);&#10;&#10;        if (maxDot &lt; 0.5f) // Ngưỡng để đảm bảo hướng rõ ràng&#10;        {&#10;            return 3; // Không xác định được hướng&#10;        }&#10;&#10;        if (maxDot == dotRight)&#10;            return 1; // Right&#10;        if (maxDot == dotLeft)&#10;            return 2; // Left&#10;        if (maxDot == dotForward)&#10;            return 3; // Forward&#10;        if (maxDot == dotBack)&#10;            return 4; // Back&#10;&#10;        return 0; // Trường hợp không xác định&#10;    }&#10;&#10;    private bool TryAttack(int attackIndex)&#10;    {&#10;        // Kiểm tra chỉ số hợp lệ&#10;        if (attackIndex &lt; 1 || attackIndex &gt; attackDurations.Length)&#10;        {&#10;            Debug.LogError($&quot;Invalid attack index: {attackIndex}&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Lấy thời lượng animation tương ứng&#10;        float attackDuration = attackDurations[attackIndex - 1];&#10;        float attackCooldown = attackDuration + 0.5f; // Cooldown bằng thời gian animation + buffer&#10;&#10;        // Kiểm tra cooldown&#10;        if (Time.time - lastAttackTime &lt; attackCooldown)&#10;        {&#10;            Debug.Log(&quot;Attack on cooldown.&quot;);&#10;            return false;&#10;        }&#10;&#10;        return Attack(Vector3.forward, config.attackRange, attackDuration, config.attackDamage, attackCooldown, attackIndex);&#10;    }&#10;&#10;    private bool Attack(Vector3 attackDir, float attackRange, float attackDuration, float attackDamage, float attackCooldown, int attackIndex)&#10;    {&#10;        try&#10;        {&#10;            if (_animator == null)&#10;            {&#10;                Debug.LogWarning(&quot;Animator is null in Attack. No animation will be played.&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Thiết lập parameter để chạy animation&#10;            isAttacking = true;&#10;            lastAttackTime = Time.time;&#10;            _animator.SetInteger(&quot;AnimationIndex&quot;, attackIndex);&#10;&#10;&#10;            //Debug.Log($&quot;Performing attack {attackIndex} with range={attackRange}, duration={attackDuration}, damage={attackDamage}, cooldown={attackCooldown}&quot;);&#10;&#10;            _core_02._stateMachine.SetState(new AttackState(_core_02._stateMachine, _playerEvent));&#10;&#10;            //Kiểm tra va chạm với đối tượng trong phạm vi tấn công&#10;            Collider[] hits = Physics.OverlapSphere(transform.position + transform.forward * attackRange * 0.5f, attackRange);&#10;            foreach (Collider hit in hits)&#10;            {&#10;                if (hit.CompareTag(&quot;Boss&quot;))&#10;                {&#10;                    PlayerEvent.Instance.TriggerTakeOutDamage(this.gameObject, attackDamage, hit.gameObject);&#10;                    Debug.Log($&quot;Hit {hit.gameObject.name} with attack {attackIndex}, damage: {attackDamage} at range: {attackRange}.&quot;);&#10;                }&#10;            }&#10;&#10;            // Đặt lại trạng thái sau khi animation hoàn thành&#10;            Invoke(nameof(ResetAttackState), attackDuration);&#10;&#10;            //ApplyForceAttack(attackIndex, _rigidbody);&#10;            StartCoroutine(WaitApplyForceAttack(attackIndex, _rigidbody));&#10;&#10;            Debug.Log($&quot;Attack {attackIndex} performed: range={attackRange}, duration={attackDuration}, damage={attackDamage}, cooldown={attackCooldown}&quot;);&#10;            return true;&#10;        }&#10;        catch (Exception e)&#10;        {&#10;            Debug.LogError($&quot;Attack failed: {e.Message}&quot;);&#10;            isAttacking = false; // Đặt lại trạng thái nếu lỗi&#10;            return false;&#10;        }&#10;    }&#10;&#10;    private void ResetAttackState()&#10;    {&#10;        isAttacking = false; // Cho phép attack tiếp theo sau khi animation hoàn thành&#10;        _animator.SetInteger(&quot;AnimationIndex&quot;, 0); // Đặt lại parameter về trạng thái mặc định (nếu cần)&#10;    }&#10;&#10;    private IEnumerator WaitApplyForceAttack(int attackIndex, Rigidbody rb)&#10;    {&#10;        // Đợi một khoảng thời gian trước khi áp dụng lực&#10;        yield return new WaitForSeconds(0.7f);&#10;        ApplyForceAttack(attackIndex, rb);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// tạo lực cho Rigidbody dựa trên attackIndex.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;attackIndex&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;rb&quot;&gt;&lt;/param&gt;&#10;    public void ApplyForceAttack(int attackIndex, Rigidbody rb)&#10;    {&#10;        // Lấy hướng phía trước của nhân vật&#10;        Vector3 forwardDirection = transform.forward;&#10;&#10;        switch (attackIndex)&#10;        {&#10;            case 1:&#10;                // Lực hướng về phía trước, cường độ 5f&#10;                //rb.AddForce(forwardDirection * 15f, ForceMode.Impulse);&#10;                ApplyRadialForce(rb, 15f, false);&#10;                Debug.LogWarning(&quot;Applied force for attack 1: Forward direction with intensity 5f.&quot;);&#10;                break;&#10;&#10;            case 2:&#10;                // Lực hướng về phía trước, cường độ 4f&#10;                //rb.AddForce(forwardDirection * 20f, ForceMode.Impulse);&#10;                ApplyRadialForce(rb, 20f, true);&#10;                Debug.LogWarning(&quot;Applied force for attack 2: Forward direction with intensity 4f.&quot;);&#10;                break;&#10;&#10;            case 3:&#10;                // Lực hướng ra tất cả các hướng xung quanh (trừ hướng xuống)&#10;                ApplyRadialForce(rb, 30f, false);&#10;                Debug.LogWarning(&quot;Applied radial force for attack 3: All directions except down with intensity 6f.&quot;);&#10;                break;&#10;&#10;            case 4:&#10;                // Lực hướng ra tất cả các hướng xung quanh (trừ hướng lên)&#10;                ApplyRadialForce(rb, 40f, true);&#10;                Debug.LogWarning(&quot;Applied radial force for attack 4: All directions except up with intensity 10f.&quot;);&#10;                break;&#10;&#10;            default:&#10;                Debug.LogWarning(&quot;Invalid attackIndex: &quot; + attackIndex);&#10;                break;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// hàm phụ để tạo lực hướng ra xung quanh từ vị trí của nhân vật.&#10;    /// nhận vào 3 tham số: Rigidbody, cường độ lực và Bool ForceUp.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;rb&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;forceMagnitude&quot;&gt;&lt;/param&gt;&#10;    /// &lt;param name=&quot;excludeUp&quot;&gt;&lt;/param&gt;&#10;    private void ApplyRadialForce(Rigidbody rb, float forceMagnitude, bool excludeUp)&#10;    {&#10;        // Lấy tất cả các Rigidbody trong bán kính 10f&#10;        Collider[] colliders = Physics.OverlapSphere(transform.position, 10f);&#10;&#10;        foreach (Collider col in colliders)&#10;        {&#10;            Rigidbody targetRb = col.GetComponent&lt;Rigidbody&gt;();&#10;            if (targetRb != null &amp;&amp; targetRb != rb) // Không áp dụng lực cho chính nhân vật&#10;            {&#10;                // Tính hướng từ nhân vật đến đối tượng&#10;                Vector3 direction = (col.transform.position - transform.position).normalized;&#10;&#10;                // Nếu excludeUp = true, loại bỏ thành phần hướng lên (y dương)&#10;                if (excludeUp &amp;&amp; direction.y &gt; 0)&#10;                {&#10;                    direction.y = 0;&#10;                    direction = direction.normalized;&#10;                }&#10;                // Nếu excludeUp = false, loại bỏ thành phần hướng xuống (y âm)&#10;                else if (!excludeUp &amp;&amp; direction.y &lt; 0)&#10;                {&#10;                    direction.y = 0;&#10;                    direction = direction.normalized;&#10;                }&#10;&#10;                // Áp dụng lực&#10;                targetRb.AddForce(direction * forceMagnitude, ForceMode.Impulse);&#10;            }&#10;        }&#10;    }&#10;&#10;    #endregion&#10;&#10;    #region Animation Parameters&#10;    private void SetAnimationParameters(CharacterActionType actionType, Vector3 dir)&#10;    {&#10;        if (_animator == null)&#10;        {&#10;            Debug.LogWarning(&quot;Animator is null in SetAnimationParameters.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Ánh xạ actionType sang State&#10;        int state = actionType switch&#10;        {&#10;            CharacterActionType.Idle =&gt; 0,&#10;            CharacterActionType.Walk =&gt; 1,&#10;            CharacterActionType.Run =&gt; 2,&#10;            CharacterActionType.Sprint =&gt; 3,&#10;            CharacterActionType.Dash =&gt; 4,&#10;            CharacterActionType.Attack =&gt; 5,&#10;            CharacterActionType.Jump =&gt; 6,&#10;            CharacterActionType.ThrowItem =&gt; 7,&#10;            CharacterActionType.ThrowWeapon =&gt; 8,&#10;            _ =&gt; 0 // Mặc định là Idle&#10;        };&#10;&#10;        // Set State&#10;        _animator.SetInteger(&quot;State&quot;, state);&#10;&#10;        // Tính toán hướng nếu cần&#10;        float targetDirectionX = 0f;&#10;        float targetDirectionZ = 0f;&#10;        if (actionType == CharacterActionType.Walk || actionType == CharacterActionType.Run ||&#10;            actionType == CharacterActionType.Sprint || actionType == CharacterActionType.Dash ||&#10;            actionType == CharacterActionType.Attack)&#10;        {&#10;            // Nếu không có hướng di chuyển, sử dụng hướng nhân vật đang đối mặt&#10;            if (dir.sqrMagnitude &lt;= 0.001f)&#10;            {&#10;                if (actionType != CharacterActionType.Attack)&#10;                {&#10;                    _animator.SetInteger(&quot;State&quot;, 0); // Idle&#10;                    _animator.SetFloat(&quot;DirectionX&quot;, 0f);&#10;                    _animator.SetFloat(&quot;DirectionZ&quot;, 0f);&#10;                    currentDirectionX = 0f;&#10;                    currentDirectionZ = 0f;&#10;                    return;&#10;                }&#10;                dir = lastRotationDirection;&#10;            }&#10;&#10;            // Lấy hướng camera (nếu có) hoặc hướng nhân vật&#10;            Vector3 referenceForward = _playerInput._characterCamera?.mainCamera != null&#10;                ? _playerInput._characterCamera.mainCamera.transform.forward&#10;                : transform.forward;&#10;            referenceForward.y = 0;&#10;            referenceForward = referenceForward.normalized;&#10;&#10;            Vector3 referenceRight = Vector3.Cross(Vector3.up, referenceForward).normalized;&#10;&#10;            // Tính Dot product để xác định hướng mục tiêu&#10;            targetDirectionX = Vector3.Dot(dir.normalized, referenceRight);&#10;            targetDirectionZ = Vector3.Dot(dir.normalized, referenceForward);&#10;        }&#10;&#10;        // Làm mượt DirectionX và DirectionZ&#10;        currentDirectionX = Mathf.Lerp(currentDirectionX, targetDirectionX, smoothSpeed * Time.deltaTime);&#10;        currentDirectionZ = Mathf.Lerp(currentDirectionZ, targetDirectionZ, smoothSpeed * Time.deltaTime);&#10;&#10;        // Set DirectionX và DirectionZ&#10;        _animator.SetFloat(&quot;DirectionX&quot;, currentDirectionX);&#10;        _animator.SetFloat(&quot;DirectionZ&quot;, currentDirectionZ);&#10;&#10;        //Debug.Log($&quot;SetAnimationParameters: State={state}, DirectionX={currentDirectionX}, DirectionZ={currentDirectionZ}, TargetX={targetDirectionX}, TargetZ={targetDirectionZ}, dir={dir}&quot;);&#10;    }&#10;&#10;    // Hàm chạy animation tương ứng&#10;    private void PlayAnimation(int index)&#10;    {&#10;        // Đảm bảo Animator đã được gán&#10;        if (_animator == null)&#10;        {&#10;            Debug.LogError(&quot;Animator chưa được gán trong Inspector!&quot;);&#10;            return;&#10;        }&#10;&#10;        // Tên parameter trong Animator, giả sử là &quot;AnimationIndex&quot;&#10;        _animator.SetInteger(&quot;AnimationIndex&quot;, index);&#10;    }&#10;    #endregion&#10;&#10;    #region check collision&#10;&#10;    private void OnCollisionEnter(Collision collision)&#10;    {&#10;        if (collision?.gameObject.CompareTag(&quot;Ground&quot;) == true)&#10;        {&#10;            isGrounded = true;&#10;&#10;            // Triệt tiêu quán tính ngang khi tiếp đất&#10;            Vector3 vel = _rigidbody.linearVelocity;&#10;            vel.x = 0;&#10;            vel.z = 0;&#10;            _rigidbody.linearVelocity = vel;&#10;&#10;            // Thoát JumpState&#10;            if (CurrentPlayerState == CharacterStateType.Jump)&#10;            {&#10;                _core_02._stateMachine.SetState(new IdleState_1(_core_02._stateMachine, _playerEvent));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void OnCollisionExit(Collision collision)&#10;    {&#10;        if (collision == null) { return; }&#10;&#10;        if (collision.gameObject.CompareTag(&quot;Ground&quot;))&#10;        {&#10;            isGrounded = false;&#10;        }&#10;    }&#10;&#10;    private void HelpCheckGround()&#10;    {&#10;        //if (Time.time - lastCheckTime &lt; checkInterval) return;&#10;        //lastCheckTime = Time.time;&#10;&#10;        groundCheckPosition = transform.position + Vector3.down * 0.2f;&#10;&#10;        isGrounded = Physics.CheckSphere(groundCheckPosition, groundCheckRadius, invironmentLayer);&#10;    }&#10;&#10;    private void OnDrawGizmos()&#10;    {&#10;        if (config != null)&#10;        {&#10;            Gizmos.color = Color.red;&#10;            Gizmos.DrawWireSphere(transform.position + transform.forward * config.attackRange * 0.5f, config.attackRange);&#10;&#10;            Gizmos.color = isGrounded ? Color.green : Color.red;&#10;            Gizmos.DrawWireSphere(groundCheckPosition, groundCheckRadius);&#10;        }&#10;    }&#10;    #endregion&#10;&#10;    #region Actions &amp; logic Action&#10;&#10;    private bool WaitCheck()&#10;    {&#10;        if (Input.GetMouseButtonDown(0) &amp;&amp; !wait)&#10;        {&#10;            wait = true;&#10;            timer = waitTimeAt;&#10;        }&#10;        if (wait)&#10;        {&#10;            timer -= Time.deltaTime;&#10;            if (timer &lt;= 0)&#10;            {&#10;                wait = false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Trả về hướng nhìn hiện tại của camera từ trung tâm màn hình.&#10;    /// &lt;/summary&gt;&#10;    public Ray GetCameraRayCenter()&#10;    {&#10;        Camera cam = Camera.main;&#10;        return cam != null&#10;            ? cam.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0f))&#10;            : new Ray(Vector3.zero, Vector3.forward);&#10;    }&#10;&#10;    public void MarkHitPoint(Vector3 point)&#10;    {&#10;        // Tạo marker&#10;        if (currentMarker == null &amp;&amp; markerPrefab != null)&#10;        {&#10;            currentMarker = Instantiate(markerPrefab);&#10;        }&#10;&#10;        if (currentMarker != null)&#10;        {&#10;            currentMarker.transform.position = point;&#10;        }&#10;&#10;        // Tạo laser&#10;        if (laserLine == null)&#10;        {&#10;            GameObject laserObj = new GameObject(&quot;LaserLine&quot;);&#10;            laserLine = laserObj.AddComponent&lt;LineRenderer&gt;();&#10;            laserLine.material = laserMaterial;&#10;            laserLine.positionCount = 2;&#10;            laserLine.startWidth = laserWidth;&#10;            laserLine.endWidth = laserWidth;&#10;            laserLine.useWorldSpace = true;&#10;        }&#10;&#10;        // 3. Cập nhật line&#10;        Camera cam = Camera.main;&#10;        if (cam != null)&#10;        {&#10;            laserLine.SetPosition(0, FacePlayer.transform.position);&#10;            laserLine.SetPosition(1, point);&#10;        }&#10;    }&#10;&#10;    public Vector3 ReturnPoinHit()&#10;    {&#10;        if (CurrentLookAtHitPoint != null)&#10;        {&#10;            return CurrentLookAtHitPoint;&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;CurrentLookAtHitPoint is null. Returning Vector3.zero.&quot;);&#10;            return Vector3.zero;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// chiếu tia từ camera để kiểm tra đối tượng người chơi đang nhìn vào.&#10;    /// &lt;/summary&gt;&#10;    public void CheckItemByLooking()&#10;    {&#10;        try&#10;        {&#10;            if (Time.time - lastCheckTime &lt; checkInterval) return;&#10;            lastCheckTime = Time.time;&#10;&#10;            Ray ray = GetCameraRayCenter();&#10;            Debug.DrawRay(ray.origin, ray.direction * 15f, Color.red, 0.1f, true);&#10;&#10;            if (Physics.Raycast(ray, out RaycastHit hit, 50f, lookAtLayerMask))&#10;            {&#10;                CurrentSourcesLookAt = hit.collider.gameObject;&#10;                CurrentLookAtHitPoint = hit.point; // Lưu tọa độ điểm va chạm&#10;                MarkHitPoint(hit.point); // Gọi hàm đánh dấu&#10;                                         //Debug.Log($&quot;Looking at: {CurrentSourcesLookAt.name}&quot;);&#10;            }&#10;        }&#10;        catch (System.Exception)&#10;        {&#10;            Debug.Log(&quot;[PlayerController] lỗi con me no roi, ngu vai lon&quot;);&#10;        }&#10;&#10;    }&#10;&#10;    public void PickUp()&#10;    {&#10;        if (CurrentSourcesLookAt == null) return;&#10;&#10;        if (CurrentSourcesLookAt.layer == LayerMask.NameToLayer(&quot;Item&quot;))&#10;        {&#10;            CurrentSourcesLookAt.transform.SetParent(ListSlot.transform);&#10;            CurrentSourcesLookAt.SetActive(false);&#10;            Debug.Log($&quot;Added {CurrentSourcesLookAt.name} to ListSlot.&quot;);&#10;        }&#10;        else&#10;        {&#10;            Debug.LogWarning(&quot;The object is not an item and cannot be added to ListSlot.&quot;);&#10;        }&#10;    }&#10;&#10;    public float CalculateThrowForce()&#10;    {&#10;        float holdTime = throwTimer.UpdateTimer(false);&#10;        if (holdTime &lt;= 0f) return config.throwForceMin;&#10;        float force = Mathf.Lerp(config.throwForceMin, config.throwForceMax, holdTime / config.maxHoldTime);&#10;        return Mathf.Clamp(force, config.throwForceMin, config.throwForceMax);&#10;    }&#10;&#10;    private bool aim = false;&#10;    /// &lt;summary&gt;&#10;    /// Thay đổi góc nhìn của camera khi nhấn nút Aim.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;Input_M&quot;&gt;&lt;/param&gt;&#10;    public void Aim(bool Input_M)&#10;    {&#10;        if (_playerInput._characterCamera == null)&#10;        {&#10;            Debug.LogWarning(&quot;CharacterCamera is null in Aim!&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lưu trạng thái camera hiện tại nếu chưa lưu&#10;        if (!isCameraSettingsSaved)&#10;        {&#10;            savedDistance = _playerInput._characterCamera.maxDistance;&#10;            savedHeight = _playerInput._characterCamera.height;&#10;            isCameraSettingsSaved = true;&#10;            //Debug.Log($&quot;Aim: Saved camera state - Distance={savedDistance}, Height={savedHeight}&quot;);&#10;        }&#10;&#10;        if (Input_M)&#10;        {&#10;&#10;            _playerInput._characterCamera.transform.SetParent(transform);&#10;            _playerInput._characterCamera.SetTargetValues(config.targetMaxDistance, config.targetHeight, config.rightOffset, config.isAiming);&#10;            _playerInput._characterCamera.useInterpolation = false;&#10;            //Debug.Log(&quot;Aim: Entered aiming mode&quot;);&#10;            aim = true;&#10;        }&#10;        else&#10;        {&#10;            _playerInput._characterCamera.transform.SetParent(null);&#10;            _playerInput._characterCamera.useInterpolation = true;&#10;            _playerInput._characterCamera.SetTargetValues(savedDistance, savedHeight, _playerInput._characterCamera.rightOffset, false);&#10;            //Debug.Log($&quot;Aim: Exited aiming mode, Restored - Distance={savedDistance}, Height={savedHeight}&quot;);&#10;            isCameraSettingsSaved = false;&#10;            aim = false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Thay đổi tài nguyên giữa các slot trong ListBody.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;SLotBody&quot;&gt;&lt;/param&gt;&#10;    public void ChangeResource(int SLotBody)&#10;    {&#10;        if (ListBody[SLotBody].childCount &gt; 0)&#10;        {&#10;            if (ListBody[SLotBody].childCount &gt; 0 &amp;&amp; ListBody[1].childCount &gt; 0)&#10;            {&#10;                Transform childFromSlot3 = ListBody[SLotBody].GetChild(0);&#10;                Transform childFromSlot1 = ListBody[1].GetChild(0);&#10;&#10;                childFromSlot3.SetParent(ListBody[1], false);&#10;                childFromSlot1.SetParent(ListBody[SLotBody], false);&#10;&#10;                Debug.Log(&quot;Successfully swapped first children between ListBody[3] and ListBody[1]&quot;);&#10;            }&#10;            else if (ListBody[SLotBody].childCount &gt; 0)&#10;            {&#10;                Transform childFromSlot3 = ListBody[SLotBody].GetChild(0);&#10;                childFromSlot3.SetParent(ListBody[1], false);&#10;                Debug.Log(&quot;Moved child from ListBody[3] to ListBody[1]&quot;);&#10;            }&#10;            else if (ListBody[1].childCount &gt; 0)&#10;            {&#10;                Transform childFromSlot1 = ListBody[1].GetChild(0);&#10;                childFromSlot1.SetParent(ListBody[SLotBody], false);&#10;                Debug.Log(&quot;Moved child from ListBody[1] to ListBody[3]&quot;);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogWarning(&quot;No children to swap in ListBody[3] or ListBody[1]!&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// lấy GameObject từ list Slot và thay đổi chỉ mục của nó vào ListBody[2] &#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;Index&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    /// &lt;summary&gt;&#10;    /// lấy GameObject từ list Slot và thay đổi chỉ mục của nó vào ListBody[2] &#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;Index&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public GameObject ChangeSlotIndex(int index)&#10;    {&#10;        if (ListSlot == null || ListSlot.transform.childCount == 0)&#10;        {&#10;            Debug.LogWarning(&quot;[PlayerController] ListSlot is null or empty.&quot;);&#10;            return null;&#10;        }&#10;&#10;        if (index &lt; 0 || index &gt;= ListSlot.transform.childCount)&#10;        {&#10;            Debug.LogWarning($&quot;[PlayerController] Index {index} is out of bounds.&quot;);&#10;            return null;&#10;        }&#10;&#10;        // Trả item cũ về slot nếu có&#10;        if (previousIndex &gt;= 0 &amp;&amp; RightHandObject != null)&#10;        {&#10;            RightHandObject.transform.SetParent(ListSlot.transform, false);&#10;            //RightHandObject.SetActive(false);&#10;        }&#10;&#10;        // Lấy item mới từ index&#10;        Transform itemTransform = ListSlot.transform.GetChild(index);&#10;        GameObject newItem = itemTransform.gameObject;&#10;&#10;        newItem.transform.SetParent(ListBody[1].transform, false);&#10;        newItem.transform.localPosition = new Vector3(1f, 2f, 0f);&#10;        newItem.transform.localRotation = Quaternion.identity;&#10;        newItem.SetActive(true);&#10;&#10;        RightHandObject = newItem;&#10;        previousIndex = index;&#10;&#10;        if (deactivateCoroutine != null)&#10;            StopCoroutine(deactivateCoroutine);&#10;        deactivateCoroutine = StartCoroutine(DeactivateAfterDelay(newItem, 0.6f));&#10;&#10;        Debug.Log($&quot;[PlayerController] Equipped item '{newItem.name}' from ListSlot[{index}]&quot;);&#10;        return newItem;&#10;    }&#10;&#10;    private IEnumerator DeactivateAfterDelay(GameObject obj, float delay)&#10;    {&#10;        yield return new WaitForSeconds(delay);&#10;        if (obj != null)&#10;        {&#10;            obj.SetActive(false);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Giảm tốc độ di chuyển của player (dùng cho fear zone effect)&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;speedMultiplier&quot;&gt;Hệ số nhân tốc độ (0.5f = giảm 50%)&lt;/param&gt;&#10;    public void ReduceMovementSpeed(float speedMultiplier = 0.5f)&#10;    {&#10;        if (!isSpeedReduced)&#10;        {&#10;            originalSpeed = N_speed;&#10;            isSpeedReduced = true;&#10;        }&#10;        N_speed = originalSpeed * speedMultiplier;&#10;        Debug.Log($&quot;[PlayerController] Speed reduced to {N_speed} (multiplier: {speedMultiplier})&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Khôi phục tốc độ di chuyển ban đầu của player&#10;    /// &lt;/summary&gt;&#10;    public void RestoreMovementSpeed()&#10;    {&#10;        if (isSpeedReduced)&#10;        {&#10;            N_speed = originalSpeed;&#10;            isSpeedReduced = false;&#10;            Debug.Log($&quot;[PlayerController] Speed restored to {N_speed}&quot;);&#10;        }&#10;    }&#10;&#10;    #endregion&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>